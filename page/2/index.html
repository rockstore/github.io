<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/go/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/go/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/go/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/go/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/go/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/go/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/go/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Rock">
<meta property="og:url" content="https://rockstore.github.io/go/page/2/index.html">
<meta property="og:site_name" content="Rock">
<meta property="article:author" content="rockstore">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/go/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rockstore.github.io/go/page/2/"/>





  <title>Rock</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/go/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/go/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/go/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/go/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/go/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/05/design-pattern-component/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/05/design-pattern-component/" itemprop="url">组合模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T09:42:04+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>组合模式是一种对象的结构型模式，也被称为”部分-整体”模式，组合模式将对象整合到树结构中，用来描述部分与整体的关系， Android 中的 View 和 ViewGroup 就使用到了组合模式，会在后面分析。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将对象整合成树形结构以表示“部分-整体”的层次结构，使得用户对单个对象和组合对象的操作具有一致性。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对象可以整合成树形的层次结构，且对单个对象和组合的操作具有一致性。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="http://p0.qhimg.com/t01e3daa698c399c040.png" alt=""></p>
<p>组合模式涉及到3种角色：</p>
<p><strong>抽象组件角色</strong>：抽象角色，定义参加组合对象的公共接口以及默认行为</p>
<p><strong>树叶组件角色</strong>：树叶组件没有子对象，实现参加组合的原始对象的行为</p>
<p><strong>树枝组件角色</strong>：有子对象的组件，同时定义了对子对象的管理方法。</p>
<p>在上面的 UML 中展示的组合模式中，只有树枝组件角色定义了组件管理的方法，树叶组件只实现了抽象组件定义的方法，树叶组件和树枝组件具有不同的操作，这种组合成为安全组合模式。既然有安全组合模式，是否存在不安全的组合模式呢？有，但是不安全的组合模式成为透明组合。</p>
<p><img src="http://p0.qhimg.com/t0119919f978ab26255.png" alt=""></p>
<p>如上图所示，在透明组合模式中，抽象组件定义了所有树叶组件和树枝组件的方法。这些方法包括原始对象的行为 operation 以及管理组件的行为，所有的树叶组件和树枝组件都需要实现这些方法。由于所有的组件都实现相同的方法，在调用管理组件的方法时需要进行判断组件是否为树叶组件，如果是树叶组件则无法执行管理组件的方法，这就是透明组合的不安全点。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>安全组合和透明组合模式的实现，分别对应两种 UML 。</p>
<h3 id="安全组合"><a href="#安全组合" class="headerlink" title="安全组合"></a>安全组合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Leaf operation"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Component&gt; components;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Composite operation"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Component component : components) &#123;</span><br><span class="line">			component.operation();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/****************manage operations*****************/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addComponent</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">		components.add(component);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeComponent</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">		components.remove(component);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Component <span class="title">getComponent</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> components.get(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    Leaf leaf1 = <span class="keyword">new</span> Leaf();</span><br><span class="line">    Leaf leaf2 = <span class="keyword">new</span> Leaf();</span><br><span class="line"></span><br><span class="line">    Composite composite = <span class="keyword">new</span> Composite();</span><br><span class="line">    composite.addComponent(leaf1);</span><br><span class="line">    composite.addComponent(leaf2);</span><br><span class="line"></span><br><span class="line">    leaf1.operation();</span><br><span class="line">    composite.operation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Leaf operation</span><br><span class="line">Composite operation</span><br><span class="line">Leaf operation</span><br><span class="line">Leaf operation</span><br></pre></td></tr></table></figure>



<p>如以上代码所示，安全组合中，只有树枝节点实现了组件管理方法，在树叶节点无法调用组件管理方法。</p>
<h3 id="透明组合"><a href="#透明组合" class="headerlink" title="透明组合"></a>透明组合</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addComponent</span><span class="params">(Component component)</span> <span class="keyword">throws</span> UnsupportedOperationException</span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeComponent</span><span class="params">(Component component)</span> <span class="keyword">throws</span> UnsupportedOperationException</span>; </span><br><span class="line">	<span class="function">Component <span class="title">getComponent</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> UnsupportedOperationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Leaf operation"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addComponent</span><span class="params">(Component component)</span> <span class="keyword">throws</span> UnsupportedOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"leaf can not addComponent"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeComponent</span><span class="params">(Component component)</span> <span class="keyword">throws</span> UnsupportedOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"leaf can not remoevComponent"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> Component <span class="title">getComponent</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> UnsupportedOperationException </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"leaf can not getComponent"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Component&gt; components;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		components = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Composite operation"</span>);</span><br><span class="line">		<span class="keyword">for</span> (Component component : components) &#123;</span><br><span class="line">			component.operation();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/****************manage operations*****************/</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addComponent</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">		components.add(component);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeComponent</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">		components.remove(component);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Component <span class="title">getComponent</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> components.get(index);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    Leaf leaf1 = <span class="keyword">new</span> Leaf();</span><br><span class="line">    Leaf leaf2 = <span class="keyword">new</span> Leaf();</span><br><span class="line"></span><br><span class="line">    Composite composite = <span class="keyword">new</span> Composite();</span><br><span class="line">    composite.addComponent(leaf1);</span><br><span class="line">    composite.addComponent(leaf2);</span><br><span class="line"></span><br><span class="line">    leaf1.operation();</span><br><span class="line">    composite.operation();</span><br><span class="line">    leaf1.addComponent(leaf2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Leaf operation</span><br><span class="line">Composite operation</span><br><span class="line">Leaf operation</span><br><span class="line">Leaf operation</span><br><span class="line">Exception in thread <span class="string">"main"</span> java.lang.UnsupportedOperationException: leaf can not addComponent</span><br><span class="line">	at com.rock.composite.transparent.Leaf.addComponent(Leaf.java:<span class="number">14</span>)</span><br><span class="line">	at com.rock.composite.transparent.Client.main(Client.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>在透明组合模式中，抽象组件定义组件不仅定义了原始的行为 operation ，还定义组件管理行为，树叶和树枝节点。在程序运行期间，在调用组件管理方法之前，需要进行类型判断，否则会抛出 UnsupportedOperationException，这就是透明模式的不安全点。</p>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>上面的实现根据组合模式的 UML 实现了简单的组合，现在有一个需求，需要自己实现一套文件管理，需要实现文件的添加，删除，修改文件名。</p>
<p><img src="http://p0.qhimg.com/t012b8c957ab6005259.png" alt=""></p>
<p>如上图所示，为 Windows 的 C 盘的部分文件结构，浅红色的是文件夹，白色是文件，毫无疑问，文件系统是树形结构。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IFile</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addFile</span><span class="params">(IFile file)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">renameFile</span><span class="params">(String newName)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exist</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象组件 IFile 定义文件的操作，添加 addFile，删除 deleteFile，重命名 renameFile，且定义获取文件名 getName 和判断文件是否存在接口 exist</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFile</span> <span class="keyword">implements</span> <span class="title">IFile</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String fileName;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		fileName = name;</span><br><span class="line">		exist = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		<span class="keyword">return</span> fileName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFile</span><span class="params">(IFile file)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"concretefile can not add file"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		exist = <span class="keyword">false</span>;</span><br><span class="line">		System.out.println(<span class="string">"file "</span> + fileName + <span class="string">" has been deleted"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renameFile</span><span class="params">(String newName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		fileName = newName;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"file "</span> + fileName + <span class="string">" does not exist!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> exist;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通文件不能执行添加文件操作，执行添加文件操作会抛出 UnsupportedOperationException 异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirFile</span> <span class="keyword">implements</span> <span class="title">IFile</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> String dirName;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> exist = <span class="keyword">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;IFile&gt; files = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">DirFile</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		dirName = name;</span><br><span class="line">		exist = <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		<span class="keyword">return</span> dirName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFile</span><span class="params">(IFile file)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		files.add(file);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteFile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		exist = <span class="keyword">false</span>;</span><br><span class="line">		System.out.println(<span class="string">"dir "</span> + dirName + <span class="string">" has been deleted"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">renameFile</span><span class="params">(String newName)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		checkExist();</span><br><span class="line">		dirName = newName;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkExist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!exist) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"dir "</span> + dirName + <span class="string">" does not exist!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exist</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> exist;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">    ConcreteFile file1 = <span class="keyword">new</span> ConcreteFile(<span class="string">"test.txt"</span>);</span><br><span class="line">    ConcreteFile file2 = <span class="keyword">new</span> ConcreteFile(<span class="string">"dat.bat"</span>);</span><br><span class="line"></span><br><span class="line">    DirFile dir1 = <span class="keyword">new</span> DirFile(<span class="string">"backup"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加文件</span></span><br><span class="line">    dir1.addFile(file1);</span><br><span class="line">    dir1.addFile(file2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除</span></span><br><span class="line">    file1.deleteFile();</span><br><span class="line">    file2.deleteFile();</span><br><span class="line">    dir1.deleteFile();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    ConcreteFile file3 = <span class="keyword">new</span> ConcreteFile(<span class="string">"learn.doc"</span>);</span><br><span class="line">    System.out.println(<span class="string">"file3 name:"</span> + file3.getName());</span><br><span class="line">    file3.renameFile(<span class="string">"learn_design.doc"</span>);</span><br><span class="line">    System.out.println(<span class="string">"file3 name:"</span> + file3.getName());</span><br><span class="line"></span><br><span class="line">    DirFile dir2 = <span class="keyword">new</span> DirFile(<span class="string">"learn"</span>);</span><br><span class="line">    System.out.println(<span class="string">"dir2 name:"</span> + dir2.getName());</span><br><span class="line">    dir2.renameFile(<span class="string">"learn_design"</span>);</span><br><span class="line">    System.out.println(<span class="string">"dir2 name:"</span> + dir2.getName());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">file test.txt has been deleted</span><br><span class="line">file dat.bat has been deleted</span><br><span class="line">dir backup has been deleted</span><br><span class="line">file3 name:learn.doc</span><br><span class="line">file3 name:learn_design.doc</span><br><span class="line">dir2 name:learn</span><br><span class="line">dir2 name:learn_design</span><br></pre></td></tr></table></figure>

<p>在对普通文件 ConcreteFile 和目录文件 DirFile 进行添加，删除，重命名时，添加了文件存在的判断，如果文件已经被删除，则不能执行响应的操作。</p>
<h2 id="组合模式在-Android-中的应用"><a href="#组合模式在-Android-中的应用" class="headerlink" title="组合模式在 Android 中的应用"></a>组合模式在 Android 中的应用</h2><p>组合模式在 Android 中最经典的应用应该属于 View 组件的设计了。 </p>
<p><img src="http://p0.qhimg.com/t013098ead7231b2135.png" alt=""></p>
<p>上图为 Android 中 View 组件中的组合模式设计。 View 类定义了组件的一些默认行为， ImageView 相当于组合模式中的树叶组件， ViewGroup 中可以添加其他类型的 View， 是组合模式中树枝组件，可以包含其他 View 组件，并提供了管理组件的方法。</p>
<p>很显然， Android 中 View 组件的组合模式是安全的组合模式，树枝节点 ViewGroup 有管理组件的方法，树叶组件并没有。</p>
<h2 id="安全和透明的选择"><a href="#安全和透明的选择" class="headerlink" title="安全和透明的选择"></a>安全和透明的选择</h2><p>安全组合中，由于树枝组件和树叶组件定义了不同的方法，对于客户端来说，在树叶组件上不会执行树枝组件的方法，不会抛出异常；透明组合中，由于树枝组件和树叶组件定义了相同的方法，树枝和树叶失去了类型信息，在执行树枝组件才有的方法之前，需要对组件的类型进行判断，否则可能会抛出异常。</p>
<p>虽然组合的目的是为了是单个对象和组合对象的操作具有统一性，但在具体实践的过程中仍然需要根据实际的需求进行选择。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或者部分层次，它让高层模块忽略了层次的差异，方便对层次结构进行控制</li>
<li>客户端可以使用一致的结构对单个对象或组合对象进行操作，不必关注对象类型</li>
<li>组合模式中新增树叶节点或者树枝节点时无需对现有结构进行修改</li>
<li>如果使用透明组合，由于系统中所有节点都实现了相同的接口，无法根据类型判断是否可对其进行某些操作，需要进行显式类型转换</li>
</ul>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p>1.《 Android 源码设计模式解析与实战》</p>
<p>2.《JAVA与模式》之合成模式</p>
<p>  <a href="https://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-my-life/archive/2012/04/17/2453861.html</a></p>
<p>3.java设计模式之组合模式</p>
<p>  <a href="https://www.cnblogs.com/lfxiao/p/6816026.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfxiao/p/6816026.html</a></p>
<p>4.Java设计模式之《组合模式》及应用场景</p>
<p>  <a href="https://www.cnblogs.com/V1haoge/p/6489827.html" target="_blank" rel="noopener">https://www.cnblogs.com/V1haoge/p/6489827.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/05/design-pattern-bridge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/05/design-pattern-bridge/" itemprop="url">桥接模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T09:41:51+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>将抽象(Abstract)和实现(Implement)解耦，使得抽象和实现可以独立变化。</p>
<p>定义很简单，但是理解起来却感觉一头雾水。。。。。。这个设计模式平时接触的可能比较少，要想有一个大致的了解，直接来个场景分析一下</p>
<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>场景分析借鉴了设计模式之禅。商人资金雄厚，准备生产交通工具赚钱，这里的交通工具是很简单，只要是能走，能带不就行（纯属例子）。商人觉得最近共享单车特别火，于是就开工厂生产共享单车；又过了一段时间，发现共享电动车特别火，于是开工厂生产共享电动车。当然，生产的这些交通工具都需要卖出去才能赚钱。</p>
<p>交通工具定义了，接下来要定义工厂基类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 生产商品</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">makeProduct</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 销售商品</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sellProduct</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 赚钱</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.makeProduct();</span><br><span class="line">		<span class="keyword">this</span>.sellProduct();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂的基类很简单，定义了生产商品，销售商品的接口，并定义了赚钱的接口，赚钱就是生产商品并销售出去。</p>
<p>需求中说过，需要生产共享单车，共享电动车，共享汽车，于是，需要定义三个交通工具类</p>
<p>生产上面两种交通工具，需要两个工厂：</p>
<p>自行车工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BikeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"bike is made!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"bike is sold"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.makeMoney();</span><br><span class="line">		System.out.println(<span class="string">"BikeFactory makeMoney"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>电动车工厂：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricBikeFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ElectricBikeFactory makes ElectricBike"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sellProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ElectricBike is sold"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.makeMoney();</span><br><span class="line">		System.out.println(<span class="string">"ElectricBikeFactory make money"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试一下生产过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">		BikeFactory bikeFactory = <span class="keyword">new</span> BikeFactory();</span><br><span class="line">		bikeFactory.makeMoney();</span><br><span class="line">		</span><br><span class="line">		ElectricBikeFactory electricBikeFactory = <span class="keyword">new</span> ElectricBikeFactory();</span><br><span class="line">		electricBikeFactory.makeMoney();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BikeFactory makes Bike!!</span><br><span class="line">Bike is sold</span><br><span class="line">BikeFactory makeMoney</span><br><span class="line">ElectricBikeFactory makes ElectricBike</span><br><span class="line">ElectricBike is sold</span><br><span class="line">ElectricBikeFactory make money</span><br></pre></td></tr></table></figure>

<p>OK，共享单车和共享电动车已经成功为老板盈利了。突然有一天，共享汽车又火了，老板又要新建汽车工厂生产汽车了，OK，也没问题，继续新建汽车工厂，马上又满足了，又过了一段时间，共享 XXX 火了，老板要新建 XXX 工厂。</p>
<p>火了一个共享单车，就新建共享单车工厂，火了共享电动车，就新建共享电动车工厂，火了共享汽车就新建汽车工厂，老板即使再有钱，也不能这么造啊，反正老板只打算跟风，为什么不能在同一个工厂生产多种产品呢？作为程序员的你，一下就明白了，商品不能和工厂绑定太紧了，商品和工厂需要能够独立进行变化，既然可以独立变化，商品也需要进行抽象。由于是商品，不管是单车，电动车还是汽车，只要能生产并卖出去即可：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IVehicle</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">beMade</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">beSold</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来定义自行车，电动车和汽车</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bike</span> <span class="keyword">implements</span> <span class="title">IVehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beMade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Bike is being made!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beSold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Bike is being sold!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElectricBike</span> <span class="keyword">implements</span> <span class="title">IVehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beMade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ElectricBike is being made!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beSold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ElectricBike is being sold!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">IVehicle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beMade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Car is being made!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beSold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Car is being sold!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>既然商品不能和工厂强绑定，需要对工厂进行修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> IVehicle vehicle;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AbstractFactory</span><span class="params">(IVehicle vehicle)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.vehicle = vehicle;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (vehicle != <span class="keyword">null</span>) &#123;</span><br><span class="line">			vehicle.beMade();</span><br><span class="line">			vehicle.beSold();</span><br><span class="line">			System.out.println(<span class="string">"makeMoney haha!!"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就定义一个工厂</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ConcreteFactory</span><span class="params">(IVehicle vehicle)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(vehicle);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">makeMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.makeMoney();</span><br><span class="line">		System.out.println(<span class="string">"ConcreteFactory makeMoney"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OK，接下来让这个工厂生产自行车，当然，也可以生产电动车和汽车。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Boss</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		Bike bike = <span class="keyword">new</span> Bike();</span><br><span class="line"><span class="comment">//		ElectricBike electricBike = new ElectricBike();</span></span><br><span class="line"><span class="comment">//		Car car = new Car();</span></span><br><span class="line">		ConcreteFactory factory = <span class="keyword">new</span> ConcreteFactory(bike);</span><br><span class="line">		factory.makeMoney();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有一天突然发现，原来的共产产能不足，没关系，在新建一个工厂，这个工厂依然可以生产自行车，电动车和汽车，新建的工厂甚至可以添加自己的属性和方法。而且还可以发现，修改之后，只是用一个工厂就可以生产三种不同的产品，工厂类数量减少了。</p>
<p>可以看到，使用这种方式后，工厂和产品之间已经实现了解耦，不存在依赖关系，他们之间可以自由演化扩展，这就是桥接模式。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/bridge.png" alt=""></p>
<p>如上 UML 所示，桥接模式有四种角色：</p>
<ul>
<li><p>Abstraction 抽象化角色</p>
<p>定义该角色的行为，同时保存一个对实现化角色的引用，该角色一般是抽象类。</p>
</li>
<li><p>Implementor 实现化角色</p>
<p>定义实现化角色的行为和属性。</p>
</li>
<li><p>RefinedAbstraction 修正抽象化角色</p>
<p>引用实现化角色对抽象化角色的行为进行修改</p>
</li>
<li><p>ConcreteImplementorA  ConcreteImplementorB 具体实现化角色</p>
<p>实现实现化接口中的方法</p>
</li>
</ul>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><p>首先定义抽象化角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Implementor implementor;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Abstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.implementor = implementor;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (implementor != <span class="keyword">null</span>) &#123;</span><br><span class="line">			implementor.doSomething();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Implementor <span class="title">getImplementor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> implementor;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象实现化角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">doOtherthing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体实现化角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorA</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ConcreteImplementorA doSomething"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherthing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ConcreteImplementorA doOtherthing"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementorB</span> <span class="keyword">implements</span> <span class="title">Implementor</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ConcreteImplementorB doSomething"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doOtherthing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ConcreteImplementorB doOtherthing"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正抽象化角色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">RefinedAbstraction</span><span class="params">(Implementor implementor)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(implementor);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">super</span>.request();</span><br><span class="line">		getImplementor().doOtherthing();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		Implementor implementorA = <span class="keyword">new</span> ConcreteImplementorA();</span><br><span class="line">		Abstraction abstractionA = <span class="keyword">new</span> RefinedAbstraction(implementorA);</span><br><span class="line">		abstractionA.request();</span><br><span class="line">		</span><br><span class="line">		Implementor implementorB = <span class="keyword">new</span> ConcreteImplementorB();</span><br><span class="line">		Abstraction abstractionB = <span class="keyword">new</span> RefinedAbstraction(implementorB);</span><br><span class="line">		abstractionB.request();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcreteImplementorA doSomething</span><br><span class="line">ConcreteImplementorA doOtherthing</span><br><span class="line">ConcreteImplementorB doSomething</span><br><span class="line">ConcreteImplementorB doOtherthing</span><br></pre></td></tr></table></figure>

<h2 id="桥接模式在-Android-中的应用"><a href="#桥接模式在-Android-中的应用" class="headerlink" title="桥接模式在 Android 中的应用"></a>桥接模式在 Android 中的应用</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/bridge_window.png" alt=""></p>
<p>Window 和 WindowManager 是典型的桥接模式，Window 类是桥接模式中的抽象化角色，持有实现化角色 WindowManager 的的实例； PhoneWindow 是修正抽象化角色，使用 WindowManager 提供的接口对内部的 View 进行添加删除等操作；WindowManagerImpl 为具体实现化角色。</p>
<p>桥接模式在 Android 的 ListView 和 Adapter 中也有非常经典的使用，可以参考 <a href="https://blog.csdn.net/u010405231/article/details/49618511" target="_blank" rel="noopener">Android设计模式源码解析之桥接模式</a></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul>
<li><p>抽象和实现的分离</p>
<p>抽象和实现充分解耦，抽象和实现可以独立演化。</p>
</li>
<li><p>优秀的扩充</p>
<p>具体抽象化角色和具体实现角色可以任意扩展。如果需要新增具体抽象化角色或者具体实现化角色，只需要定义一个新的具体抽象化类或者具体实现化类即可，不需要修改其他任何东西。</p>
</li>
<li><p>屏蔽实现细节</p>
<p>具体实现化类的实现细节对具体抽象化角色透明，具体抽象化角色不依赖具体实现化角色的细节。</p>
</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>要说桥接模式的缺点， 可能就是需要对系统有充分的理解。需要开发者可以识别两个独立变化的纬度，能够抽象出抽象实现角色以及抽象角色，否则可能会造成桥接模式使用不合理。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>桥接模式 <a href="https://www.cnblogs.com/WindSun/p/10260547.html" target="_blank" rel="noopener">https://www.cnblogs.com/WindSun/p/10260547.html</a></p>
<p>《JAVA与模式》之桥梁模式 <a href="https://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-my-life/archive/2012/05/07/2480938.html</a></p>
<p>《设计模式之禅》</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/05/design-pattern-adapter/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/05/design-pattern-adapter/" itemprop="url">适配器模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T09:41:35+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>把一个类的接口转换成客户期待的另一种接口，从而是原本不匹配的而无法在一起工作的两个类能一起工作。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>需要重用现有的类，但是现有类的接口不符合需要，即接口不兼容</li>
<li>需要建立一个可以重复使用的类，用于与一些彼此之间没有太多关联的一些类，包括一些可能在将来引进的类一起工作</li>
<li>需要统一的输出接口，而输入端的类型不可预知</li>
</ul>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>适配器模式分类适配和对象适配，首先分析类适配器。类适配器通过实现 Target 接口，继承 Adaptee 实现接口转换。</p>
<p><img src="http://p0.qhimg.com/t0158985eeb62561301.png" alt=""></p>
<p>如上图所示为类适配器结构。客户端需要的目标接口是 Target ， Target 接口包含 operate1 和 operate2 接口， Adaptee 只有 operate2 接口，出现了接口不匹配，故需要对 Adaptee 的接口进行转换，此时通过 Adapter 将 Adaptee 的 operate2 转换成客户端需要的 operate2 操作。</p>
<p>角色介绍：</p>
<ul>
<li><p>Target</p>
<p>目标角色，即期待得到的接口</p>
</li>
<li><p>Adaptee</p>
<p>需要适配的类</p>
</li>
<li><p>Adapter</p>
<p>适配器，负责将 Adaptee 的接口转换成 Target 中的目标接口</p>
</li>
</ul>
<p><img src="http://p0.qhimg.com/t019fe6c661411bc04c.png" alt=""></p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operate1</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">operate2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Adaptee operate2"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Target 为目标接口， Adaptee 为需要适配的类，接下来分别使用 类适配和对象适配的方式实现 Adaptee 的适配：</p>
<p><strong>类适配</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span>  </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Adapter operate1"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Adapter operate2"</span>);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>对象适配</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类适配与对象适配的对比"><a href="#类适配与对象适配的对比" class="headerlink" title="类适配与对象适配的对比"></a>类适配与对象适配的对比</h2><ul>
<li>类适配器使用继承的方式，直接继承 Adaptee ，所以无法对 Adaptee 的子类进行适配</li>
<li>对象适配器模式使用组合方式，Adaptee 的子类都可以被适配。对象适配器对于增加一些新行为非常方便，而且新增加的行为同时适用于所有 Adaptee 及其子类。</li>
</ul>
<h2 id="简单应用"><a href="#简单应用" class="headerlink" title="简单应用"></a>简单应用</h2><p>国内的居民用电电压是 220v , 我们使用的手机充电器也支持 220v 电压，现在到你到美国去旅游，但是美国的电压是 110v ，手机充电器不能直接使用，需要进行电压适配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Vol220</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">get220Vol</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Vol110</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get110Vol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">110</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Vol110</span> <span class="keyword">implements</span> <span class="title">Vol220</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get220Vol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>经过 Adapter 的转换， 110v 的电压 Vol110 输出了 220v 的电压。也可以使用对象适配的方式实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Vol220</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">private</span> Vol110 vol110;</span><br><span class="line">    </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">AdapterObj</span><span class="params">(Vol110 vol110)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.vol110 = vol110;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get220Vol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">220</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="缺省适配"><a href="#缺省适配" class="headerlink" title="缺省适配"></a>缺省适配</h2><p>缺省适配是一种“平庸化”的适配器模式，这种适配的方式可能和类适配与对象适配在表现形式上不同，但目的是一样的。</p>
<p>公司现在需要招聘员工，要求员工至少掌握 Java, C++, Python 中的一门语言。接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWorker</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">java</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">cPlus</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">python</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并不是所有的员工都掌握这三种语言，很多开发人员只会其中的一种或者两种。假设直接使用类或者对象适配，则每个适配器 Adapter 都需要实现这三个方法，使用缺省适配则会避免这种情况。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WorkerAdapter</span> <span class="keyword">implements</span> <span class="title">IWorker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">java</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cPlus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">python</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用缺省适配后，应聘者可以继承 WorkerAdapter 类，掌握任意一门语言，只需要重写对应的方法即可，避免每个应聘者都需要实现三门语言。</p>
<p><img src="http://p0.qhimg.com/t01302eba47af969706.png" alt=""></p>
<p>添加了 WorkerAdapter 类，应聘者只需要根据自己擅长的语言实现对应的方法即可。缺省适配和标准的类适配与对象适配在实现形式上有较大的不同，但是实现的结果却是一样的，后面进行分析。</p>
<h2 id="适配器与装饰器"><a href="#适配器与装饰器" class="headerlink" title="适配器与装饰器"></a>适配器与装饰器</h2><p>适配器模式是为了改变原对象的接口，以便与目标接口相符合；装饰器模式对原对象进行功能增强。</p>
<p>理想情况下，使用装饰器模式对被装饰对象进行功能增强的同时，要求具体构件角色，装饰角色和抽象构件角色的接口保持完全一致，这样的装饰模式称为透明装饰；在实际开发中，装饰角色往往会在抽象构件接口的基础上添加新的接口，这样的装饰称为半透明装饰，此时的装饰角色已经成为适配器角色。</p>
<p><img src="http://p0.qhimg.com/t01435136e7e7e83cca.png" alt=""></p>
<p>通过在功能增强和接口改变上的不断变化，装饰角色在透明性上也不断变化，伴随着透明性的降低，装饰角色逐渐演变为适配角色。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://blog.csdn.net/mrkohaku/article/details/79087688" target="_blank" rel="noopener">https://blog.csdn.net/mrkohaku/article/details/79087688</a></p>
<p><a href="https://www.cnblogs.com/LUA123/p/7824791.html" target="_blank" rel="noopener">https://www.cnblogs.com/LUA123/p/7824791.html</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html" target="_blank" rel="noopener">https://www.cnblogs.com/java-my-life/archive/2012/04/20/2455726.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/04/design-pattern-proto/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/04/design-pattern-proto/" itemprop="url">原型模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T23:49:28+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于新建对象时最常见的方式为new，故原型模式在Android实际开发中用的不多，本文从原型模式的定义出发，深入分析对象复制过程中需要注意的点。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。可以简单的理解为通过复制已经存在的实例创建新的实例。</p>
<h2 id="浅复制，深复制"><a href="#浅复制，深复制" class="headerlink" title="浅复制，深复制"></a>浅复制，深复制</h2><p>既然是对象的复制，必须要考虑的就是浅复制和深复制的问题。<br>java中的数据可分为基本数据类型和引用数据类型。这两种数据类型在进行赋值操作，参数传递，结果返回时分为值传递和引用传递。</p>
<ul>
<li>浅复制<br>有基本类型属性的对象，在进行复制时直接进行值传递，新对象对值的修改不影响原对象；对于有引用类型数据属性的对象，在进行复制时进行引用传递，新对象对属性的修改会影响原对象。Object类的clone方法就是浅复制。</li>
<li>深复制<br>深复制不仅要复制对象基本类型数据，还要为所有引用类型的成员申请存储空间，并复制每个引用成员所执行的对象</li>
</ul>
<p>可以参考<a href="https://www.cnblogs.com/shakinghead/p/7651502.html" target="_blank" rel="noopener">Java 浅拷贝和深拷贝的理解和实现方式</a> 深入了解下。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>Demo部分的演示主要为了演示浅复制和深复制，演示场景分数组和非数组。<br>基本数据类型就不用演示了，首先看第一个demo:</p>
<pre><code>class Stu {
    String name;
    int age;
    public Stu(String n, int a) {
        name = n;
        age = a;
    }
}

public class Client {
    public static void main(String [] args) {
        int [] originIntArr = {1,2,3};
        int [] copyIntArr = originIntArr.clone();
        copyIntArr[0] = 4;
        System.out.println(originIntArr[0] + &quot;-&quot; + copyIntArr[0]);

        String [] originStrArr = {&quot;abc&quot;, &quot;def&quot;, &quot;ghi&quot;};
        String [] copyStrArr = originStrArr.clone();
        copyStrArr[0] = &quot;xyz&quot;;
        System.out.println(originStrArr[0] + &quot;-&quot; + copyStrArr[0]);

        Stu [] originStuArr = {new Stu(&quot;peter&quot;, 12), new Stu(&quot;mark&quot;, 13), new Stu(&quot;lily&quot;, 18)};
        Stu [] copyStuArr = originStuArr.clone();
        copyStuArr[0].name = &quot;rock&quot;;
        System.out.println(originStuArr[0].name + &quot;-&quot; + copyStuArr[0].name);
    }
}</code></pre><p>程序运行如下：</p>
<pre><code>1-4
abc-xyz
rock-rock</code></pre><p>经过clone操作后，由于int数组的内容是基本数据类型，故clone操作执行后是值赋值，复制后对象的修改不影响原对象；那为什么String是引用类型，复制后对象的修改还是不影响原对象呢？String类型的数据是常量数据，放在常量池中，当我们将一个String类型的引用进行修改时，并不是修改了原来的常量，而是在常量池中添加了一个新的常量并将引用指向了这个常量，故String类型修改不会影响原对象；最后一个就很好的解释了clone复制时浅复制，仅仅复制了引用，clone后的引用指向了原来的对象。</p>
<p>再修改一下：</p>
<pre><code>class Stu implements Cloneable {
    String name;
    int age;
    public Stu(String n, int a) {
        name = n;
        age = a;
    }

    @Override
    public Object clone() {
        // TODO Auto-generated method stub
        Stu clone = null;
        try {
            clone = (Stu) super.clone();
        } catch (CloneNotSupportedException e) {
            // TODO: handle exception
        }
        return clone;
    }
}

public class Client {
    public static void main(String [] args) {
        Stu originStu = new Stu(&quot;peter&quot;, 18);
        Stu copyStu = (Stu) originStu.clone();
        copyStu.name = &quot;mike&quot;;
        copyStu.age = 20;
        System.out.println(&quot;origin:&quot; + originStu.name + &quot;-&quot; + originStu.age + &quot;\n&quot; + 
                            &quot;copy:&quot; + copyStu.name + &quot;-&quot; + copyStu.age);
    }
}</code></pre><p>程序运行如下：</p>
<pre><code>origin:peter-18
copy:mike-20</code></pre><p>以上代码不足以说明问下，现在假设每个学生配一名老师：</p>
<pre><code>class Stu implements Cloneable {
    String name;
    int age;
    Teacher teacher;
    public Stu(String n, int a, Teacher t) {
        name = n;
        age = a;
        teacher = t;
    }

    @Override
    public Object clone() {
        // TODO Auto-generated method stub
        Stu clone = null;
        try {
            clone = (Stu) super.clone();
        } catch (CloneNotSupportedException e) {
            // TODO: handle exception
        }
        return clone;
    }
}

class Teacher {
    String name;
    public Teacher(String n) {
        // TODO Auto-generated constructor stub
        name = n;
    }
}

public class Client {
    public static void main(String [] args) {
        Stu originStu = new Stu(&quot;peter&quot;, 18, new Teacher(&quot;smith&quot;));
        Stu copyStu = (Stu) originStu.clone();
        copyStu.name = &quot;mike&quot;;
        copyStu.age = 20;
        copyStu.teacher.name = &quot;amily&quot;;
        System.out.println(&quot;origin:&quot; + originStu.name + &quot;-&quot; + originStu.age + &quot;-&quot; + originStu.teacher.name +&quot;\n&quot; + 
                            &quot;copy:&quot; + copyStu.name + &quot;-&quot; + copyStu.age + &quot;-&quot; + copyStu.teacher.name);
    }
}</code></pre><p>程序运行结果如下：</p>
<pre><code>origin:peter-18-amily
copy:mike-20-amily</code></pre><p>发现，由于Stu类的clone默认是引用复制，符originStu和copyStu指向同一个Teacher对象，copyStu对Teacher的修改影响了originStu，那有没有办法让复制变为深复制呢？只需要实现Teacher的clone方法即可：</p>
<pre><code>class Stu implements Cloneable {
    String name;
    int age;
    Teacher teacher;
    public Stu(String n, int a, Teacher t) {
        name = n;
        age = a;
        teacher = t;
    }

    @Override
    public Object clone() {
        // TODO Auto-generated method stub
        Stu clone = null;
        try {
            clone = (Stu) super.clone();
            clone.teacher = (Teacher) teacher.clone();
        } catch (CloneNotSupportedException e) {
            // TODO: handle exception
        }
        return clone;
    }
}

class Teacher implements Cloneable {
    String name;
    public Teacher(String n) {
        // TODO Auto-generated constructor stub
        name = n;
    }

    @Override
    public Object clone() {
        // TODO Auto-generated method stub
        Teacher clone = null;
        try {
            clone = (Teacher) super.clone();
        } catch (CloneNotSupportedException e) {
            // TODO: handle exception
        }
        return clone;
    }
}

public class Client {
    public static void main(String [] args) {
        Stu originStu = new Stu(&quot;peter&quot;, 18, new Teacher(&quot;smith&quot;));
        Stu copyStu = (Stu) originStu.clone();
        copyStu.name = &quot;mike&quot;;
        copyStu.age = 20;
        copyStu.teacher.name = &quot;amily&quot;;
        System.out.println(&quot;origin:&quot; + originStu.name + &quot;-&quot; + originStu.age + &quot;-&quot; + originStu.teacher.name +&quot;\n&quot; + 
                            &quot;copy:&quot; + copyStu.name + &quot;-&quot; + copyStu.age + &quot;-&quot; + copyStu.teacher.name);
    }
}</code></pre><p>程序运行结果：</p>
<pre><code>origin:peter-18-smith
copy:mike-20-amily</code></pre><p>可以看到，Teacher实现了自己的clone方法，Stu在实现clone方法是对teacher字段进行了clone调用，最终完成了深复制。</p>
<h2 id="Android中原型模式的使用"><a href="#Android中原型模式的使用" class="headerlink" title="Android中原型模式的使用"></a>Android中原型模式的使用</h2><p>Android中原型模式的分析，可以分析一下Android中的集合<code>SparseArray</code>。<br>以上是SparseArray的继承结构，SparseArray实现了Cloneable接口，对SparseArray的复制就是对SparseArray内部数组mKeys和mValues的的复制。</p>
<pre><code>public SparseArray&lt;E&gt; clone() {
    SparseArray&lt;E&gt; clone = null;
    try {
        clone = (SparseArray&lt;E&gt;) super.clone();
        clone.mKeys = mKeys.clone();
        clone.mValues = mValues.clone();
    } catch (CloneNotSupportedException cnse) {
        /* ignore */
    }
    return clone;
}</code></pre><p>前面说过，clone接口进行的是浅复制，mKeys为int类型的数组，mValues为Object类型的数组，既然是浅复制，通过clone方法返回对象的修改应该会影响原对象，接下来验证一下：</p>
<pre><code>SparseArray&lt;Stu&gt; originSparseArray = new SparseArray&lt;&gt;();
originSparseArray.put(1, new Stu(&quot;test1&quot;, 1));
originSparseArray.put(2, new Stu(&quot;test2&quot;, 2));
originSparseArray.put(3, new Stu(&quot;test3&quot;, 3));
SparseArray&lt;Stu&gt; cloneSparseArray = originSparseArray.clone();
Stu stu = cloneSparseArray.get(1);
stu.name = &quot;test4&quot;;
    Log.d(&quot;sparse_clone&quot;, &quot;origin:&quot; + originSparseArray.get(1).name + &quot;-clone:&quot; + cloneSparseArray.get(1).name);</code></pre><p>程序运行结果如下：</p>
<pre><code>sparse_clone: origin:test4-clone:test4</code></pre><p>可以发现，对cloneSparseArray的修改影响了originSparseArray。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>原型模式是对已有对象实例的复用</li>
<li>如果使用new创建新的实例需要消耗过多的资源或者步骤比较复杂，建议采用原型模式</li>
<li>clone方法在进行对象复制时不会调用构造方法</li>
<li>在使用原型模式时，特别需要注意浅复制与深复制的问题，如果使用浅复制，需要确保复制后对象对原对象的影响不会导致出现异常</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/04/design-pattern-builder/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/04/design-pattern-builder/" itemprop="url">建造者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T23:49:11+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发中，经常用到builder设计模式，但感觉最常见的应用场景就是构造对象参数较多的时候，本文将builder模式梳理总结一下。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>非要给builder模式一个定义，我就查看了《Android源码设计模式解析与实战》，以下是其给出的定义:</p>
<blockquote>
<p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>这样的总结比较经典，但是感觉离彻底明白其中的含义还差点距离。前半句可以理解为将一个对象的创建过程分多步，后半句可以这样理解，使用同样的构建过程，传递不同的参数会产生不同的结果。</p>
<h2 id="经典写法"><a href="#经典写法" class="headerlink" title="经典写法"></a>经典写法</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/builder.png" alt=""><br>上图为builder经典写法的uml，其实在实际开发过程中，Director部分经常就被去掉了。<br>如下所示，定义了AbstractBuilder:</p>
<pre><code>public abstract class AbstractBuilder {
    public abstract void buildPart1(int numOfWheel);
    public abstract void buildPart2(int numOfSeat);
    public abstract void buildPart3(int capacity);
    public abstract Vehicle build();
}</code></pre><p>demo的目标是将车辆Vehicle的构建分离，demo中的Product为Vehicle类型，可以看下Vehicle的定义：</p>
<pre><code>public abstract class Vehicle {
    // 车轮的数量
    protected int numOfWheel;
    // 座椅的数量
    protected int numOfSeat;
    // 载重，car按照人数，truck按照吨数
    protected int capacity;

    public void setNumOfWheel(int numOfWheel) {
        this.numOfWheel = numOfWheel;
    }
    public void setNumOfSeat(int numOfSeat) {
        this.numOfSeat = numOfSeat;
    }
    public abstract void setCapacity(int capacity);
}</code></pre><p>demo中Vehicle的子类有Car(小轿车)和Truck(卡车)，Car类的定义如下：</p>
<pre><code>public class Car extends Vehicle {

    @Override
    public void setCapacity(int capacity) {
        // TODO Auto-generated method stub
        super.capacity = capacity;
    }

    @Override
    public String toString() {
        // TODO Auto-generated method stub
        return &quot;car parameter:&quot; + numOfWheel + &quot;-&quot; + numOfSeat + &quot;-&quot; + capacity;
    }
}</code></pre><p>Truck的定义如下：</p>
<pre><code>public class Truck extends Vehicle {

    @Override
    public void setCapacity(int capacity) {
        // TODO Auto-generated method stub
        super.capacity = capacity;
    }

    @Override
    public String toString() {
        // TODO Auto-generated method stub
        return &quot;car parameter:&quot; + numOfWheel + &quot;-&quot; + numOfSeat + &quot;-&quot; + capacity + &quot; ton&quot;;
    }
}</code></pre><p>接下来就看下Car的builder CarBuilder:</p>
<pre><code>public class CarBuilder extends AbstractBuilder {
    private Car car = new Car();

    @Override
    public void buildPart1(int numOfWheel) {
        // TODO Auto-generated method stub
        car.setNumOfWheel(numOfWheel);
    }

    @Override
    public void buildPart2(int numOfSeat) {
        // TODO Auto-generated method stub
        car.setNumOfSeat(numOfSeat);
    }

    public void buildPart3(int capacity) {
        // TODO Auto-generated method stub
        car.setCapacity(capacity);
    }

    public Vehicle build() {
        return car;
    }
}</code></pre><p>TruckBuilder定义如下：</p>
<pre><code>public class TruckBuilder extends AbstractBuilder {
    private Truck truck = new Truck();
    @Override
    public void buildPart1(int numOfWheel) {
        // TODO Auto-generated method stub
        truck.setNumOfWheel(numOfWheel);
    }

    @Override
    public void buildPart2(int numOfSeat) {
        // TODO Auto-generated method stub
        truck.setNumOfSeat(numOfSeat);
    }

    @Override
    public void buildPart3(int capacity) {
        // TODO Auto-generated method stub
        truck.setCapacity(capacity);
    }

    @Override
    public Vehicle build() {
        // TODO Auto-generated method stub
        return truck;
    }
}</code></pre><p>以上定义了CarBuiler， TruckBuiler。虽然在实际开发中经常会省略掉Director部分，为了演示，demo也定义了Director</p>
<pre><code>public class Director {
    private AbstractBuilder builder;
    public Director(AbstractBuilder builder) {
        this.builder = builder;
    }
    public void construct(int numOfWheel, int numOfSeat, int capacity) {
        if (builder != null) {
            builder.buildPart1(numOfWheel);
            builder.buildPart2(numOfSeat);
            builder.buildPart3(capacity);
        }
    }
}</code></pre><p>OK，所有需要定义的部分已经完成，接下来就去调用一下：</p>
<pre><code>public class Client {
    public static void main(String [] args) {
        AbstractBuilder builder = new CarBuilder();
        Director director = new Director(builder);
        director.construct(4, 5, 5);
        Car car = (Car) builder.build();
        System.out.println(car);

        AbstractBuilder builder2 = new TruckBuilder();
        Director director2 = new Director(builder2);
        director2.construct(8, 2, 5);
        Truck truck = (Truck) builder2.build();
        System.out.println(truck);
    }
}</code></pre><p>程序输入如下：<br>car parameter:4-5-5<br>truck parameter:8-2-5 ton</p>
<p>demo演示部分将Vehicle的构造过程分3步，执行完3步构建后返回实例对象。</p>
<h2 id="日常写法"><a href="#日常写法" class="headerlink" title="日常写法"></a>日常写法</h2><p>上面的demo是经典的写法，但在实际开发中，很少写的那么标准或者那么复杂，大多数情况下builder模式主要是为了防止在构建对象时传递太多的参数。查看下以下demo:</p>
<pre><code>public class Student {
    private String name;
    private String nickName;
    private String sex;
    private int age;
    private int weight;
    private int height;

    public Student(String name, String nickName, String sex, int age, int weight, int height) {
        // TODO Auto-generated constructor stub
        this.name = name;
        this.nickName = nickName;
        this.sex = sex;
        this.age = age;
        this.weight = weight;
        this.height = height;
    }

    @Override
    public String toString() {
        // TODO Auto-generated method stub
        return &quot;student info:name=&quot; + name + &quot;\n&quot; +
                            &quot;nickname=&quot; + nickName + &quot;\n&quot; +
                            &quot;sex=&quot; + sex + &quot;\n&quot; + 
                            &quot;age=&quot; + age + &quot;\n&quot; + 
                            &quot;weight=&quot; + weight + &quot;\n&quot; +
                            &quot;height=&quot; + height;
    }

    public static class Builder {
        private String name;
        private String nickName;
        private String sex;
        private int age;
        private int weight;
        private int height;

        public Builder name(String name) {
            this.name = name;
            return this;
        }
        public Builder nickName(String nickName) {
            this.nickName = nickName;
            return this;
        }
        public Builder sex(String sex) {
            this.sex = sex;
            return this;
        }
        public Builder age(int age) {
            this.age = age;
            return this;
        }
        public Builder weight(int weight) {
            this.weight = weight;
            return this;
        }
        public Builder height(int height) {
            this.height = height;
            return this;
        }
        public Student build() {
            return new Student(name, nickName, sex, age, weight, height);
        }
    } 
}</code></pre><p>以下是测试程序：</p>
<pre><code>public class Client {
    public static void main(String [] args) {
        Student student = new Student.Builder().name(&quot;rock&quot;)
                                               .nickName(&quot;store&quot;)
                                               .sex(&quot;boy&quot;)
                                               .age(12)
                                               .weight(60)
                                                .height(176).build();
        System.out.println(student);
    }
}</code></pre><p>程序运行结果如下：</p>
<pre><code>student info:name=rock
nickname=store
sex=boy
age=12
weight=60
height=176</code></pre><h2 id="Android中Builder使用场景"><a href="#Android中Builder使用场景" class="headerlink" title="Android中Builder使用场景"></a>Android中Builder使用场景</h2><p>在开发过程中，经常使用的builder模式其实就是上文所说的日常写法，Android中最常见的builder模式就是AlertDialog的创建过程了，以下是AlertDialog创建过程的常见写法。</p>
<pre><code>AlertDialog.Builder builder = new AlertDialog.Builder(context)
                                             .setTitle(title)
                                             .setView(view)
                                             .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
                                                @Override
                                                public void onClick(DialogInterface dialog, int which) {

                                                }
                                            })
                                            .setNegativeButton(android.R.string.cancel, null);
builder.create().show();</code></pre><p>感觉很熟悉，这就是我们最常用的AlertDialog的构建过程。扒一扒源码，由于AlertDialog.Builder的源码较多，就不全部贴出来，感兴趣的同学可以自行看一下。</p>
<pre><code>public static class Builder {
    private final AlertController.AlertParams P;</code></pre><p>​<br>        public Builder(Context context) {<br>            this(context, resolveDialogTheme(context, ResourceId.ID_NULL));<br>        }</p>
<p>​<br>       ……</p>
<pre><code>public Builder setTitle(@StringRes int titleId) {
    P.mTitle = P.mContext.getText(titleId);
    return this;
}</code></pre><p>​<br>        public Builder setTitle(CharSequence title) {<br>            P.mTitle = title;<br>            return this;<br>        }</p>
<p>​<br>        public Builder setCustomTitle(View customTitleView) {<br>            P.mCustomTitleView = customTitleView;<br>            return this;<br>        }</p>
<pre><code>......</code></pre><p>​<br>        public Builder setMessage(CharSequence message) {<br>            P.mMessage = message;<br>            return this;<br>        }</p>
<pre><code>   public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) {
        P.mPositiveButtonText = P.mContext.getText(textId);
        P.mPositiveButtonListener = listener;
        return this;
    }
    ......

    public AlertDialog create() {
        // Context has already been wrapped with the appropriate theme.
        final AlertDialog dialog = new AlertDialog(P.mContext, 0, false);
        P.apply(dialog.mAlert);
        dialog.setCancelable(P.mCancelable);
        if (P.mCancelable) {
            dialog.setCanceledOnTouchOutside(true);
        }
        dialog.setOnCancelListener(P.mOnCancelListener);
        dialog.setOnDismissListener(P.mOnDismissListener);
        if (P.mOnKeyListener != null) {
            dialog.setOnKeyListener(P.mOnKeyListener);
        }
        return dialog;
    }

}</code></pre><p>AlertDialog.Buidler类中定义各种set方法，执行完set方法之后再执行create方法便创建了一个AlertDialog。这应该是一个标准的builder模式了。可以发现AlertDialog.Builder执行set方法，其实就是将set参数复制给了对象P。对象P是什么结构呢？</p>
<pre><code>public static class AlertParams {
    public final Context mContext;
    public final LayoutInflater mInflater;

    public int mIconId = 0;
    public Drawable mIcon;
    public int mIconAttrId = 0;
    public CharSequence mTitle;
    public View mCustomTitleView;
    public CharSequence mMessage;
    public CharSequence mPositiveButtonText;
    public DialogInterface.OnClickListener mPositiveButtonListener;
    public CharSequence mNegativeButtonText;
    public DialogInterface.OnClickListener mNegativeButtonListener;
    public CharSequence mNeutralButtonText;
    public DialogInterface.OnClickListener mNeutralButtonListener;
    public boolean mCancelable;
    public DialogInterface.OnCancelListener mOnCancelListener;
    public DialogInterface.OnDismissListener mOnDismissListener;
    public DialogInterface.OnKeyListener mOnKeyListener;
    public CharSequence[] mItems;
    public ListAdapter mAdapter;
    public DialogInterface.OnClickListener mOnClickListener;
    public int mViewLayoutResId;
    public View mView;
    public int mViewSpacingLeft;
    public int mViewSpacingTop;
    public int mViewSpacingRight;
    public int mViewSpacingBottom;
    public boolean mViewSpacingSpecified = false;
    public boolean[] mCheckedItems;
    public boolean mIsMultiChoice;
    public boolean mIsSingleChoice;
    public int mCheckedItem = -1;
    public DialogInterface.OnMultiChoiceClickListener mOnCheckboxClickListener;
    public Cursor mCursor;
    public String mLabelColumn;
    public String mIsCheckedColumn;
    public boolean mForceInverseBackground;
    public AdapterView.OnItemSelectedListener mOnItemSelectedListener;
    public OnPrepareListViewListener mOnPrepareListViewListener;
    public boolean mRecycleOnMeasure = true;

    ......
}</code></pre><p>可以发现，AlertController.AlertParams类型的对象P其实就是存放了构建AlertDialog需要的各种参数。对象P中海油其他函数操作，感兴趣的同学可以去看一下。</p>
<p>将参数保存到P对象，然后执行create函数，创建新的AlertDialog对象，然后P中存放的属性设置给新建的AlertDilaog对象，这样，就完成了AlertDialog的构建。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Builder模式的目标是将复杂对象的创建过程进行分解，使对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。在实际开发过程中，通常是在复杂对象内部申明静态内部类Builder，在Builder中保存复杂对象的属性，然后使用create或者build函数将保存的属性设置给对象。</p>
<p>其实日常开发过程中使用builder模式还没有让我们领略到builer模式的强大，建议参考下这篇文章体会一下：<a href="https://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyhippy/archive/2010/09/01/1814287.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/04/design-pattern-abstract-factory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/04/design-pattern-abstract-factory/" itemprop="url">抽象工厂</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T23:46:29+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>简单工厂根据对象类型信息创建对象，但责任太重，不符合单一职责原则；工厂模式引入等级结构，解决了简单工厂责任太重的问题，那抽象工厂的主要作用是什么呢？</p>
<h2 id="产品等级结构和产品簇"><a href="#产品等级结构和产品簇" class="headerlink" title="产品等级结构和产品簇"></a>产品等级结构和产品簇</h2><p>如果要区分工厂和抽象工厂，理解产品等级结构和产品簇是必要条件。<br><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/abstract_factory_product.jpg" alt=""></p>
<p>图片引自：<a href="https://www.cnblogs.com/lfxiao/p/6811820.html" target="_blank" rel="noopener">https://www.cnblogs.com/lfxiao/p/6811820.html</a></p>
<p>上图展示了产品等级和产品簇之间的区别。在横坐标方向，图形分正方形，原型，椭圆；在纵坐标方向上，为每种图形的不同颜色。产品等级结构是相同产品的不同表现形式，比如车-&gt;黑色的车-&gt;白色的车，在产品等级结构中，所有的产品都有共同的基类；产品族是具有某种相同属性的不同产品，比如黑色的宝马车-&gt;黑色的自行车-&gt;黑色的手扶拖拉机，在产品族中，所有的产品拥有相同的约束–黑色的车。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>为创建一组或具有相同约束的对象提供一个接口</p>
<h2 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h2><p>一个产品族由相同的约束。比如都是黑色的交通工具，都是黑色的图形……</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>在介绍工厂模式时，使用的示例如下：<br><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/factory.png" alt=""><br>工厂的基类<code>Factory</code>定义了<code>createAnimal</code>方法，具体的工厂根据待生产的产品的不同分<code>CatFactory</code>和<code>DogFactory</code>，这两个<code>Factory</code>的子类分别用于新建<code>Cat</code>对象和<code>Dog</code>对象。</p>
<p>假设现在对猫<code>Animal</code>进行具体化，分为黑颜色的猫<code>BlackCat</code>，白颜色的猫<code>WhiteCat</code>，黑颜色的狗<code>BlackDog</code>，白颜色的狗<code>WhiteDog</code>，如果使用工厂模式，结构图如下：<br><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/factory_update.png" alt=""></p>
<p>可以发现系统中的类会成对增加，造成这种情况的原因在于每个工厂只能生产一种具体的产品，每增加一个产品均需要新建一个工厂，那有没有什么方法能够避免这种情况的出现呢？</p>
<p>在以上的示例中，白色的狗<code>WhiteDog</code>和白色的猫<code>WhiteCat</code>都是相同颜色的动物，相同颜色的狗和猫是相同颜色的小动物，将他们放在同一个产品簇中，修改后的结构如下：<br><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/abstract_factory.png" alt=""> </p>
<p>如果继续添加黑色的猪<code>BlackPig</code>，白色的猪<code>WhitePig</code>，则只需要增加新的Animal类型，在Factory中添加对应的create方法即可，不会出现类急剧增多的情况。</p>
<p>具体实现如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Animal &#123;</span><br><span class="line">	void eat();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Cat implements Animal &#123;</span><br><span class="line">	</span><br><span class="line">	private String color;</span><br><span class="line">	</span><br><span class="line">	public Cat(String color) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">		this.color &#x3D; color;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		System.out.println(color + &quot; cat eats&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class Dog implements Animal &#123;</span><br><span class="line">	</span><br><span class="line">	private String color;</span><br><span class="line">	</span><br><span class="line">	public Dog(String color) &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated constructor stub</span><br><span class="line">		this.color &#x3D; color;</span><br><span class="line">	&#125;</span><br><span class="line">	@Override</span><br><span class="line">	public void eat() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		System.out.println(color + &quot; dog eats&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractAnimalFactory &#123;</span><br><span class="line">	abstract Animal makeCat();</span><br><span class="line">	abstract Animal makeDog();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class BlackAnimalFactory extends AbstractAnimalFactory &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	Animal makeCat() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		return new Cat(&quot;black&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	Animal makeDog() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		return new Dog(&quot;black&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public class WhiteAnimalFactory extends AbstractAnimalFactory &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	Animal makeCat() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		return new Cat(&quot;white&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	Animal makeDog() &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		return new Dog(&quot;white&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String [] args) &#123;</span><br><span class="line">		</span><br><span class="line">		AbstractAnimalFactory whiteAnimalFactory &#x3D; new WhiteAnimalFactory();</span><br><span class="line">		Cat whiteCat &#x3D; (Cat) whiteAnimalFactory.makeCat();</span><br><span class="line">		Dog whiteDog &#x3D; (Dog) whiteAnimalFactory.makeDog();</span><br><span class="line">		whiteCat.eat();</span><br><span class="line">		whiteDog.eat();</span><br><span class="line">		</span><br><span class="line">		AbstractAnimalFactory blackAnimalFactory &#x3D; new BlackAnimalFactory();</span><br><span class="line">		Cat blackCat &#x3D; (Cat) blackAnimalFactory.makeCat();</span><br><span class="line">		Dog blackDog &#x3D; (Dog) blackAnimalFactory.makeDog();</span><br><span class="line">		blackCat.eat();</span><br><span class="line">		blackDog.eat();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<pre><code>white cat eats
white dog eats
black cat eats
black dog eats</code></pre><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>似乎抽象工厂很完美，现在有一个新的需求过来了，需要在系统中添加白色的猪<code>WhitePig</code>和黑色的猪<code>BlackPig</code>。突然发现在原有的抽象工厂结构中，如果需要添加这两种Animal，需要对<code>Factory</code>进行修改，添加<code>makePig</code>方法，同时<code>WhiteAnimalFactory</code>和<code>BlackAnimalFactory</code>都需要实现<code>makePig</code>方法。</p>
<p>这样的设计违反了开闭原则(一个软件实体应当对扩展开放，对修改关闭)，有没有什么办法解决这个问题呢？抽象工厂无法解决这样的问题。可以发现，使用抽象工厂时，增加产品族（在本文中可以理解为为现有动物添加新的颜色分类）可以满足开闭原则，但是增加产品等级结构（在本文中可以理解为增加新的动物），就需要对原结构进行大量的修改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>简单工厂侧重根据类型信息创建对象，但是不符合单一职责原则；工厂模式中每个工厂只生产一种具体的产品，如果产品过多，可能会导致系统中存在大量的工厂类；抽象工厂将工厂模式中相关的产品组成产品族，由一个工厂生产，减少了系统中类的数量</li>
<li>使用抽象工厂增加产品族符合开闭原则，但增加产品等级结构不满足开闭原则</li>
<li>在使用抽象工厂模式之前，需要设计好产品族和产品等级结构，防止由于增加产品等级结构而造成系统大幅度的改动</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/04/design-pattern-factory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/04/design-pattern-factory/" itemprop="url">工厂模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T23:41:56+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相对于其他设计模式，工厂模式从概念上很好理解，就是将对象创建工作交给一个工厂，工厂根据需求返回我们需要的对象。但在Android开发过程中，感觉涉及到的工厂模式并不多，本文将从<code>Activity</code>实例创建入手，分析工厂模式在Android中的应用。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>定义对象创建的接口，根据需求返回对象实例。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/simple_factory.png" alt=""><br>其实使用工厂模式时，简单工厂常常会被我们忽略，以上为简单工厂的UML类图，我们首先看下简单工厂。</p>
<pre><code>interface Animal {
    abstract void eat();
}

class Dog implements Animal {

    @Override
    public void eat() {
        // TODO Auto-generated method stub
        System.out.println(&quot;dog eats&quot;);
    }

}

class Cat implements Animal {
    @Override
    public void eat() {
        // TODO Auto-generated method stub
        System.out.println(&quot;cat eats&quot;);
    }
}

class SimpleFactory {
    public static Animal makeAnimal(int type) {
        switch (type) {
        case 1:
            return new Dog();
        case 2:
            return new Cat();
        default:
                return null;
        }
    }
}</code></pre><p>测试代码：</p>
<pre><code>public static void main(String [] args) {
    Animal animal1 = SimpleFactory.makeAnimal(1);
    Animal animal2 = SimpleFactory.makeAnimal(2);
    animal1.eat();
    animal2.eat();
}</code></pre><p>程序运行结果：</p>
<pre><code>dog eats
cat eats</code></pre><p>简单工厂模式将所有类型对象的创建工作放在一个方法中，根据条件语句判断创建对象。</p>
<h3 id="工厂"><a href="#工厂" class="headerlink" title="工厂"></a>工厂</h3><p>简单工厂将所有类型对象的创建工作放在一个方法中，这种设计简化了对象的创建；抽象工厂的缺点也是显而易见的，这样的设计违反了高内聚单一职责原则，简单工厂负责所有对象的创建，如果需要添加新的类型，则需要修改简单工厂。接下来就分析下工厂的实现。</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/factory.png" alt=""></p>
<pre><code>interface Animal {
    void eat();
}

class Dog implements Animal {

    @Override
    public void eat() {
        // TODO Auto-generated method stub
        System.out.println(&quot;dog eats&quot;);
    }

}

class Cat implements Animal {
    @Override
    public void eat() {
        // TODO Auto-generated method stub
        System.out.println(&quot;cat eats&quot;);
    }
}

abstract class Factory {
    abstract Animal createAnimal();
}

class DogFactory extends Factory {

    @Override
    Animal createAnimal() {
        // TODO Auto-generated method stub
        return new Dog();
    }
}

class CatFactory extends Factory {
    @Override
    Animal createAnimal() {
        // TODO Auto-generated method stub
        return new Cat();
    }
}</code></pre><p>测试代码：</p>
<pre><code>public static void main(String [] args) {
    DogFactory dogFactory = new DogFactory();
    CatFactory catFactory = new CatFactory();
    Animal dog = dogFactory.createAnimal();
    Animal cat = catFactory.createAnimal();
    dog.eat();
    cat.eat();
}</code></pre><p>程序运行结果：</p>
<pre><code>dog eats
cat eats</code></pre><p>相对于简单工厂，工厂将对象的创建做了抽象，不同对象使用不同的工厂进行创建，这样的设计符合高内聚职责单一的原则，让子类可以创建自己的工厂，降低了工厂和具体对象之间的耦合。</p>
<h2 id="Android中工厂模式的使用"><a href="#Android中工厂模式的使用" class="headerlink" title="Android中工厂模式的使用"></a>Android中工厂模式的使用</h2><p>Android中Activity实例的创建是容易被我们忽略的工厂模式的使用。Activity实例的新建实在<code>ActivityThread</code>的<code>performLaunchActivity</code>方法中完成的。</p>
<pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ......
    Activity activity = null;
    try {
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        ......
    } catch (Exception e) {
        ......
    }

    try {
        ......
            if (r.isPersistable()) {
                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
            } else {
                mInstrumentation.callActivityOnCreate(activity, r.state);
            }
            ......
        }
        r.setState(ON_CREATE);

        mActivities.put(r.token, r);

    } catch (SuperNotCalledException e) {
        throw e;

    } catch (Exception e) {
        ......
    }

    return activity;
}</code></pre><p>略去了和<code>Activity</code>实例创建无关的代码。可以看到<code>Activity</code>实例创建完成后，接下来会执行<code>mInstrumentation.callActivityOnCreate</code>方法，也就是会执行<code>Activity</code>的<code>onCreate</code>方法。我们关注的是<code>Activity</code>实例的创建，需要深入<code>mInstrumentation.newActivity(cl, component.getClassName(), r.intent)</code>方法看下：</p>
<pre><code>public Activity newActivity(ClassLoader cl, String className,
        Intent intent)
        throws InstantiationException, IllegalAccessException,
        ClassNotFoundException {
    String pkg = intent != null &amp;&amp; intent.getComponent() != null
            ? intent.getComponent().getPackageName() : null;
    return getFactory(pkg).instantiateActivity(cl, className, intent);
}</code></pre><p>是不是看到<code>getFactory</code>方法了，隐隐约约嗅到了工厂，哈哈。</p>
<pre><code>private AppComponentFactory getFactory(String pkg) {
    if (pkg == null) {
        Log.e(TAG, &quot;No pkg specified, disabling AppComponentFactory&quot;);
        return AppComponentFactory.DEFAULT;
    }
    if (mThread == null) {
        Log.e(TAG, &quot;Uninitialized ActivityThread, likely app-created Instrumentation,&quot;
                + &quot; disabling AppComponentFactory&quot;, new Throwable());
        return AppComponentFactory.DEFAULT;
    }
    LoadedApk apk = mThread.peekPackageInfo(pkg, true);
    // This is in the case of starting up &quot;android&quot;.
    if (apk == null) apk = mThread.getSystemContext().mPackageInfo;
    return apk.getAppFactory();
}</code></pre><p>再深入看下<code>getAppFactory</code>方法返回的是什么：</p>
<pre><code>public AppComponentFactory getAppFactory() {
    return mAppComponentFactory;
}</code></pre><p>ok，继续，到<code>AppComponentFactory</code>中找下<code>instantiateActivity</code>这个方法：</p>
<pre><code>public @NonNull Activity instantiateActivity(@NonNull ClassLoader cl, @NonNull String className,
        @Nullable Intent intent)
        throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    return (Activity) cl.loadClass(className).newInstance();
}</code></pre><p>可以看到，系统将对<code>Activity</code>实例的创建封装为<code>instantiateActivity</code>，方法，只需要传入<code>classloader</code>以及<code>className</code>即可创建实例了。创建<code>Activity</code>实例的过程也告诉我们，<code>Activity</code>的创建使用的是默认无参构造函数。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>简单工厂封装了对象的创建过程，但是在实现时工厂和对象高度耦合，违背了高内聚单一职责</li>
<li>工厂模式在简单工厂的基础上将工厂抽象，不同的工厂可以创建不同的实例，工厂和对象解耦，实现了高内聚单一职责。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/04/design-pattern-singleton/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/04/design-pattern-singleton/" itemprop="url">单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-04T22:07:27+08:00">
                2020-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在开发过程中也经常涉及到设计模式，对设计模式的总结也仅仅是遇到了梳理一下，没有系统总结过，从这篇文章开始就总结一下java中的设计模式，并结合android做一下分析。</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/Desigin-Pattern.png" alt=""></p>
<p>以上为前辈大佬总结的java设计模式，分三大类：创建型模式，结构型模式以及行为型模式，后面也会按照以上顺序进行分析。本文先分析开发中经常使用的单例模式。</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/singleton.png" alt=""></p>
<p>以上为单例模式的UML，总结一下，实现单例模式需要有如下关键点：</p>
<blockquote>
<p>(1) 构造函数为是私有，不对外公开<br>(2) 通过一个静态方法或者枚举返回单例对象<br>(3) 确保单例对象只有一个，尤其是在多线程环境中<br>(4) 确保在反序列化的过程不会新建单例对象</p>
</blockquote>
<p>在开发过程中，通常会关注前3点，第四点常常会被忽略，后面的分析中会对第4点进行分析。</p>
<p>提起单例模式，最熟悉的就是饿汉和懒汉这两个概念了，虽然很熟悉，还是要梳理一下。</p>
<h2 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h2><p>懒汉模式实在需要单例对象的时候再创建单例对象的一种模式，有lazy loading的效果，在一定层度上提高了内存的使用效率。</p>
<pre><code>public class Singleton {
    private static Singleton sInstance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        if (sInstance == null) {
            sInstance = new Singleton();
        }
        return sInstance;
    }
}</code></pre><p>这种懒汉模式在单线程环境下没有问题，但是在多线程环境中<code>getInstance</code>可能会返回多个实例，于是就有了以下改进</p>
<pre><code>public class Singleton {

    private static Singleton sInstance = null;

    private Singleton() {}

    public static synchronized Singleton getInstance() {
        if (sInstance == null) {
            sInstance = new Singleton();
        }
        return sInstance;
    }
}</code></pre><p>通过对<code>getInstance</code>方法加锁，保证了在多线程环境中仅返回同一个实例。但是这样的做法缺点也十分明显，即使<code>sInstance</code>对象已经被新建，每次调用<code>getInstance</code>时都存在加锁与释放锁的操作，这样会消耗不必要的资源。经过改进，就有了以下实现：</p>
<pre><code>public class Singleton {

    private static Singleton sInstance = null;

    private Singleton() {}

    public static Singleton getInstance() {
        if (sInstance == null) {
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }
}</code></pre><p>经过改进后，调用<code>getInstance</code>不会进行加锁操作，而是会先判断单例对象是否为空，如果为空，则同步去新建单例对象，并在同步新建对象之前再次判断单例对象是否为空，这种方式被称为双重检查锁(DCL),这种方式看似不会出现什么问题了，但分析之后发现还是可能有问题。</p>
<pre><code>sInstance = new Singleton();</code></pre><p>以上语句实际上经过了以下3个步骤：<br>(1)为Singleton单例对象分配内存空间<br>(2)调用Singleton构造函数，初始化Singleton单例对象<br>(3)将sInstance引用指向已经分配的内存空间</p>
<p>以上3个步骤中，步骤(2)和步骤(3)可能被重新排序，最终导致执行的顺序可能是(1)(3)(2)，假设在多线程环境中多个线程尝试调用<code>getInstance</code>函数获取Singleton单例，线程1调用<code>getInstance</code>时，<code>sInstance</code>的对象为空，调用<code>sInstance = new Singleton()</code>的执行顺序是(1)(3)(2)，线程1执行到步骤(3)时，线程2也去调用<code>getInstance</code>，此时sIntance对象不为空，但是<code>sInstance</code>指向的对象却是没有被初始化的对象。在jdk1.5之前会存在以上问题，但是在jdk1.5后，<code>volatile</code>的语义得到增强，只需要使用<code>private static volatile Singleton sInstance = null</code>便可以消除指令重排。</p>
<h2 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h2><p>饿汉模式，顾名思义，就是无论现在是否需要单例对象，都要初始化单例对象。</p>
<pre><code>public class Singleton {

    private static Singleton sInstance = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return sInstance;
    }
}</code></pre><p>以上为经典十分常见的饿汉单例模式，这种创建方式会在类加载的时候就创建实例，没有lazy loading的效果，如果Singleton实例需要占用很大的内存空间，会导致内存的利用率较低。基于以上原因，优化后的代码如下：</p>
<pre><code>public class Singleton {
    private Singleton(){

    }
    private static class SingletonHolder{
        private final static Singleton instance=new Singleton();
    }
    public static Singleton getInstance(){
        return SingletonHolder.instance;
    }
}</code></pre><p>当第一次加载<code>Singleton</code>类时，并不会新建单例对象，当调用<code>getInstance</code>方法时，会加载<code>SingletonHolder</code>类，这种方法不仅能够确保线程安全，也能保证对象的唯一性，同时也有lazy loading的效果。</p>
<h2 id="对象创建的方式"><a href="#对象创建的方式" class="headerlink" title="对象创建的方式"></a>对象创建的方式</h2><p>前面说过，实现单例需要确保在反序列化的过程不会新建单例对象，说到序列化，先岔开一下，回忆下java对象的创建方式：</p>
<p>(1) new<br>(2) Class.newInstance<br>(3) Constructor.newInstance<br>(4) clone<br>(5) 反序列化</p>
<p>其中使用(1)(2)(3)会调用构造函数，(4)(5)不会调用类的构造函数。</p>
<p>为了验证在clone和反序列化过程中不会调用构造函数，可以使用简单的demo演示：</p>
<pre><code>public class Singleton implements Cloneable, Serializable {

    private static final long serialVersionUID = 1L;

    private static Singleton sInstance = null;

    private Singleton() {
        System.out.println(&quot;create a singleton&quot;);
    }

    public static Singleton getInstance() {
        if (sInstance == null) {
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }

    public static void main(String [] args) {
        try {
            Singleton singleton = Singleton.getInstance();

            // test clone
            Singleton singleton3 = (Singleton) singleton.clone();
            System.out.println(singleton == singleton3);</code></pre><p>​<br>                // write single to file<br>                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(“test.dat”)));<br>                oos.writeObject(singleton);<br>                oos.flush();<br>                oos.close();</p>
<pre><code>            // read single from file
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;test.dat&quot;)));
            Singleton singleton2 = (Singleton) ois.readObject();
            ois.close();
            if (singleton2 == null) {
                System.err.println(&quot;can not read singleton from file&quot;);
            } else {
                System.out.println(singleton == singleton2);
            }

        } catch (Exception e) {
            // TODO: handle exception
        }

    }
}</code></pre><p>为了演示，Singleton类实现了Cloneable和Serializable接口，运行程序结果如下：<br>create a singleton<br>false<br>false</p>
<p>从结果中可以看出，使用clone和反序列化构建的对象不会执行构造函数，且通过clone和反序列化得到的对象并不是调用<code>getInstance</code>返回的单例对象。</p>
<p>好在反序列化提供了一个很特别的钩子函数<code>readResolve</code>，让开发人员可以去控制反序列化的过程，经过修改后的代码如下：</p>
<pre><code>public class Singleton implements Serializable {

    private static final long serialVersionUID = 1L;

    private static Singleton sInstance = null;

    private Singleton() {
        System.out.println(&quot;create a singleton&quot;);
    }

    public static Singleton getInstance() {
        if (sInstance == null) {
            synchronized (Singleton.class) {
                if (sInstance == null) {
                    sInstance = new Singleton();
                }
            }
        }
        return sInstance;
    }

    private Object readResolve() throws ObjectStreamException {
        return getInstance();
    }

    public static void main(String [] args) {
        try {

            Singleton singleton = Singleton.getInstance();

            // write single to file
            ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(new File(&quot;test.dat&quot;)));
            oos.writeObject(singleton);
            oos.flush();
            oos.close();

            // read single from file
            ObjectInputStream ois = new ObjectInputStream(new FileInputStream(new File(&quot;test.dat&quot;)));
            Singleton singleton2 = (Singleton) ois.readObject();
            ois.close();
            if (singleton2 == null) {
                System.err.println(&quot;can not read singleton from file&quot;);
            } else {
                System.out.println(singleton == singleton2);
            }

        } catch (Exception e) {
            // TODO: handle exception
        }

    }

}</code></pre><p>程序运行结果如下：</p>
<p>create a singleton<br>true</p>
<p>通过运行结果可以看到，经过反序列化操作返回的对象和<code>getInstance</code>返回的对象是同一个。</p>
<h2 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h2><pre><code>public enum EnumSingleton {
    INSTANCE;

    public void enumDo() {
        System.out.println(&quot;EnumSingleton want to do something&quot;);
    }
}</code></pre><p>使用枚举实现单例，既保证了线程安全，同时也可以防止在反序列化过程中新建单例对象。虽然Effective Java中推荐使用这种方式，但在Android平台上，这种方式会对内存造成严重的浪费，可参考<a href="https://blog.csdn.net/xiao_nian/article/details/80002101，谷歌官方明确指出" target="_blank" rel="noopener">https://blog.csdn.net/xiao_nian/article/details/80002101，谷歌官方明确指出</a></p>
<blockquote>
<p>Enums ofter require more than twice as much memory as static constants. You should strictly avoid using enums on Android.</p>
</blockquote>
<p>因此，枚举单例在Android平台上就不要使用了。</p>
<h2 id="容器单例"><a href="#容器单例" class="headerlink" title="容器单例"></a>容器单例</h2><p>容器单例，就是将单例对象存放在容器中进行统一管理，这样便于对系统中的单例进行统一管理。</p>
<pre><code>public class SingletonManager {
    private SingletonManager() {}

    private static HashMap&lt;String, Object&gt; sSingletonManager = new HashMap&lt;&gt;();

    public static Object getSingleton(String name) {
        return sSingletonManager.get(name);
    }

    public static void putSingleton(String name, Object singleton) {
        if (!sSingletonManager.containsKey(name)) {
            sSingletonManager.put(name, singleton);
        }
    }
}</code></pre><h2 id="Android中单例使用"><a href="#Android中单例使用" class="headerlink" title="Android中单例使用"></a>Android中单例使用</h2><p>Android中单例的使用，本文主要从LayoutInflater的创建入手。不同的Activity之间使用的LayoutInflater是不同的实例，但是每个Activity内部使用的LayoutInflater确是同一个实例。接下来就从源码角度去分析一下。</p>
<p>构造LayoutInflater通常有两种方式：</p>
<ul>
<li>LayoutInflater inflater = LayoutInflater.from(Activity);</li>
<li>LayoutInflater inflater = (LayoutInflater) Activity.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</li>
</ul>
<p>第一种方式实际上最后也是调用了第二种方式，故后续只分析第二种。直接到Activity中找到<code>getSystemService</code>函数：</p>
<pre><code>@Override
public Object getSystemService(@ServiceName @NonNull String name) {
    ......
    return super.getSystemService(name);
}</code></pre><p>继续跟踪<code>super.getSystemService(name)</code>，由于Activity继承<code>ContextThemeWrapper</code>，执行逻辑如下：</p>
<pre><code>@Override
public Object getSystemService(String name) {
    if (LAYOUT_INFLATER_SERVICE.equals(name)) {
        if (mInflater == null) {
            mInflater = LayoutInflater.from(getBaseContext()).cloneInContext(this);
        }
        return mInflater;
    }
    return getBaseContext().getSystemService(name);
}</code></pre><p>又回到了<code>LayoutInflater.from</code>逻辑，<code>LayoutInflater.from</code>逻辑实际上最后又走到了<code>getSystemService</code>的逻辑。先看下<code>getBaseContext()</code>函数返回了什么东西。<code>getBaseContext</code>是<code>ContextThemeWrapper</code>的父类<code>ContextWrapper</code>中定义的函数，<code>getBaseContext()</code>函数返回了类型为<code>Context</code>的<code>mBase</code>实例，这个<code>mBase</code>是在<code>ContextWrapper</code>的<code>attachBaseContext</code>函数中赋值的，<code>attachBaseContext</code>又是在什么时候调用的呢？</p>
<p><code>attachBaseContext</code>的调用需要追溯到<code>ActivityThread</code>类的<code>performLaunchActivity</code>函数：</p>
<pre><code>private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) {
    ......
    ContextImpl appContext = createBaseContextForActivity(r);
    Activity activity = null;
    try {
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(
                cl, component.getClassName(), r.intent);
        ......
    } catch (Exception e) {
        ......
    }

    try {
        ......
            activity.attach(appContext, this, getInstrumentation(), r.token,
                    r.ident, app, r.intent, r.activityInfo, title, r.parent,
                    r.embeddedID, r.lastNonConfigurationInstances, config,
                    r.referrer, r.voiceInteractor, window, r.configCallback);

        ......
    } catch (SuperNotCalledException e) {
        throw e;

    } catch (Exception e) {
        .....
    }
    return activity;
}</code></pre><p>继续跟踪下<code>activity.attach</code>：</p>
<pre><code>final void attach(Context context, ActivityThread aThread,
        Instrumentation instr, IBinder token, int ident,
        Application application, Intent intent, ActivityInfo info,
        CharSequence title, Activity parent, String id,
        NonConfigurationInstances lastNonConfigurationInstances,
        Configuration config, String referrer, IVoiceInteractor voiceInteractor,
        Window window, ActivityConfigCallback activityConfigCallback) {
    attachBaseContext(context);

    ......
}</code></pre><p>可以发现，<code>mBase</code>就是通过<code>createBaseContextForActivity(r)</code>创建的<code>ContextImpl</code>类型的实例对象（感兴趣的同学可以跟踪下这个函数），由于每个Activity都会执行次函数，故不同的Activity的mBase是不同的<code>ContextImpl</code>类型的实例对象。</p>
<p>解决了<code>getBaseContext()</code>返回值的问题，继续回到<code>LayoutInflater.from(getBaseContext())</code>这个函数，这个函数最终会走到<code>ContextImpl.getSystemService</code>:</p>
<pre><code>@Override
public Object getSystemService(String name) {
    return SystemServiceRegistry.getSystemService(this, name);
}</code></pre><p>代码有点深，别着急，再到<code>SystemServiceRegistry</code>类中看一下。<code>SystemServiceRegistry</code>类中有一个静态块，这个静态块会调用<code>registerService</code>方法去注册服务：</p>
<pre><code>registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,
            new CachedServiceFetcher&lt;LayoutInflater&gt;() {
        @Override
        public LayoutInflater createService(ContextImpl ctx) {
            return new PhoneLayoutInflater(ctx.getOuterContext());
        }});</code></pre><p>到这个位置，好像豁然开朗了。继续跟踪一下<code>SystemServiceRegistry.getSystemService(this, name)</code></p>
<pre><code>public static Object getSystemService(ContextImpl ctx, String name) {
    ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);
    return fetcher != null ? fetcher.getService(ctx) : null;
}</code></pre><p>此处的<code>ctx</code>参数是前面的<code>mBase</code>，<code>name</code>是<code>Context.LAYOUT_INFLATER_SERVICE</code>，由于已经注册了<code>CachedServiceFetcher</code>，直接到<code>CachedServiceFetcher</code>看下<code>getService</code>函数：</p>
<pre><code>static abstract class CachedServiceFetcher&lt;T&gt; implements ServiceFetcher&lt;T&gt; {
    private final int mCacheIndex;

    CachedServiceFetcher() {
        ......
        mCacheIndex = sServiceCacheSize++;
    }

    @Override
    @SuppressWarnings(&quot;unchecked&quot;)
    public final T getService(ContextImpl ctx) {
        // mServiceCache是ContextImpl的变量，用户缓存已经获取过的服务对象
        final Object[] cache = ctx.mServiceCache;
        final int[] gates = ctx.mServiceInitializationStateArray;

        for (;;) {
            boolean doInitialize = false;
            synchronized (cache) {
                // 如果待获取的服务对象已经存在，则直接返回缓存中的对象
                T service = (T) cache[mCacheIndex];
                if (service != null || gates[mCacheIndex] == ContextImpl.STATE_NOT_FOUND) {
                    return service;
                }
                ......
            }

            if (doInitialize) {
                // Only the first thread gets here.

                T service = null;
                @ServiceInitializationState int newState = ContextImpl.STATE_NOT_FOUND;
                try {
                    // 缓存中没有服务对象，则需要执行createService去创建对象
                    service = createService(ctx);
                    newState = ContextImpl.STATE_READY;

                } catch (ServiceNotFoundException e) {
                    onServiceNotFound(e);

                } finally {
                    ......
                }
                return service;
            }
            ......
        }
    }

    public abstract T createService(ContextImpl ctx) throws ServiceNotFoundException;
}</code></pre><p>至此，Android同一个Activity内LayoutInflater为同一个对象的原理从源码角度已经分析完毕。总结一下就是以下流程：<br>Activity ContextImpl缓存中是否存在LayoutInflater对象，如果已经存在，则直接返回缓存的对象，如果没有则新建LayoutInflater对象，同时，通过源码分析，也知道LayoutInflater的最终实现是PhoneLayoutInflater。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>饿汉模式会在类加载时完成单例对象的初始化，虽然确保了线程安全，但是可能会引起内存使用效率降低</li>
<li>懒汉模式会在需要使用单例对象时完成单例对象的初始化，有lazy loading，提高了内存使用率，但是为了保证线程安全，在新建单例对象时添加了锁机制；多线程环境下，锁机制可能会降低程序运行效率，故引入了DCL，由于存在指令重排的可能，故DCL机制可能存在失效的情况，为了防止DCL失效，jdk1.5之后需要volatile对单例对象进行修饰</li>
<li>使用静态内部类的方式实现单例，既有lazy loading的效果，又可以利用类的加载机制保证线程安全</li>
<li>由于反序列化新建对象不需要执行构造函数，单例模式需要防止反序列化时新建单例对象</li>
<li>Activity 对象内部ContextImpl会对LayoutInflater对象进行缓存，如果已经存在，则直接返回缓存对象</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/go/">&lt;</a><a class="page-number" href="/go/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">rockstore</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/go/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">18</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/go/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/go/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rockstore</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/go/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/go/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/go/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/go/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
