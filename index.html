<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/go/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/go/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/go/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/go/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/go/images/favicon-32x32-next.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/go/images/favicon-16x16-next.ico?v=5.1.4">


  <link rel="mask-icon" href="/go/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Rock">
<meta property="og:url" content="https://rockstore.github.io/go/index.html">
<meta property="og:site_name" content="Rock">
<meta property="article:author" content="rockstore">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/go/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rockstore.github.io/go/"/>





  <title>Rock</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/go/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/go/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/go/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/go/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/15/android-framework-componet-jobscheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/15/android-framework-componet-jobscheduler/" itemprop="url">JobService 原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-15T23:36:04+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">系统组件</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/JobService/" itemprop="url" rel="index">
                    <span itemprop="name">JobService</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JobService 在之前做推送的时候遇到过，主要的作用基于给予系统的各种条件执行异步任务，实现保活功能。从本片开始，逐渐分析 JobService 。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>本文就不介绍 JobService 的使用了，因为网上这样的文章还是比较多的，有一点需要注意的是 JobService 组件需要在清单文件中使用以下权限保护 android:permission=”android.permission.BIND_JOB_SERVICE”，否则是不会被系统调用的。</p>
<p>JobService 的源码相当简单，这里我直接把源码贴出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JobService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"JobService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSION_BIND =</span><br><span class="line">            <span class="string">"android.permission.BIND_JOB_SERVICE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JobServiceEngine mEngine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mEngine = <span class="keyword">new</span> JobServiceEngine(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> JobService.<span class="keyword">this</span>.onStartJob(params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> JobService.<span class="keyword">this</span>.onStopJob(params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mEngine.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">jobFinished</span><span class="params">(JobParameters params, <span class="keyword">boolean</span> wantsReschedule)</span> </span>&#123;</span><br><span class="line">        mEngine.jobFinished(params, wantsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，JobService 就是是 Service ，并且提供了 bind 的方法进行绑定，只是添加了一下几个方法。</p>
<ul>
<li><p>jobFinished</p>
<p>应用执行完后主动调用，通知 JobScheduler ，wantsReschedule 表示执行完成后是否还需要系统继续规划执行，如果为 true ，则规划的执行时间受退避规则限制</p>
</li>
<li><p>onStartJob</p>
<p>子类需要实现此方法，以便在服务开始执行时执行自己的业务逻辑。此方法执行在应用的主线程，故需要考虑阻塞的问题；方法的返回值表示方法返回后服务是否还需要继续执行，true 表示需要继续执行，返回 true 后，如果想停止服务，则需要调用 jobFinished 函数或者系统当前的状态已经无法满足最开始设置的服务运行的条件。还有一点需要注意的时，在服务被即将被调用之前，系统将会获取应用的 WakeLock，WakeLock 会一直存在直到调用 jobFinished 或者 onStopJob</p>
</li>
<li><p>onStopJob</p>
<p>子类需要实现此方法，当系统认为当前系统的状态已经不满足服务的运行后，系统会主动调用此方法，调用此方法后，系统持有应用的锁 WakeLock 也会被释放。</p>
</li>
</ul>
<p>介绍完 JobService 的三个方法后，发现 JobService 的原理其实蛮简单，但是回过头再看下，这还有一个类 JobServiceEngine 未分析。JobServiceEngnie 类的实例是在 onBind 中新建的，JobService 的 onStartJob 和 onStopJob 方法也是在 JobServiceEngine 对应的方法中被调用的，onBind 方法最终返回 mEngine.getBinder() ，说明 JobServiceEngnie 的 getBinder 方法返回了 Binder 实例，用于进行进程通信。</p>
<p>这个 Binder 实例会被谁获取呢？当然是被 JobScheduler 获取了，JobScheduler 通过这个 Binder 实例进行跨进程通信，首先调用 JobServiceEngine 的 onStartJob 或者 onStopJob 方法，JobServiceEngine 会相应调用 JobService 的 onStartJob 和 onStopJob 方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文比较简单，梳理了 JobService 的结构，并大致了解了 JobService 中 onStartJob 和 onStopJob 方法的调用链，下篇文章将会详细分析 JobService onStartJob 和 onStopJob 方法被调用的整个 过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/15/android-framework-server-watchdog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/15/android-framework-server-watchdog/" itemprop="url">WatchDog 原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-15T22:38:01+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">系统组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WatchDog 为系统的看门狗， 它会不断的查看它监控的线程的运行情况，如果发现异常，则会重启系统，之前排查问题的时候遇到过 WatchDog，但是一直没有分析 WatchDog ，趁着这两天有时间，把 WatchDog 的原理总结分析一下。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>WatchDog 是在 SystemServer 中启动的（后面会分析 SystemServer），SystemServer.java 文件位于</p>
<p>framework/services/java/com/android/server/SystemServer.java，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是 SystemServer 的 main 方法，直接新建了一个 SystemServer 对象，并执行了 run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    startOtherServices();</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">    Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    traceEnd();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪 startOtherServices 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">  watchdog.init(context, mActivityManagerService);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 startOtherServices 方法中，系统执行了对 WatchDog 的初始化，执行了 init 方法，WatchDog 的构造方法会在分析 WatchDog 的运行时进行分析。init 方法内部监听重启广播，这里不做分析。</p>
<p>到这里，我们已经执行了 WatchDog 的初始化，但是 WatchDog 究竟是一个什么样的类呢？WatchDog.java 位于</p>
<p>framework/services/java/com/android/server/WatchDog.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watchdog</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;......&#125;</span><br></pre></td></tr></table></figure>

<p>WatchDog 继承 Thread ，会作为一个线程运行，要启动一个线程，需要执行其 start 方法，SystemServer 内部是如何启动 WatchDog 的呢？答案在 AMS，在 SystemServer 的 startOtherServices 方法中，AMS 这样启动 WatchDog</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">  ......</span><br><span class="line">  Watchdog.getInstance().start();</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>AMS 在执行 systemReady 时，会调用 start 方法启动 WatchDog。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>上一节分析了 WatchDog 的启动过程，本节分析 WatchDog 启动后干了什么，如何为系统看门的。start 方法直接启动了线程，在分析运行之前，需要清楚在新建 WatchDog 对象时都做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Watchdog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"watchdog"</span>);</span><br><span class="line">        <span class="comment">// Initialize handler checkers for each common thread we want to check.  Note</span></span><br><span class="line">        <span class="comment">// that we are not currently checking the background thread, since it can</span></span><br><span class="line">        <span class="comment">// potentially hold longer running operations with no guarantees about the timeliness</span></span><br><span class="line">        <span class="comment">// of operations there.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The shared foreground thread is the main checker.  It is where we</span></span><br><span class="line">        <span class="comment">// will also dispatch monitor checks and do other work.</span></span><br><span class="line">        mMonitorChecker = <span class="keyword">new</span> HandlerChecker(FgThread.getHandler(),</span><br><span class="line">                <span class="string">"foreground thread"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">        mHandlerCheckers.add(mMonitorChecker);</span><br><span class="line">        <span class="comment">// Add checker for main thread.  We only do a quick check since there</span></span><br><span class="line">        <span class="comment">// can be UI running on the thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(<span class="keyword">new</span> Handler(Looper.getMainLooper()),</span><br><span class="line">                <span class="string">"main thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">        <span class="comment">// Add checker for shared UI thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(UiThread.getHandler(),</span><br><span class="line">                <span class="string">"ui thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">        <span class="comment">// And also check IO thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(IoThread.getHandler(),</span><br><span class="line">                <span class="string">"i/o thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">        <span class="comment">// And the display thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(DisplayThread.getHandler(),</span><br><span class="line">                <span class="string">"display thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize monitor for Binder threads.</span></span><br><span class="line">        addMonitor(<span class="keyword">new</span> BinderThreadMonitor());</span><br><span class="line"></span><br><span class="line">        mOpenFdMonitor = OpenFdMonitor.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See the notes on DEFAULT_TIMEOUT.</span></span><br><span class="line">        <span class="keyword">assert</span> DB ||</span><br><span class="line">                DEFAULT_TIMEOUT &gt; ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个陌生的 HandlerChecker 类，HandlerChecker 类的构造函数穿了一个 Handler 的对象，这个类的主要作用是定期去检测 Handler 对象对应的线程的运行状态。这里出现了 FgThread，UiThread，IoThread 以及 DisplayThread ，可能比较好奇，这都是些什么线程呢？查看源码就会发现，这些线程最终都继承 HandlerThread ，他们的主要作用就是为使用者提供 Handler 以便运行 Runnable，举个例子，DisplayThread 主要供 WindowManager，DisplayManager，InputManager 使用，以便他们可以执行 Runnable 的任务。如果以上线程在被检测过程中发现执行超时或者无响应，由于以上线程是系统运行必须的线程，WatchDog 则会重启系统。接下来就来分析 WatchDog 是如何检测线程运行的状态。</p>
<p>WatchDog 继承 Thread，他的主要工作为放在 run 函数中，所以分析 WatchDog 的运行机制，就从 WatchDog 的 run 函数开始，为了便于阅读，将 run 函数分几段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;HandlerChecker&gt; blockedCheckers;</span><br><span class="line">            <span class="keyword">final</span> String subject;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> allowRestart;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> timeout = CHECK_INTERVAL;</span><br><span class="line">                <span class="comment">// Make sure we (re)spin the checkers that have become idle within</span></span><br><span class="line">                <span class="comment">// this wait-and-check interval</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">                    HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">                    hc.scheduleCheckLocked();</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>在 WatchDog 的构造函数中，添加了若干 HandlerChecker 的对象，在执行循环检测时，首先遍历这些 HandlerChecker 对象的实例，并调用 scheduleCheckLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleCheckLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  如果没有 monitor 需要监控且当前线程 alive，则当前的检测已经完成</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (mMonitors.size() == <span class="number">0</span> &amp;&amp; mHandler.getLooper().getQueue().isPolling()) &#123;</span><br><span class="line">    <span class="comment">// If the target looper has recently been polling, then</span></span><br><span class="line">    <span class="comment">// there is no reason to enqueue our checker on it since that</span></span><br><span class="line">    <span class="comment">// is as good as it not being deadlocked.  This avoid having</span></span><br><span class="line">    <span class="comment">// to do a context switch to check the thread.  Note that we</span></span><br><span class="line">    <span class="comment">// only do this if mCheckReboot is false and we have no</span></span><br><span class="line">    <span class="comment">// monitors, since those would need to be executed at this point.</span></span><br><span class="line">    <span class="comment">// handler 当前未执行</span></span><br><span class="line">    mCompleted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	之前的检测还未完成，不需要继续执行检测了。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="keyword">if</span> (!mCompleted) &#123;</span><br><span class="line">    <span class="comment">// we already have a check in flight, so no need</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  开始检测</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  mCompleted = <span class="keyword">false</span>;</span><br><span class="line">  mCurrentMonitor = <span class="keyword">null</span>;</span><br><span class="line">  mStartTime = SystemClock.uptimeMillis();</span><br><span class="line">  mHandler.postAtFrontOfQueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入  scheduleCheckLocked 函数时有一个判断 mHandler.getLooper().getQueue().isPolling()，isPolling 是 MessageQueue 类中的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPolling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> isPollingLocked();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数判断当前线程是否正在从消息队列中获取消息以便执行相应的操作，返回 true 表示当前线程未被阻塞，正常运行，返回 false 表示当前线程已经被阻塞了。在新建 HandlerChecker 对象时，mCompleted = true，只有在开始检测的时候，mCompleted 才会被设置 false。</p>
<p>在开始检测时，mStartTime 首先记录了开始检测的时间，然后执行 mHandler.postAtFrontOfQueue(this)，接下来看下 HandlerChecker 的 run 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = mMonitors.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Watchdog.<span class="keyword">this</span>) &#123;</span><br><span class="line">      mCurrentMonitor = mMonitors.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentMonitor.monitor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (Watchdog.<span class="keyword">this</span>) &#123;</span><br><span class="line">    mCompleted = <span class="keyword">true</span>;</span><br><span class="line">    mCurrentMonitor = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，需要先了解一下 Monitor ，Monitor 是定义在 WatchDog 中的一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要被 WatchDog 监控的组件只需要实现此接口，然后调用 WatchDog.getInstance().addMonitor() 函数添加即可，至于 monitor 函数监控的细节，后面会做分析。每一个 monitor 实例执行完 monitor 函数后，将 mCompleted 设置为 true，表示本次检测完成。</p>
<p>继续回到 WatchDog 的 run 函数进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = SystemClock.uptimeMillis();</span><br><span class="line"><span class="comment">// 等待 CHECK_INTERVAL 时间</span></span><br><span class="line"><span class="keyword">while</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    wait(timeout);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    Log.wtf(TAG, e);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!fdLimitTriggered) &#123;</span><br><span class="line">  <span class="comment">// 获取 WatchDog 当前监控线程的状态，取所有线程的最差状态</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> waitState = evaluateCheckerCompletionLocked();</span><br><span class="line">  <span class="keyword">if</span> (waitState == COMPLETED) &#123;</span><br><span class="line">    <span class="comment">// The monitors have returned; reset</span></span><br><span class="line">    <span class="comment">// 监控的线程都已经执行完 monitor 函数正常返回</span></span><br><span class="line">    waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITING) &#123;</span><br><span class="line">    <span class="comment">// still waiting but within their configured intervals; back off and recheck</span></span><br><span class="line">    <span class="comment">// 监控的线程正在执行 monitor 函数，还未返回，未超过最长等待时间的 1/2，继续检查</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITED_HALF) &#123;</span><br><span class="line">    <span class="comment">// 等待超过最长等待时间的 1/2 ，继续等待</span></span><br><span class="line">    <span class="keyword">if</span> (!waitedHalf) &#123;</span><br><span class="line">      <span class="comment">// We've waited half the deadlock-detection interval.  Pull a stack</span></span><br><span class="line">      <span class="comment">// trace and wait another half.</span></span><br><span class="line">      ArrayList&lt;Integer&gt; pids = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      pids.add(Process.myPid());</span><br><span class="line">      ActivityManagerService.dumpStackTraces(<span class="keyword">true</span>, pids, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                                             getInterestingNativePids());</span><br><span class="line">      waitedHalf = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待已超时，</span></span><br><span class="line">  blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">  subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  blockedCheckers = Collections.emptyList();</span><br><span class="line">  subject = <span class="string">"Open FD high water mark reached"</span>;</span><br><span class="line">&#125;</span><br><span class="line">allowRestart = mAllowRestart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 系统记录相关日志并准备重启</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这里只保留了关键的代码，evaluateCheckerCompletionLocked 函数会计算所有线程的监控状态，返回最差的状态，WAITING 状态表示等待的时间少于最长等待时间的 1/2 ，会继续执行检测操作，WAIT_HALF 状态表示等待的时间已经大于最长等待时间的 1/2，会继续等待最长时间的 1/2。如果以上条件都不满足，则表示已经有线程等待超时，线程可能已经死掉了，由于 WatchDog 监控的都是系统运行的核心线程，如果等待超时，表示当前系统已经不稳定或者出现了异常，此时会进行系统重启。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>经过前面的分析，WatchDog 监控的流程已经又了一个清晰的认识，还有一个关键的问题没有解决：Monitor 接口里的 monitor 函数是如何监控线程是否是活的呢？</p>
<p>为了搞懂这个问题，需要找一个组件分析一下，就直接找 AMS 好了，看下 AMS 是如何实现 Monitor 接口的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我勒个大叉，什么玩意儿，为什么就是一个同步呢？分析一下这个同步的意义，synchronized 的意义是获取当前对的锁，如果可以成功获取，那么当前线程就没有出现死锁，当前线程就是活的，如果迟迟无法获取，则当前线程已经出现了死锁，无法再正常运行。</p>
<p>可以再看下其他实现 Monitor 接口的组件，他们的实现思路也是通过获取锁的方式检测线程的状态，这里就不在举例子了。</p>
<p>突然觉得 Google 的大佬们实在太有创意了，不知道他们是如何想出这么棒的方法检测线程的死锁。。。。。。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WatchDog 的实现十分巧妙，通过尝试获取线程相关锁的方式检测线程的状态，如果在规定的时间内可以正常获取锁，则表示线程运行状态正常，否则线程运行出现了死锁获取其他异常。</p>
<p>这里需要注意的是，WatchDog 会检测多个线程，只要有一个线程出现死锁异常，系统就会重启。</p>
<p>这里又学会了一个技能，用同步方法检测线程死锁，got it !!!</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/12/android-framework-battery-sys-promote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/12/android-framework-battery-sys-promote/" itemprop="url">Android 系统尝试耗电的措施</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-12T23:16:31+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了提高电池寿命，减少耗电，Android 系统在不断进行优化，本文只是简单的记录 Android6.0 到 Android 9.0 系统为了优化耗电所做的工作，并没有做过多的分析，如果需要看相关的详情，可以到官网查看。</p>
<h2 id="Android-6"><a href="#Android-6" class="headerlink" title="Android 6"></a>Android 6</h2><h3 id="Doze-低耗电模式"><a href="#Doze-低耗电模式" class="headerlink" title="Doze 低耗电模式"></a>Doze 低耗电模式</h3><ul>
<li>进入条件</li>
</ul>
<p>用户未插接设备的电源，在屏幕关闭且静止的情况下，让设备在一段时间内保持不活动状态，那么设备就会进入低电耗模式</p>
<ul>
<li>限制</li>
</ul>
<p>在低电耗模式下，系统会尝试通过限制应用访问占用大量网络和 CPU 资源的服务来节省电量。它还会阻止应用访问网络，并延迟其作业、同步和标准闹钟。</p>
<p>（1）暂停访问网络。</p>
<p>（2）系统忽略唤醒锁定。</p>
<p>（3）标准 AlarmManager 闹钟（包括 setExact() 和 setWindow()）推迟到下一个维护期。</p>
<p>a）如果您需要设置在设备处于低电耗模式时触发的闹钟，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。</p>
<p>b）使用 setAlarmClock() 设置的闹钟将继续正常触发，系统会在这些闹钟触发之前不久退出低电耗模式。</p>
<p>（4）系统不执行 WLAN 扫描。</p>
<p>（5）系统不允许运行同步适配器。</p>
<p>（6）系统不允许运行 JobScheduler。</p>
<h3 id="应用待机模式"><a href="#应用待机模式" class="headerlink" title="应用待机模式"></a>应用待机模式</h3><ul>
<li>进入条件</li>
</ul>
<p>应用待机模式允许系统判定应用在用户未主动使用它时是否处于闲置状态。当用户有一段时间未触摸应用时，系统便会作出此判定。</p>
<ul>
<li>退出和限制</li>
</ul>
<p>当用户将设备插入电源时，系统会从待机状态释放应用，允许它们自由访问网络并执行任何待处理的作业和同步。如果设备长时间处于闲置状态，系统将允许闲置应用访问网络，频率大约每天一次。</p>
<ul>
<li>排除条件</li>
</ul>
<p>（1）用户明确启动应用。</p>
<p>（2）应用当前有一个进程在前台运行（作为活动或前台服务，或者正在由其他活动或前台服务使用）。<br>注意：您只能将前台服务用于用户希望系统立即执行或不中断的任务。此类情况包括将照片上传到社交媒体，或者即使在音乐播放器应用不在前台运行时也能播放音乐。您不应该只是为了阻止系统判定您的应用处于闲置状态而启动前台服务。</p>
<p>（3）应用生成用户可在锁定屏幕或通知栏中看到的通知。</p>
<p>（4）应用是正在使用中的设备管理应用（例如设备策略控制器）。虽然设备管理应用通常在后台运行，但永远不会进入应用待机模式，因为它们必须保持可用性，以便随时从服务器接收策略。</p>
<h2 id="Android-7"><a href="#Android-7" class="headerlink" title="Android 7"></a>Android 7</h2><h3 id="增强了-Doze"><a href="#增强了-Doze" class="headerlink" title="增强了 Doze"></a>增强了 Doze</h3><p>通过在设备未插接电源且屏幕关闭状态下、但不一定要处于静止状态（例如用户外出时把手持式设备装在口袋里）时应用部分 CPU 和网络限制，进一步增强了低电耗模式。</p>
<ul>
<li>限制</li>
</ul>
<p>当设备处于充电状态且屏幕已关闭一定时间后，设备会进入低电耗模式并应用第一部分限制：关闭应用网络访问、推迟作业和同步。如果进入低电耗模式后设备处于静止状态达到一定时间，系统则会对 PowerManager.WakeLock、AlarmManager 闹铃、GPS 和 WLAN 扫描应用余下的低电耗模式限制。无论是应用部分还是全部低电耗模式限制，系统都会唤醒设备以提供简短的维护时间窗口，在此窗口期间，应用程序可以访问网络并执行任何被推迟的作业/同步。</p>
<h3 id="移除了三项隐式广播"><a href="#移除了三项隐式广播" class="headerlink" title="移除了三项隐式广播"></a>移除了三项隐式广播</h3><p>CONNECTIVITY_ACTION<br>对于 target 7.0 的应用，通过静态注册的广播，无法接收到  CONNECTIVITY_ACTION 广播；应用无法接收到 ACTION_NEW_PICTURE 或 ACTION_NEW_VIDEO 的广播</p>
<h2 id="Android-8"><a href="#Android-8" class="headerlink" title="Android 8"></a>Android 8</h2><h3 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h3><p>（1）前台应用</p>
<p>a）具有可见 Activity（不管该 Activity 已启动还是已暂停）。</p>
<p>b）具有前台 Service。</p>
<p>c）另一个前台应用已关联到该应用（不管是通过绑定到其中一个 Service，还是通过使用其中一个内容提供程序）。 例如，如果另一个应用绑定到该应用的 Service，那么该应用处于前台：<br>IME<br>壁纸 Service<br>通知侦听器<br>语音或文本 Service</p>
<ul>
<li>限制</li>
</ul>
<p>处于前台时，应用可以自由创建和运行前台与后台 Service。 进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用 Service。 在该时间窗结束后，应用将被视为处于空闲状态。 此时，系统将停止应用的后台 Service，就像应用已经调用 Service 的 Service.stopSelf() 方法一样。</p>
<p>在这些情况下，后台应用将被置于一个临时白名单中并持续数分钟。 位于白名单中时，应用可以无限制地启动 Service，并且其后台 Service 也可以运行。</p>
<h3 id="后台位置限制"><a href="#后台位置限制" class="headerlink" title="后台位置限制"></a>后台位置限制</h3><p>降低了后台应用接收位置更新的频率</p>
<h3 id="升级隐式广播限制"><a href="#升级隐式广播限制" class="headerlink" title="升级隐式广播限制"></a>升级隐式广播限制</h3><ul>
<li>限制</li>
</ul>
<p>（1）适配 Android 8.0 或更高版本的应用无法继续在其清单中为隐式广播注册广播接收器。 隐式广播是一种不专门针对该应用的广播。 例如，ACTION_PACKAGE_REPLACED 就是一种隐式广播，因为该广播将被发送给所有已注册侦听器，让后者知道设备上的某些软件包已被替换。 不过，ACTION_MY_PACKAGE_REPLACED 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只被发送给软件包已被替换的应用。</p>
<p>（2）应用可以继续在它们的清单中注册显式广播。</p>
<p>（3）应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注册接收器。</p>
<p>（4）需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。</p>
<p>以下链接可以查看隐式广播的例外<br><a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="noopener">https://developer.android.com/guide/components/broadcast-exceptions</a></p>
<h2 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h2><h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><h4 id="应用待机群组"><a href="#应用待机群组" class="headerlink" title="应用待机群组"></a>应用待机群组</h4><p>Android 9 引入了一项新的电池管理功能，即应用待机群组。 应用待机群组可以基于应用最近使用时间和使用频率，帮助系统排定应用请求资源的优先级。 根据使用模式，每个应用都会归类到五个优先级群组之一中。 系统将根据应用所属的群组限制每个应用可以访问的设备资源</p>
<p>五个群组按照以下特性将应用分组：</p>
<p><strong>活跃</strong></p>
<p>如果用户当前正在使用应用，应用将被归到“活跃”群组中，例如：</p>
<ul>
<li>应用已启动一个 Activity</li>
<li>应用正在运行前台服务</li>
<li>应用的同步适配器与某个前台应用使用的 content provider 关联</li>
<li>用户在应用中点击了某个通知</li>
</ul>
<p>如果应用处于“活跃”群组，系统不会对应用的作业、报警或 FCM 消息施加任何限制。</p>
<p><strong>工作集</strong></p>
<p>如果应用经常运行，但当前未处于活跃状态，它将被归到“工作集”群组中。 例如，用户在大部分时间都启动的某个社交媒体应用可能就属于“工作集”群组。 如果应用被间接使用，它们也会被升级到“工作集”群组中 。</p>
<p>如果应用处于“工作集”群组，系统会对它运行作业和触发报警的能力施加轻度限制。 如需了解详细信息，请参阅电源管理限制。</p>
<p>常用<br>如果应用会定期使用，但不是每天都必须使用，它将被归到“常用”群组中。 例如，用户在健身房运行的某个锻炼跟踪应用可能就属于“常用”群组。</p>
<p>如果应用处于“常用”群组，系统将对它运行作业和触发报警的能力施加较强的限制，也会对高优先级 FCM 消息的数量设定限制。 如需了解详细信息，请参阅电源管理限制。</p>
<p>极少使用<br>如果应用不经常使用，那么它属于“极少使用”群组。 例如，用户仅在入住酒店期间运行的酒店应用就可能属于“极少使用”群组。</p>
<p>如果应用处于“极少使用”群组，系统将对它运行作业、触发警报和接收高优先级 FCM 消息的能力施加严格限制。系统还会限制应用连接到网络的能力。 如需了解详细信息，请参阅电源管理限制。</p>
<p>从未使用<br>安装但是从未运行过的应用会被归到“从未使用”群组中。 系统会对这些应用施加极强的限制。</p>
<p>以下链接可以查看电源管理限制<br><a href="https://developer.android.com/topic/performance/power/power-details" target="_blank" rel="noopener">https://developer.android.com/topic/performance/power/power-details</a></p>
<h4 id="省电模式改进"><a href="#省电模式改进" class="headerlink" title="省电模式改进"></a>省电模式改进</h4><p>开启省电模式后，系统会对所有应用施加限制。 这是一项已有的功能，但在 Android 9 中得到了改进</p>
<h3 id="后台对传感器的访问受限"><a href="#后台对传感器的访问受限" class="headerlink" title="后台对传感器的访问受限"></a>后台对传感器的访问受限</h3><p>Android 9 限制后台应用访问用户输入和传感器数据的能力。 如果您的应用在运行 Android 9 设备的后台运行，系统将对您的应用采取以下限制：</p>
<ul>
<li>您的应用不能访问麦克风或摄像头。</li>
<li>使用连续报告模式的传感器（例如加速度计和陀螺仪）不会接收事件。</li>
<li>使用变化或一次性报告模式的传感器不会接收事件。</li>
</ul>
<p>如果您的应用需要在运行 Android 9 的设备上检测传感器事件，请使用前台服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-framework-battery-app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-framework-battery-app/" itemprop="url">Android App 耗电计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T22:27:08+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android 中对组件的耗电时间统计是由 BatteryStatusService 完成的，真正完成耗时统计的是类 BatteryStatsImpl 类。系统耗电排行中显示的耗电信息是通过 BatteryStatsHelper 类中相关的函数完成的。后面会分别分析 App 耗电和 硬件耗电，本文首先分析 App 耗电。</p>
<h2 id="耗电计算"><a href="#耗电计算" class="headerlink" title="耗电计算"></a>耗电计算</h2><p>App 耗电也称软件耗电，分别统计不同应用的耗电情况，系统通过 BatterStatsHelper 的 processAppUsage 函数，去更新不同应用的耗电信息，然后显示其排行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAppUsage</span><span class="params">(SparseArray&lt;UserHandle&gt; asUsers)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iu = <span class="number">0</span>; iu &lt; NU; iu++) &#123;</span><br><span class="line">		<span class="comment">// 统计每一个应用的耗电信息</span></span><br><span class="line">        <span class="keyword">final</span> Uid u = uidStats.valueAt(iu);</span><br><span class="line">        <span class="keyword">final</span> BatterySipper app = <span class="keyword">new</span> BatterySipper(BatterySipper.DrainType.APP, u, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// CPU </span></span><br><span class="line">        mCpuPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// WakeLock</span></span><br><span class="line">        mWakelockPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 移动网络</span></span><br><span class="line">        mMobileRadioPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">		<span class="comment">// wifi</span></span><br><span class="line">        mWifiPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 蓝牙</span></span><br><span class="line">        mBluetoothPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">		<span class="comment">// 传感器</span></span><br><span class="line">        mSensorPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 相机</span></span><br><span class="line">        mCameraPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 闪光灯</span></span><br><span class="line">        mFlashlightPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">		<span class="comment">// 多媒体</span></span><br><span class="line">        mMediaPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        <span class="comment">// 统计总的耗电</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> totalPower = app.sumPower();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有 Uid 类，可以将这个类的实例理解为一个应用， processAppUsage 函数循环遍历每一个应用，分别统计不同应用不同组件的耗电。每一个应用会分别计算应用的 CPU，Wakelock，移动网络，wifi，传感器，相机，闪光灯，多媒体的耗电情况，最后将这些组件的耗电相加便得到了应用的总耗电，前面已经分析过，Android 计算耗电实际上就是计算不同组件在不同状态的工作时间，下面在分析不同组件的耗电，也是沿着这样的思路。在分析每一个组件的耗电，只会列出最核心的代码，</p>
<h2 id="组件耗电"><a href="#组件耗电" class="headerlink" title="组件耗电"></a>组件耗电</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">        app.cpuTimeMs = (u.getUserCpuTimeUs(statsType) + u.getSystemCpuTimeUs(statsType)) / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numClusters = mProfile.getNumCpuClusters();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> cpuPowerMaUs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cluster = <span class="number">0</span>; cluster &lt; numClusters; cluster++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> speedsForCluster = mProfile.getNumSpeedStepsInCpuCluster(cluster);</span><br><span class="line">            <span class="comment">// 计算不同主频下 CPU 的耗电</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> speed = <span class="number">0</span>; speed &lt; speedsForCluster; speed++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> timeUs = u.getTimeAtCpuSpeed(cluster, speed, statsType);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">double</span> cpuSpeedStepPower = timeUs *</span><br><span class="line">                        mProfile.getAveragePowerForCpuCore(cluster, speed);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": CPU cluster #"</span> + cluster + <span class="string">" step #"</span></span><br><span class="line">                            + speed + <span class="string">" timeUs="</span> + timeUs + <span class="string">" power="</span></span><br><span class="line">                            + BatteryStatsHelper.makemAh(cpuSpeedStepPower / MICROSEC_IN_HR));</span><br><span class="line">                &#125;</span><br><span class="line">                cpuPowerMaUs += cpuSpeedStepPower;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cpuPowerMaUs += u.getCpuActiveTime() * <span class="number">1000</span> * mProfile.getAveragePower(</span><br><span class="line">                PowerProfile.POWER_CPU_ACTIVE);</span><br><span class="line">        <span class="keyword">long</span>[] cpuClusterTimes = u.getCpuClusterTimes();</span><br><span class="line">        <span class="comment">// 计算各个 Cluster 的平均耗电</span></span><br><span class="line">        <span class="keyword">if</span> (cpuClusterTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cpuClusterTimes.length == numClusters) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClusters; i++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> power =</span><br><span class="line">                            cpuClusterTimes[i] * <span class="number">1000</span> * mProfile.getAveragePowerForCpuCluster(i);</span><br><span class="line">                    cpuPowerMaUs += power;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": CPU cluster #"</span> + i + <span class="string">" clusterTimeUs="</span></span><br><span class="line">                                + cpuClusterTimes[i] + <span class="string">" power="</span></span><br><span class="line">                                + BatteryStatsHelper.makemAh(power / MICROSEC_IN_HR));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">" CPU cluster # mismatch: Power Profile # "</span></span><br><span class="line">                        + numClusters + <span class="string">" actual # "</span> + cpuClusterTimes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        app.cpuPowerMah = cpuPowerMaUs / MICROSEC_IN_HR;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，CPU 耗电计算了 CPU 在不同核心在不同主频下的耗电，并将这些耗电相加。</p>
<h3 id="Wakelock"><a href="#Wakelock" class="headerlink" title="Wakelock"></a>Wakelock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> wakeLockTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;String, ? extends BatteryStats.Uid.Wakelock&gt; wakelockStats =</span><br><span class="line">            u.getWakelockStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> wakelockStatsCount = wakelockStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wakelockStatsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Wakelock wakelock = wakelockStats.valueAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only care about partial wake locks since full wake locks</span></span><br><span class="line">        <span class="comment">// are canceled when the user turns the screen off.</span></span><br><span class="line">        BatteryStats.Timer timer = wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);</span><br><span class="line">        <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wakeLockTimeUs += timer.getTotalTimeLocked(rawRealtimeUs, statsType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    app.wakeLockTimeMs = wakeLockTimeUs / <span class="number">1000</span>; <span class="comment">// convert to millis</span></span><br><span class="line">    mTotalAppWakelockTimeMs += app.wakeLockTimeMs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add cost of holding a wake lock.</span></span><br><span class="line">    app.wakeLockPowerMah = (app.wakeLockTimeMs * mPowerWakelock) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wakeLockPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": wake "</span> + app.wakeLockTimeMs</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(app.wakeLockPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wakelock 的耗电逻辑比叫简单，但是这里有一个需要注意的位置，在统计 Wakelock 的耗电时，仅仅统计了 PARTIAL 类型的 Wakelock 的耗时，这就给我们使用 Wakelock 的策略提供了思路。</p>
<h3 id="移动网络"><a href="#移动网络" class="headerlink" title="移动网络"></a>移动网络</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add cost of mobile traffic.</span></span><br><span class="line">    app.mobileRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileActive = u.getMobileRadioActiveTime(statsType) / <span class="number">1000</span>;</span><br><span class="line">    app.mobileActiveCount = u.getMobileRadioActiveCount(statsType);</span><br><span class="line">    app.mobileRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.mobileActive &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We are tracking when the radio is up, so can use the active time to</span></span><br><span class="line">        <span class="comment">// determine power use.</span></span><br><span class="line">        mTotalAppMobileActiveMs += app.mobileActive;</span><br><span class="line">        app.mobileRadioPowerMah = (app.mobileActive * mPowerRadioOn) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We are not tracking when the radio is up, so must approximate power use</span></span><br><span class="line">        <span class="comment">// based on the number of packets.</span></span><br><span class="line">        app.mobileRadioPowerMah = (app.mobileRxPackets + app.mobileTxPackets)</span><br><span class="line">                * getMobilePowerPerPacket(rawRealtimeUs, statsType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.mobileRadioPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": mobile packets "</span></span><br><span class="line">                + (app.mobileRxPackets + app.mobileTxPackets)</span><br><span class="line">                + <span class="string">" active time "</span> + app.mobileActive</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(app.mobileRadioPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无线电耗电的计算分两种情况，如果 mobileActive &gt; 0 即 无线电处于 active 状态时，直接使用无线电处于 active 的时间乘以无线电在 active 时的功率 mPowerRadioOn 即可，如果未处于 active ，则使用收发的数据包数量乘以收发数据包的平均功率。</p>
<h3 id="wifi"><a href="#wifi" class="headerlink" title="wifi"></a>wifi</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = u.getWifiControllerActivity();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wifi 处于空闲的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTime = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="comment">// wifi 发送数据包的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTime = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="comment">// wifi 接收数据包的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTime = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="comment">// wifi 总运行时间</span></span><br><span class="line">    app.wifiRunningTimeMs = idleTime + rxTime + txTime;</span><br><span class="line">    mTotalAppRunningTime += app.wifiRunningTimeMs;</span><br><span class="line">    <span class="comment">// wifi 的总耗电</span></span><br><span class="line">    app.wifiPowerMah =</span><br><span class="line">            ((idleTime * mIdleCurrentMa) + (txTime * mTxCurrentMa) + (rxTime * mRxCurrentMa))</span><br><span class="line">            / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    mTotalAppPowerDrain += app.wifiPowerMah;</span><br><span class="line"></span><br><span class="line">    app.wifiRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wifiPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": idle="</span> + idleTime + <span class="string">"ms rx="</span> + rxTime + <span class="string">"ms tx="</span> +</span><br><span class="line">                txTime + <span class="string">"ms power="</span> + BatteryStatsHelper.makemAh(app.wifiPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wifi 的工作状态氛围空闲 idle，发送数据包 tx，接收数据包 如下，wifi 耗电的计算也分别计算了 wifi 在空闲，发送数据包和接收数据包时的耗电，最后计算了 wifi 收发的数据包。</p>
<h3 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = u.getBluetoothControllerActivity();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTimeMs = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTimeMs = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTimeMs = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTimeMs = idleTimeMs + txTimeMs + rxTimeMs;</span><br><span class="line">    <span class="keyword">double</span> powerMah = counter.getPowerCounter().getCountLocked(statsType)</span><br><span class="line">            / (<span class="keyword">double</span>)(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (powerMah == <span class="number">0</span>) &#123;</span><br><span class="line">        powerMah = ((idleTimeMs * mIdleMa) + (rxTimeMs * mRxMa) + (txTimeMs * mTxMa))</span><br><span class="line">                / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.bluetoothPowerMah = powerMah;</span><br><span class="line">    app.bluetoothRunningTimeMs = totalTimeMs;</span><br><span class="line">    app.btRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_BT_RX_DATA, statsType);</span><br><span class="line">    app.btTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_BT_TX_DATA, statsType);</span><br><span class="line"></span><br><span class="line">    mAppTotalPowerMah += powerMah;</span><br><span class="line">    mAppTotalTimeMs += totalTimeMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>蓝牙耗电的计算和 wifi 类似，蓝牙的工作状态也分为空闲 idle ，发送 tx，接收 rx，在计算蓝牙耗电时也分别计算了蓝牙在 idle ，tx，rx 时的耗电，最后将这些耗电进行相加。</p>
<h3 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process Sensor usage</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;? extends BatteryStats.Uid.Sensor&gt; sensorStats = u.getSensorStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NSE = sensorStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ise = <span class="number">0</span>; ise &lt; NSE; ise++) &#123;</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Sensor sensor = sensorStats.valueAt(ise);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sensorHandle = sensorStats.keyAt(ise);</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Timer timer = sensor.getSensorTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> sensorTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (sensorHandle) &#123;</span><br><span class="line">            <span class="keyword">case</span> BatteryStats.Uid.Sensor.GPS:</span><br><span class="line">                app.gpsTimeMs = sensorTime;</span><br><span class="line">                app.gpsPowerMah = (app.gpsTimeMs * mGpsPower) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> sensorsCount = mSensors.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sensorsCount; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Sensor s = mSensors.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (s.getHandle() == sensorHandle) &#123;</span><br><span class="line">                        app.sensorPowerMah += (sensorTime * s.getPower()) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传感器耗电分为两种：GPS ，其他传感器，GPS 的耗电记录在 PowerProfile.xml 文件中，保存在 mGpsPower 中，其他传感器的计算根据SensorManager得到所有传感器类型，这个里面保存有不同传感器的单位耗电量，这样就能计算不同传感器的耗电量。</p>
<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate camera power usage.  Right now, this is a (very) rough estimate based on the</span></span><br><span class="line">    <span class="comment">// average power usage for a typical camera application.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer timer = u.getCameraTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.cameraTimeMs = totalTime;</span><br><span class="line">        app.cameraPowerMah = (totalTime * mCameraPowerOnAvg) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app.cameraTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.cameraPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相机的耗电首先计算出相机工作的时间，然后乘以相机的平均耗电。</p>
<h3 id="闪光灯"><a href="#闪光灯" class="headerlink" title="闪光灯"></a>闪光灯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate flashlight power usage.  Right now, this is based on the average power draw</span></span><br><span class="line">    <span class="comment">// of the flash unit when kept on over a short period of time.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer timer = u.getFlashlightTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.flashlightTimeMs = totalTime;</span><br><span class="line">        app.flashlightPowerMah = (totalTime * mFlashlightPowerOnAvg) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app.flashlightTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.flashlightPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闪光灯的耗电和相机类似，先计算相机工作的时间，然后乘以相机的平均耗电。</p>
<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Calculate audio power usage, an estimate based on the average power routed to different</span></span><br><span class="line">    <span class="comment">// components like speaker, bluetooth, usb-c, earphone, etc.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer audioTimer = u.getAudioTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (audioTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.audioTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.audioPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = audioTimer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.audioTimeMs = totalTime;</span><br><span class="line">        app.audioPowerMah = (totalTime * mAudioAveragePowerMa) / MS_IN_HR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate video power usage.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer videoTimer = u.getVideoTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (videoTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.videoTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.videoPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = videoTimer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.videoTimeMs = totalTime;</span><br><span class="line">        app.videoPowerMah = (totalTime * mVideoAveragePowerMa) / MS_IN_HR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多媒体耗电分别计算音频和视频的耗电，耗电的计算方法和闪光灯和相机类似，分别计算出工作时间，然后乘以平均能耗。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android App 耗电的分析初步写完了。其实耗电的计算也没有那么复杂，和我们平时生活中的耗电计算的思路是相同的，唯一不同的是这里计算的是移动设备。</p>
<p>Android 系统中，不同组件的耗电功率数据通过记录在文件 PowerProfile.xml 文件中，PowerProfile.xml 文件是进行耗电分析的基础，如果这个文件的数据有问题，那么我们的分析结果就是有问题，这也提醒我们，一些小的或者不知名的厂商，他们的耗电数据可能是不准确的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-summary/" itemprop="url">Android 容器总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T21:10:55+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于其他设备，移动设备有自己的特点，内存小是一个很突出的问题，Google针对android设备的这一特点，开发了一套容器框架，目的就是为了更加高效地利用内存。接下来就对这些容器进行一下总结。</p>
<h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/android_container.png" alt=""><br>以上是android中容器的实现继承结构，简单梳理一下：</p>
<ul>
<li>ArraySet 实现了 Set 和 Collections 接口，在api 23中添加</li>
<li>ArrayMap 实现了 Map 接口，在api 19中添加</li>
<li>SparseArray ， SparseIntArray ， SparseBooleanArray 实现了 Cloneable 接口，在api 1中添加</li>
<li>SparseLong 实现了 Cloneable 接口，在api 18中添加</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>从功能上划分，可以将以上容器划分为两类：</p>
<ul>
<li><p>存储元素<br> ArraySet 优化了 HashSet 对元素的存储</p>
</li>
<li><p>存储键值对</p>
<p>相较于 HashMap ，具体的优化方向如下：</p>
<p> ArrayMap 优化了 HashMap 存储 Object –&gt; Object 的键值存储；<br> SparseArray 优化了 int –&gt; Object 的键值存储；<br> SparseIntArray 优化了 int –&gt; int 的键值存储；<br> SparseBooleanArray 优化了  int –&gt; boolean 的键值存储；<br> SparseLongArray 优化了  int –&gt; long 的键值存储</p>
</li>
</ul>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>从组织结构可以看出，可以将这些容器分为3类： ArraySet , ArrayMap 和剩余的容器。通过前面的分析可以知道， ArraySet 和 ArrayMap 使用的相同的优化方式， SparseArray 在进行优化的时候使用 gc 垃圾回收策略，故从优化方法上进行分类的话可以分一下三类：</p>
<ul>
<li>ArraySet ,  ArrayMap<br>使用数组 mKeys 存储 key 的hash值，hash 值在 mKeys 的位置为 index，并将 value 存储到 mValues 数组对应下标的位置（ ArrayMap 中 key 和 value 分别在 mValues 的 index * 2 和 index * 2 + 1 的位置）。查找或者修改元素时，使用二分查找在 mKeys 中找到元素在 mValues 的下标，然后进行修改或者返回。</li>
<li>SparseArray<br>使用 int 类型的 mKeys 数组存储 int 类型的键，下标为 index ，将 Object 类型的 value 存储在在 Object 类型的数组 mValues 的 index 位置，在查找和修改时，使用二分查找在 mKeys 中找到元素在 Values 的下标，然后进行修改或者返回。在删除 value 时， SparseArray 并不直接进行数组元素的移动，而是将待删除的 value 标记为DELETED 状态，在 gc 的过程中将所有非 DELETED 状态的元素移动到数组的最前面，从而减少二分查找的时间。</li>
<li>SparseIntArray,  SparseLongArray ,  SparseBooleanArray<br>这3个容器可以理解成专用容器，使用 int 类型数组和对应类型的数组；使用二分查找快速查找元素，然后进行删除，修改，添加操作。</li>
</ul>
<h2 id="优化共同点与差异"><a href="#优化共同点与差异" class="headerlink" title="优化共同点与差异"></a>优化共同点与差异</h2><p>虽然这些容器存储的元素类型不同，但是通过分析可以发现他们在内存优化中的共同点，接下来就分析下这些容器在优化上存在的共同点和差异。</p>
<p> <strong>共同点</strong></p>
<ul>
<li><p>数据结构<br><img src="https://raw.githubusercontent.com/rockstore/images/master/data_h_v2.png" alt=""><br>这里的数据结构是指容器的底层存储结构，虽然在 ArrayMap 中 mValues 的长度是 mKeys 的 2 倍，但也仅仅是数组长度上的差异，底层存储使用的思想仍然是一样的；int 类型的数组 mKeys 里的元素时按照升序进行排列的。相较于 HashMap 使用 Node 结构存储，这样的存储方式使用更小的存储空间存储 k-v ，同时避免了原始数据类型的自动装箱。</p>
</li>
<li><p>查找方法<br>在组织结构中列出的容器，他们在进行元素查找时，都会先在 mKeys 数组中利用二分查找找到元素的下标 index ，然后使用 index 到 mValues 数组中对 value 进行操作。</p>
</li>
<li><p>获取带插入下标<br>在进行元素插入时，会首先使用二分查找在 mKeys 数组中查找元素的下标，如果元素不存在，则二分查找会返回元素待插入位置的取反。</p>
<br>

</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>对 key的处理<br>ArraySet,  ArrayMap 底层实现时，会计算待插入元素的 hash 值，根据 hash 值，在 mKeys 找到待插入位置；SparseArray 和 SparseXXXArray 存储的时候直接使用 key 值，不会进行 hash 计算。</li>
<li>对 null 的处理<br>ArraySet 和 ArrayMap 允许插入 key 为 null 的元素， key 的 hash 值为 0； SparseArray 和 SparseXXXArray 存储的时由于直接使用int类型的数据作为key ，故不存在 key 为 null 的情况。</li>
<li>缓存<br>为了避免频繁的内存回收，ArraySet 和 ArrayMap 添加了缓存结构，SparseArray 和 SparseXXXArray 没有缓存</li>
<li>扩容规则<br>ArraySet 和 ArrayMap 在进行扩容的时，容量的变化规则为 4, 8 , size * 2 / 3 ， SparseArray 和 SparseXXXArray 使用 ArrayUtils.newUnpaddedArray 建立新的数据，将原来的数据拷贝到新数组中。</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>虽然这些容器在Android设备上可以更高效地利用内存，但是还是存在使用使用限制。</p>
<ul>
<li>兼容性<br>在组织结构中，可以看到，并不是所有的容器都是从api 1就开始提供的，在使用具体的容器时，需要考虑应用的兼容。</li>
<li>对性能的影响<br>虽然 ArrayMap 在删除时不直接使用移动元素的方式删除元素，但是在获取数组元素等操作中还是</li>
<li>对数量的限制<br>在对元素进行查找时会使用二分查找，元素数量较大（超过1000）时，查找效率会降低，相较于<code>HashMap</code>只要数量不超过1000，效率最多不会下降50%。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面说了很多，其实android容器优化的根本思想就是使用 int 到其他类型的映射，使用数组保存着两个映射，用以优化 HashMap 对 k-v 的存储。这种优化适用于元素数量较少（少于1000）的情况。</p>
<p>以上所写是我的个人总结，可能有总结不到位的情况，有任何问题感谢大家及时向我反馈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-sparseintarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-sparseintarray/" itemprop="url">Android SparseIntArray</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T21:07:03+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  SparseArray  优化了  int  到  Object  键值对的存储，  SparseIntArray  优化了  int  到  int  键值对的存储。android中在键值对存储上的优化主要做了一下几种类型的优化:</p>
<ul>
<li>int   –&gt;   Object  (SparseArray)</li>
<li>int   –&gt;   int  (SparseIntArray)</li>
<li>int   –&gt;   boolean  (SparseBooleanArray)</li>
<li>int   –&gt;   long  (SparseLongArray)</li>
<li>int   –&gt;   Set  (SparseSetArray)</li>
</ul>
<p>SparseSetArray 目前在sdk中还处于hide状态，故在做总结的时候就不分析它了。</p>
<p>之前已经分析过  SparseArray  ，本文就分析下  SparseIntArray  的实现，并在最后总结下这几种键值对在实现上的共同点。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/SparseIntArray_h.png" alt=""></p>
<br>
以上为  SparseIntArray  的继承体系。  SparseIntArray  只实现了  Cloneable  接口，结构比较简单。其实阅读源码可以发现，  SparseArray  ，  SparseIntArray  ，  SparseBooleanArray  ，  SparseLongArray  都只实现了  Cloneable  接口。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/SparseIntArray_s.png" alt=""></p>
<br>
以上为  SparseIntArray  的存储结构，mKeys存储的是int类型的键，mValues存储的是int类型的value。

<h2 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h2><pre><code>// 查找键key在mKeys的下标
public int indexOfKey(int key) {
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}

// 查找value在mValues的下标
public int indexOfValue(int value) {
    for (int i = 0; i &lt; mSize; i++)
        if (mValues[i] == value)
            return i;
    return -1;
}</code></pre><p>元素的查找分键查找和值查找，键查找使用二分查找，值查找直接使用循环遍历。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><pre><code>public void put(int key, int value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        mValues[i] = value;
    } else {
        i = ~i;

        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}</code></pre><p>添加元素首先使用二分查找找到key在mKeys数组的下标，也就是value在mValues数组的下标。如果   ContainerHelpers.binarySearch(mKeys, mSize, key)  在mKeys数组中没有找到key，则返回key待插入位置的下标的取反，如果找到了key，则直接更新mValues对应位置的值即可。<br>  GrowingArrayUtils.insert  函数的实现如下：</p>
<pre><code>public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize &lt;= array.length;

    if (currentSize + 1 &lt;= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    }

    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}</code></pre><p>函数的逻辑很简单，首先断言了currentSize &lt;= array.length；如果array在不需要扩大容量的情况下可以添加一个元素，则先将待插入位置index开始的元素整体后移一位，然后插入元素，否则先扩容，然后将元素拷贝到新的数组中。</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><pre><code>public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i &gt;= 0) {
        removeAt(i);
    }
}

public void removeAt(int index) {
    System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));
    System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));
    mSize--;
}</code></pre><p>删除元素主要涉及以上两个方法，  delete(int key)  根据  key  进行删除，  removeAt(int index)  删除指定下标的元素。这两个方法都是  public  ，故都可以直接使用。  delete(int key)  ，先使用二分查找，找到  key  在  mKeys  的下标，如果找到即  i &gt;= 0  ，则直接删除  mKeys  和  mValues  指定位置的元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有  SparseBooleanArray  ，  SparseLongArray  还没有分析，他们的实现规则是一样的，只是存储的数据类型的  mValues  数组是  boolean   和   long  ，接下来就对  SparseIntArray  ，  SparseBooleanArray  ，  SparseLongArray  进行下总结。</p>
<ul>
<li>他们的设计目的是优化  int  到  int  ,   boolean   ,  long  映射的存储</li>
<li>使用  int  类型的数组  mKeys  存储映射的键，使用对应类型的数组  mValues  存储值</li>
<li>int  类型的键在存储上是有顺序的</li>
<li>在查找值时，先使用二分查找，在  mKeys  中查找值在  mValues  中的下标，然后返回值</li>
</ul>
<p>以上三种数据类型和  SparseArray  最大的区别在于  SparseArray  在删除元素的时候会将元素设置为  DELETED  ，后续会有  gc  的过程。</p>
<p>相对于使用HashMap，这样的设计的优势和缺点：</p>
<p><strong>优势：</strong></p>
<ul>
<li>避免  int  类型的键自动装箱</li>
<li>相较于  HashMap  使用  Node  ，这样的设计使用更小的存储单元即可存储  key  到  value  的映射</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在进行元素查找时使用二分查找，元素较多（谷歌给出的数字是大于1000）时，查找效率较低</li>
<li>在进行元素的添加和删除时，可能会频繁进行元素的移动，运行效率可能会降低</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-sparearray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-sparearray/" itemprop="url">Android SpareArray</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T20:55:59+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> SparseArray 和其他的Android容器类一样，都是为了更加有效地利用内存，说直白点，就是为了节省内存。 SparseArray 和 ArrayMap 一样，都是为了更高效的保存int值到非原始类型的映射，用了同样的数据结构，但是为了提高效率， SparseArray 也做了自己的优化。接下来就分析一下 SparseArray 的存储，添加和删除元素。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p><img src="http://p0.qhimg.com/t01ebe97cef584833f4.png" alt=""></p>
<br>
上图表明， SparseArray 并没有像 ArrayMap 一样实现 Map 接口，仅仅实现了 Cloneable 接口。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="http://p0.qhimg.com/t0135547fb1e591cb0e.png" alt=""></p>
<br>
存储结构和 ArraySet 以及 ArrayMap 一脉相承，都使用int数组存储key值，使用Object数组存储对象。不同点在于 mKeys 数组中存储的是添加元素的key值本身，没有进行hash值得计算。


<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><pre><code>public void put(int key, E value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        mValues[i] = value;
    } else {
        i = ~i;

        if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }

        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {
            gc();

            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }

        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}</code></pre><p> put 方法首先使用二分查找在 mKeys 中查找 key ，如果找到，则直接更新对应下标的 value 。如果未找到， binarySearch 方法返回待插入的下标的取反，故 i = ~i 。如果待插入的位置的元素已经被标记为 DELETED ，则直接更新并返回。如果需要执行 gc 函数，且需要扩大数组的容量（ mSize &gt;= mKeys.lengt ），则先执行 gc 函数。由于执行 gc 函数之后元素会发生移动，故重新计算待插入位置，最后执行元素的插入。插入函数分为插入 key 和插入 value 。 GrowingArrayUtils.insert 的源码如下：</p>
<pre><code>public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize &lt;= array.length;

    if (currentSize + 1 &lt;= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    }

    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}</code></pre><p>函数的逻辑很简单，首先断言了 currentSize &lt;= array.length ；如果 array 在不需要扩大容量的情况下可以添加一个元素，则先将待插入位置 index 开始的元素整体后移一位，然后插入元素，否则先扩容，然后将元素拷贝到新的数组中。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>为什么删除的时候我没有使用一个具体的函数呢，是因为 SparseArray 的删除有两种：根据key删除对象，删除指定位置的对象。</p>
<h3 id="根据key删除对象"><a href="#根据key删除对象" class="headerlink" title="根据key删除对象"></a>根据key删除对象</h3><pre><code>public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i &gt;= 0) {
        if (mValues[i] != DELETED) {
            mValues[i] = DELETED;
            mGarbage = true;
        }
    }
}</code></pre><p> ContainerHelpers.binarySearch 函数在 ArraySet 和 ArrayMap 的元素查找中都出现过，作用是使用二分查找，在 mKeys 中找到 key 的位置，如果 key 存在，则返回 key 在 mKeys 中的下标，否则返回试图将 key 插入到 mKeys 中的位置的取反。找到待删除元素的下标后， SparseArray 并没有像 ArraySet 和 ArrayMap 一样去删除元素，只是将待删除元素标记为 DELETED ，然后将 mGarbage 设置为 true 。 DELETED 实际上就是一个对象，具体申明为：  Object DELETED =  new Object() ， SparseArray 有 gc 的过程，后面会分析这个 gc 的过程。</p>
<h3 id="删除执行位置的对象"><a href="#删除执行位置的对象" class="headerlink" title="删除执行位置的对象"></a>删除执行位置的对象</h3><pre><code>public void removeAt(int index) {
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}</code></pre><p>删除指定位置元素的逻辑比较简单，判断待删除位置的元素是否已经被标记为 DELETED ，如果没有被标记，则标记指定位置的元素，并将 mGarbage 设置为 true 。</p>
<p>元素在被删除之后，都会将标志 mGarbage 设置为 true ，这是执行 gc 的必要条件。</p>
<h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>说到gc，给我的第一感觉应该是什么高深的c/c++源码，其实不是，贴上 gc 的源码</p>
<pre><code>private void gc() {
    int n = mSize;
    int o = 0;
    int[] keys = mKeys;
    Object[] values = mValues;

    for (int i = 0; i &lt; n; i++) {
        Object val = values[i];

        if (val != DELETED) {
            if (i != o) {
                keys[o] = keys[i];
                values[o] = val;
                values[i] = null;
            }
            o++;
        }
    }

    mGarbage = false;
    mSize = o;
}</code></pre><p>好吧，开始被自己给吓着了， gc 函数没有那么复杂。 gc 函数实际上就是将 mValues 数组中还未标记为 DELETED 的元素以及对应下标的 mKeys 数组中的元素移动到数组的前面，保证数组在0到 mSize 之间的元素都是未被标记为 DELETED ，经过 gc 之后，数据的位置可能会发生移动。</p>
<p>在元素被删除后，标志 mGarbage 设置为 true ，表示可以执行 gc 函数了。那么 gc 函数会在什么位置执行呢？<br>分析 SparseArray 源码可以发现，如果 mGarbage 设置为 true ，在以下函数调用中 gc 函数会执行：</p>
<p> put , append ，  size , keyAt , valueAt , setValueAt , indexOfKey , indexOfValue , indexOfValueByValue 。</p>
<p>将以上函数总结一下可以归纳为三类：</p>
<ul>
<li>向SparseArray添加元素</li>
<li>修改SparseArray的mValues数组</li>
<li>获取SparseArray的属性</li>
</ul>
<p>通过执行 gc 将未被标记为 DELETED 的元素前移，在进行元素查找时可以减少需要查找的元素的数量，减少查找的时间，在添加元素的时候也可以更加快速的找到待插入点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SparseArray 主要是为了优化 int 值到 Object 映射的存储，提高内存的使用效率。相较于 HashMap ，在存储上的优化如下：</p>
<ul>
<li>使用int和Object类型的数组分别存储key和value，相较于 HashMap 使用Node， SparseArray 在存储单个key-value时更节省内存</li>
<li>SparseArray 使用int数组存储int类型的key，避免了int到Integer的自动装箱机制</li>
</ul>
<p>虽然在存储int到Object映射时的内存使用效率更高，由于使用数组存储数组，在添加或者删除元素时需要进行二分查找，元素较多（超过1000）是效率较低，谷歌给出的建议是数据量不要超过1000，这种情况下，相较于 HashMap ,效率降低不会超过50%</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-arrayset%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-arrayset%E5%88%86%E6%9E%90/" itemprop="url">Android ArraySet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T00:32:44+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直在使用Set相关类进行运行时数据存储，之前也有知道 Android 为了更加有效的利用内存，在23的时候设计了自己的一套运行时的集合类。本文的以我的视角分析 ArraySet 的 add 和 remove 过程，并做了简单的对比分析。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://p0.qhimg.com/t01ebc5f5688c918e20.png" alt=""></p>
<br>
ArraySet 实现了 Set 和 Collections 接口，故 add 和 remove 接口的使用方式相同，就不在对这两个接口的使用提供示例。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="http://p0.qhimg.com/t01dbd3b0687f23f126.png" alt=""></p>
<br/> 
ArraySet 在进行 add 和 remove 操作时，操作的是 int[] 类型的 mHashes 和 Object[] 类型的 mArray ，其中mHashes 保存 mArray 每个元素的 hash 值，且 mHashes 和 mArray 相同下标的元素一一对应。

<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p><img src="http://p0.qhimg.com/t010b82f86211d13d60.png" alt=""></p>
<br/>
以上为add的流程，可以概括为以下几点：

<ul>
<li><p>判断元素是否存在，已存在则直接返回<br>indexOf 函数判断待插入元素是否存在，如果存在，则直接返回元素在 mArray 的下标，如果不存在，则返回带插入元素即将插入的位置的取反 </p>
</li>
<li><p>判断是否需要对存储元素的数组进行扩容<br>ArraySet 使用 mSize 记录当前元素的数量，如果 mSize &gt;= mHashes.length (元素的数量大于等于数组的长度)，则需要对数组进行扩容，则计算扩容后的容量，扩容的规则会后续说明。扩容过程中还会涉及到的缓存也会后续说明。</p>
</li>
<li><p>根据元素插入的位置判断是否需要对数组元素进行移动<br>如果数组中不存在待插入元素，则在第一步中会计算出带插入元素待插入位置的取反，此不会再次取反，获得真实待插入的位置 index 。如果 index &lt; mSize (插入位置不在数组末尾)，则需要将 index+1 只 mSize - 1 位置的元素后移一位。</p>
</li>
<li><p>插入元素<br>将待插入元素本身和其hash值分别插入到 mArray 和 mHashes 的 index 位置</p>
</li>
</ul>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p><img src="http://p0.qhimg.com/t013c2e659cc85b9bd9.png" alt=""></p>
<br>
remove得流程可以概括如下：

<ul>
<li>判断元素是否存在，如果不存在则直接返回</li>
<li>如果当前元素小于等于1，则将mHashes和mArray置空，否则会进行扩容判断判断</li>
<li>如果需要进行扩容，则计算扩容后的容量，扩容过程中涉及到的缓存处理会后续说明，扩容完成后会将原来数组中的元素copy到新数组中</li>
<li>扩容完成后，执行将index至mSize-1的元素前移一位，删除待删除元素</li>
</ul>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>indexOf函数功能是查找元素在mArray中的位置，在add和remove操作过程中都涉及到查找元素的过程。看下这个函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private int indexOf(Object key, int hash) &#123;</span><br><span class="line">    final int N &#x3D; mSize;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Important fast case: if nothing is in here, nothing to look for.</span><br><span class="line">    if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return ~0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index &#x3D; ContainerHelpers.binarySearch(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the hash code wasn&#39;t found, then we have no entry for this key.</span><br><span class="line">    if (index &lt; 0) &#123;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the key at the returned index matches, that&#39;s what we want.</span><br><span class="line">    if (key.equals(mArray[index])) &#123;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Search for a matching key after the index.</span><br><span class="line">    int end;</span><br><span class="line">    for (end &#x3D; index + 1; end &lt; N &amp;&amp; mHashes[end] &#x3D;&#x3D; hash; end++) &#123;</span><br><span class="line">        if (key.equals(mArray[end])) return end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a matching key before the index.</span><br><span class="line">    for (int i &#x3D; index - 1; i &gt;&#x3D; 0 &amp;&amp; mHashes[i] &#x3D;&#x3D; hash; i--) &#123;</span><br><span class="line">        if (key.equals(mArray[i])) return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Key not found -- return negative value indicating where a</span><br><span class="line">    &#x2F;&#x2F; new entry for this key should go.  We use the end of the</span><br><span class="line">    &#x2F;&#x2F; hash chain to reduce the number of array entries that will</span><br><span class="line">    &#x2F;&#x2F; need to be copied when inserting.</span><br><span class="line">    return ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexOf函数的实现比较简单，首先会判断当前元素数量是否为0，如果是0，则直接返回-1，否则使用二分查找ContainerHelpers.binarySearch(mHashes, N, hash)获取元素的位置index。ContainerHelpers.binarySearch的代码比较简单，就不分析了。如果待查找元element素和mArray[index]相同，表示元素已经找到，直接返回index。若element未找到，则使用end记录如果将element插入mArray时的位置。</p>
<p>可以发现，indexOf函数有两个作用：</p>
<ul>
<li>查找element在mArray中的位置</li>
<li>若element在mArray中不存在，则返回将element插入mArray中的位置的取反。</li>
</ul>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>ArraySet中没有resize函数，这里的resize表示ArraySet在add和remove时可能会执行的扩容操作，这里的扩容可能是增加容量，也可能是缩小容量。接下来会分别分下add和remove过程中涉及到的扩容操作。</p>
<h3 id="add扩容"><a href="#add扩容" class="headerlink" title="add扩容"></a>add扩容</h3><p>add过程中，如果mSize &gt;= mHashes.length(元素的数量大于等于数组的长度)，则数组(mHashes和mArray)需要进行扩容，扩容规则如下</p>
<pre><code>private static final int BASE_SIZE = 4;

final int n = mSize &gt;= (BASE_SIZE * 2) ? (mSize + (mSize &gt;&gt; 1))
            : (mSize &gt;= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);</code></pre><p>BASE_SIZE是ArraySet扩容的最小增量，已经经过Google工程师验证过，BASE_SIZE = 4时，内存的使用效率最高。根据以上的扩容规则，假设我们使用ArraySet mSet = new ArraySet()的方式新建了一个ArraySet对象，mHashes和mArray的长度大小变化如下：</p>
<p><img src="http://p0.qhimg.com/t01b06cfba9651c1e15.png" alt=""></p>
<p>上图中，mSize表示mHashes和mArray中元素的数量，length表示mHashes和mArray的长度。</p>
<h3 id="remove缩容"><a href="#remove缩容" class="headerlink" title="remove缩容"></a>remove缩容</h3><p>remove的过程中ArraySet会根据一定的规则对mHashes和mArray的大小进行缩小，缩小规则如下：</p>
<pre><code>if (mHashes.length &gt; (BASE_SIZE * 2) &amp;&amp; mSize &lt; mHashes.length / 3) {
    final int n = mSize &gt; (BASE_SIZE * 2) ? (mSize + (mSize &gt;&gt; 1)) : (BASE_SIZE * 2);
    ......
}</code></pre><p>缩容的规则比扩容稍微简单一些，数组mHashes和mArray长度是一样的，故缩容的条件可理解为：</p>
<ul>
<li>mHashes和mArray长度大于BASE_SIZE * 2</li>
<li>mHashes和mArray中元素的数量小于数组长度的1/3</li>
</ul>
<p>缩容之后数组mHashes和mArray的长度：</p>
<pre><code>n = mSize &gt; (BASE_SIZE * 2) ? (mSize + (mSize &gt;&gt; 1)) : (BASE_SIZE * 2);</code></pre><p>可以发现，缩容之后，mHashes和mArray的长度最小为BASE_SIZE * 2</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在add过程中，如果需要扩容，需要走如下逻辑：</p>
<pre><code>final int[] ohashes = mHashes;
final Object[] oarray = mArray;
allocArrays(n);
......
freeArrays(ohashes, oarray, mSize);</code></pre><p>在remove过程中，如果需要缩容，则需要走如下逻辑：</p>
<pre><code>final int[] ohashes = mHashes;
final Object[] oarray = mArray;
allocArrays(n);</code></pre><p>以上两段代码中n表示计算后数组的容量。在add的扩容和remove的缩容过程中，都会调用allocArray，可以看下具体实现，代码可能比较长，但不是很复杂</p>
<pre><code>private void allocArrays(final int size) {
    if (size == (BASE_SIZE * 2)) {
        synchronized (ArraySet.class) {
            if (sTwiceBaseCache != null) {
                final Object[] array = sTwiceBaseCache;
                try {
                    mArray = array;
                    sTwiceBaseCache = (Object[]) array[0];
                    mHashes = (int[]) array[1];
                    array[0] = array[1] = null;
                    sTwiceBaseCacheSize--;
                    if (DEBUG) {
                        Log.d(TAG, &quot;Retrieving 2x cache &quot; + mHashes + &quot; now have &quot;
                                + sTwiceBaseCacheSize + &quot; entries&quot;);
                }
                return;
                } catch (ClassCastException e) {
                }
                // Whoops!  Someone trampled the array (probably due to not protecting
                // their access with a lock).  Our cache is corrupt; report and give up.
                Slog.wtf(TAG, &quot;Found corrupt ArraySet cache: [0]=&quot; + array[0]
                        + &quot; [1]=&quot; + array[1]);
                sTwiceBaseCache = null;
                sTwiceBaseCacheSize = 0;
            }
        }
    } else if (size == BASE_SIZE) {
        synchronized (ArraySet.class) {
            if (sBaseCache != null) {
                final Object[] array = sBaseCache;
                try {
                    mArray = array;
                    sBaseCache = (Object[]) array[0];
                    mHashes = (int[]) array[1];
                    array[0] = array[1] = null;
                    sBaseCacheSize--;
                    if (DEBUG) {
                        Log.d(TAG, &quot;Retrieving 1x cache &quot; + mHashes + &quot; now have &quot; + sBaseCacheSize
                                + &quot; entries&quot;);
                    }
                    return;
                } catch (ClassCastException e) {
                }
                // Whoops!  Someone trampled the array (probably due to not protecting
                // their access with a lock).  Our cache is corrupt; report and give up.
                Slog.wtf(TAG, &quot;Found corrupt ArraySet cache: [0]=&quot; + array[0]
                        + &quot; [1]=&quot; + array[1]);
                sBaseCache = null;
                sBaseCacheSize = 0;
            }
        }
    }

    mHashes = new int[size];
    mArray = new Object[size];
}</code></pre><p>如果不考虑缓存部分，直接到函数的最后，可以发现，allocArray函数其实就是根据计算出来的长度，新建了mHashes和mArray数组。再看下缓存部分，Google设计了两个节点，BASE_SIZE和BASE_SIZE * 2，如果计算后数组的容量是以上两个节点，则尝试从缓存中给mHashes和mArray赋值。至于为什么不设置其他的节点，个人猜测，可能是Google认为这两个节点是数组在变化过程中会经常到达的点；也可能是认为如果缓存其他节点，缓存的数组过长，对内存的消耗较大。</p>
<p>说了这么多缓存，这个缓存究竟是什么结构呢，这个缓存是如何被赋值的呢？我们先给出这个缓存的结构，然后在分析freeArray中分析缓存的赋值。</p>
<p><img src="http://p0.qhimg.com/t016e0b7bd024302aad.png" alt=""></p>
<p>以上就是缓存的结构，sBaseCache和sTwiceBaseCache指向的节点称为缓存节点，sBaseCache和sTwiceBaseCache指向的是最新的缓存节点，这样的缓存节点最多有CACHE_SIZE = 10个。每个缓存节点都是一个Object类型的数组，index = 0的元素指向下一个缓存节点，index = 1的元素指向缓存的mHashes的数组。</p>
<p>接下来看下在释放数组的时候，freeArray函数是如何给缓存赋值的</p>
<pre><code>private static void freeArrays(final int[] hashes, final Object[] array, final int size) {
    if (hashes.length == (BASE_SIZE * 2)) {
        synchronized (ArraySet.class) {
            if (sTwiceBaseCacheSize &lt; CACHE_SIZE) {
                array[0] = sTwiceBaseCache;
                array[1] = hashes;
                for (int i = size - 1; i &gt;= 2; i--) {
                    array[i] = null;
                }
                sTwiceBaseCache = array;
                sTwiceBaseCacheSize++;
                if (DEBUG) {
                    Log.d(TAG, &quot;Storing 2x cache &quot; + array + &quot; now have &quot; + sTwiceBaseCacheSize
                            + &quot; entries&quot;);
                }
            }
        }
    } else if (hashes.length == BASE_SIZE) {
        synchronized (ArraySet.class) {
            if (sBaseCacheSize &lt; CACHE_SIZE) {
                array[0] = sBaseCache;
                array[1] = hashes;
                for (int i = size - 1; i &gt;= 2; i--) {
                    array[i] = null;
                }
                sBaseCache = array;
                sBaseCacheSize++;
                if (DEBUG) {
                    Log.d(TAG, &quot;Storing 1x cache &quot; + array + &quot; now have &quot;
                            + sBaseCacheSize + &quot; entries&quot;);
                }
            }
        }
    }
}</code></pre><p>上面的代码看着很多，逻辑理解起来相对比较简单的，在释放数组的size为4或者8的时候，会首先判断缓存节点的数量是否已经超过CACHE_SIZE，如果没有超过，则将待释放的array作为一个缓存节点，array[0]指向目前最新的节点，array[1]指向待释放的hashes数组，然后调整sBaseCache / sTwiceBaseCache指向array。这就是freeArray添加缓存节点或者说设置缓存的流程。</p>
<p>再回顾下前面的allocArray, 如果从最新的缓存节点中给mHashes和mArray赋值，sBaseCache / sTwiceBaseCache调整自己的指向，指向上一个缓存节点。</p>
<p><strong>在添加缓存节点的时候，有这样的逻辑一直在引起我的关注</strong></p>
<pre><code>for (int i = size - 1; i &gt;= 2; i--) {
    array[i] = null;
}</code></pre><p>这段逻辑如果仔细分析，可以发现Google程序员考虑的真的很周全。我们在freeArray的时候，函数中传递的array是数组，这个数组指向的是Object[]类型的mArray，也就是说函数参数中的array和mArray指向的是同一块内存区域，array中每一个元素和mArray中每个元素引用同样的内存区域。如果没有array[i] = null这一步逻辑，每一个缓存节点从2号为元素开始，都会引用mArray对应节点指向的内存区域。</p>
<p>猜测可能会产生两个后果：</p>
<ul>
<li>由于数组mArray指向的内存区域存在过多的引用，其他程序可能会使用这些引用修改缓存，引起缓存异常</li>
<li>虚拟机中普遍采用可达性分析的方式计算内存是否可以被回收，在判断时，会沿着GC Root搜索，如果对象在以GC Root为根的链上，则对象不能被回收。如果没有array[i] = null，则随着缓存的增加，mArray指向的对象增加大量的引用，可能会影响虚拟机的内存回收</li>
</ul>
<p><strong>补充一下</strong><br>虚拟机中使用可达性分析的方式来判断对象所占用的空间是否需要回收。使用可达性分析的时候，虚拟机会从GC Root开始往下搜索，搜索的过程中，会形成一条引用链，如果某个对象在引用链上，则此对象还在存活不能被回收。可以作为GC Root的对象包括下面几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常亮引用的属性</li>
<li>本地方法栈中应用的对象。</li>
</ul>
<p><strong>以上有关虚拟机的内容，可参考《深入理解Java虚拟机》第二版，3.2.2节相关内容。此部分的分析没有经过验证，大家有验证方式可以回复我一下。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据Google官方的说明，ArraySet的设计是为了更加有效的利用内存，它的对比目标是HashSet，HashSet的实现底层是HashMap，故ArraySet实际上就是和HashMap进行对比。既然说ArraySet可以更加有效利用内存，有效在那些方面呢？接下来就对比下优势和劣势。</p>
<p><strong>优势：</strong></p>
<ul>
<li>ArraySet使用更少的存储单元存储元素<br>ArraySet使用int类型的数组存储hash，使用Object类型数组存储元素，相较于HashMap使用Node存储节点，ArraySet存储一个元素占用的内存更小。</li>
<li>ArraySet在扩容时容量变化更小<br>HashMap在扩容的时候，往往会对原来的容量扩大一倍，而ArraySet在元素超过8之后，只会增加元素个数的1/2，在扩容过程中更省内存空间。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>存储大量元素（超过1000）时比较耗时<br>相较于HashMap使用hash算法直接找到数组下标，然后从该下表的元素往后搜索，ArraySet在查找元素时需要进行二分查找，如果数组元素数量过多(超过1000)，可能比较耗时。</li>
<li>在扩容和缩容时可能会频繁移动元素<br>ArraySet在扩容和缩容时需要移动元素，且扩容时容量变化比HashMap小，扩容和缩容的频率可能更高，元素数量过多时，元素的移动可能会对性能产生影响。</li>
</ul>
<p>Google给出了提示，如果元素的数量少于1000，性能最多降低50%。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>对程序员来说，Read The Fucking Source Code才能真正了解其中的原理，文章以我的视角分析了ArraySet，可能有些分析并不能满足需求，建议各位去Read The Fucking Source Code，同时也帮我检查看有没有问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-arraymap%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-arraymap%E5%88%86%E6%9E%90/" itemprop="url">Android ArrayMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T00:11:21+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayMap-分析"><a href="#ArrayMap-分析" class="headerlink" title="ArrayMap 分析"></a>ArrayMap 分析</h1><p> ArraySet 使用数组保存数据，提高了内存的使用效率，在数据量不超过1000时，相较于 HashSet，效率最多不会降低50%，具体分析可参考<a href="https://blog.csdn.net/rockstore/article/details/83055565" target="_blank" rel="noopener">ArraySet 添加和删除元素分析</a>，本节来分析下 ArrayMap ，谷歌指出ArrayMap 的设计也是为了更加高效地使用内存，在数据量不超过1000时，效率最多不会降低50%。阅读源码可以发现， ArrayMap 和 ArraySet 在实现上保持了统一，主要的不同是元素的存储方式。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><strong>继承结构</strong></h2><p><img src="http://p0.qhimg.com/t01cedf02ac30d3ccce.png" alt=""></p>
<p>可以看到，ArrayMap 的继承结构比较简单，只是实现了Map接口。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>可以回忆一下 ArraySet 的存储结构：一个 int 类型的数组 mHashes 存储 hash 值，一个 object 类型的数组mArray 存储内容，这两个数组的下标一一对应。</p>
<p>ArrayMap 的存储结构猜想应该和 ArraySet 不一样，因为 ArrayMap 不仅仅需要存储 value，还需要存储 key，Google 的大神们是怎样解决这个问题的呢？</p>
<p>Google的大神们还是使用了和 ArraySet 一样的数据结构，在存储key和value时设计了一个非常巧妙的方法。</p>
<p><img src="http://p0.qhimg.com/t012e5a57945ea73d56.png" alt=""></p>
<p>如上图所示，mHashes 中存储了 key 的hash值，key 在 mHashes 的下标为 index ，在 mArray 中， mArray[index&lt;&lt;1] 存储key ， mArray[index&lt;&lt;1 + 1] 存储 value。故 mArray 的长度是 mHashes 的2倍。这样的设计使的 ArraySet 和 ArrayMap 在存储结构上保持了统一。</p>
<h1 id="添加和删除"><a href="#添加和删除" class="headerlink" title="添加和删除"></a>添加和删除</h1><p> ArraySet 和 ArrayMap 在实现上保持了统一，阅读原码可以发现，他们拥有同样的缓存结构，删除和添加元素时会有相同的逻辑流程。<br>大致看下 HashMap 的存储结构</p>
<div align="center"><img src="http://p0.qhimg.com/t0164e470cfc6c407ab.png"/></div>
上图是 HashMap 的存储结构，每个链表后面的元素的数量没有达到将链表树化的数目。 HashMap 在存储k-v键值对的时候，首先根据k的hash值找到k-v存储的链表数组的下标，然后将k-v键值对存储在链表的最后。

<p> ArrayMap 使用两个一维数组分别存储k的hash值和k-v键值对。添加元素时根据k查找元素以确认元素是否已经存在，如果已经存在则直接更新，否则添加；删除元素时查找元素以确定元素是否存在，如果不存在则直接返回，否则删除元素。 ArrayMap 在添加删除元素的过程中，也会涉及到元素的移动，缓存的添加和删除，整个流程和 ArraySet 相同。但是需要注意的是， ArrayMap 在添加和删除元素的过程中，存储k-v键值对 mArray 数组需要同时修改k和v两个元素。</p>
<h1 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h1><p>经过上面的分析，可能发现了一个问题， ArrayMap 和 ArraySet 太相似了。确实是，他们在底层存储结构，缓存结构都是一样的。</p>
<p>添加和删除元素的时候，需要查找元素，添加元素时根据k查找元素以确认元素是否已经存在，如果已经存在则直接更新，否则添加；删除元素时查找元素以确定元素是否存在，如果不存在则直接返回，否则删除元素（又重复了一遍）。 ArrayMap 是否和 ArraySet 具有相同的查找过程呢。直接上源码：</p>
<pre><code>int indexOf(Object key, int hash) {
    final int N = mSize;

    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }

    int index = binarySearchHashes(mHashes, N, hash);

    // If the hash code wasn&apos;t found, then we have no entry for this key.
    if (index &lt; 0) {
        return index;
    }

    // If the key at the returned index matches, that&apos;s what we want.
    if (key.equals(mArray[index&lt;&lt;1])) {
        return index;
    }

    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == hash; end++) {
        if (key.equals(mArray[end &lt;&lt; 1])) return end;
    }

    // Search for a matching key before the index.
    for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == hash; i--) {
        if (key.equals(mArray[i &lt;&lt; 1])) return i;
    }

    // Key not found -- return negative value indicating where a
    // new entry for this key should go.  We use the end of the
    // hash chain to reduce the number of array entries that will
    // need to be copied when inserting.
    return ~end;
}</code></pre><p>​<br>​    private static int binarySearchHashes(int[] hashes, int N, int hash) {<br>​        try {<br>​            return ContainerHelpers.binarySearch(hashes, N, hash);<br>​        } catch (ArrayIndexOutOfBoundsException e) {<br>​            if (CONCURRENT_MODIFICATION_EXCEPTIONS) {<br>​                throw new ConcurrentModificationException();<br>​            } else {<br>​                throw e; // the cache is poisoned at this point, there’s not much we can do<br>​            }<br>​        }<br>​    }<br>以上为 indexOf 函数和 binarySearchHashes 函数的实现。通过对比源码，可以发现， ArrayMap 和 ArraySet 使用了相同的二分查找逻辑，可以肯定的，和 ArraySet 一样， ArrayMap 在存储hash值时是有序的。具体的查找过程的分析可以参考<a href="https://blog.csdn.net/rockstore/article/details/83055565" target="_blank" rel="noopener">ArraySet 添加和删除元素分析</a>。</p>
<h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>上面的分析容易让人产生一种感觉— ArraySet 和 ArrayMap 的实现完全相同。这是一种误解， ArraySet 和 ArrayMap 在实现的逻辑流程是相同的，但在细节处理上还是有不同。添加删除元素的过程中，不同点主要体现在在添加和删除元素的过程中，如果有其他操作改变了 ArrayMap 存储的内容的数量，则会抛出 ConcurrentModificationException ， ArrayMap 中能改变存储容量的是以下三个方法： put 、 remove 、 clear </p>
<p>可以做一个小实验<br>首先，两个线程同时修改 ArrayMap 同一个key下的value</p>
<pre><code>ArrayMap&lt;String, String&gt; aMap = new ArrayMap&lt;&gt;();
    aMap.put(&quot;key&quot;, &quot;value&quot;);
    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot;, &quot;value&quot; + i);
            }
        }
    }).start();

    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot;, &quot;value&quot; + i);
            }
        }
    }).start();</code></pre><p>运行后可以发现，程序会一直运行，也不会报错。</p>
<p>接下来看下两个线程同时向 ArrayMap 中添加元素</p>
<pre><code>ArrayMap&lt;String, String&gt; aMap = new ArrayMap&lt;&gt;();
    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot; + i, &quot;value&quot; + i);
            }
        }
    }).start();

    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot; + i, &quot;value&quot; + i);
            }
        }
    }).start();</code></pre><p>运行程序后，会报如下异常</p>
<pre><code>Exception in thread &quot;Thread-1&quot; java.util.ConcurrentModificationException
at com.rock.collections.array.ArrayMap.put(ArrayMap.java:527)
at com.rock.collections.Client$2.run(Client.java:50)
at java.lang.Thread.run(Thread.java:748)</code></pre><p>（我将 ArrayMap 抽出来进行测试，故显示的包名是我自定义的）<br>可以发现由于两个线程同时向 aMap 中添加了元素，修改了元素的数量，系统抛出了 ConcurrentModificationException 。</p>
<p>跟踪下添加元素的过程</p>
<pre><code> @Override
public V put(K key, V value) {
    final int osize = mSize;
    ......
    index = ~index;
    if (osize &gt;= mHashes.length) {
        // 数组扩容
        final int n = osize &gt;= (BASE_SIZE*2) ? (osize+(osize&gt;&gt;1))
                : (osize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);

        ......
        allocArrays(n);

        if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
            throw new ConcurrentModificationException();
        }
        ......
    }

    ......

    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {
        if (osize != mSize || index &gt;= mHashes.length) {
            throw new ConcurrentModificationException();
        }
    }
    mHashes[index] = hash;
    mArray[index&lt;&lt;1] = key;
    mArray[(index&lt;&lt;1)+1] = value;
    mSize++;
    return null;
}</code></pre><p>源码已经很清晰了，  CONCURRENT_MODIFICATION_EXCEPTIONS = true ，在添加元素之前，使用 osize 记录 mSize ，在扩容之后和最后添加元素之前会对当前元素的数量进行判断，如果发生了变化则抛出异常。</p>
<p>再跟踪下删除元素的过程</p>
<pre><code>public V removeAt(int index) {
    final int osize = mSize;
    ......
    if (osize &lt;= 1) {
        ......
    } else {
        nsize = osize - 1;
        if (mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3) {
            ......

            if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
                throw new ConcurrentModificationException();
            }

            ......
        } else {
            ......
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V)old;
}</code></pre><p>在缩容或者记录最终元素的数量之前，如果发现元素的数量被修改过，则抛出异常。这个地方还有一个要注意的，由于是删除元素， mSize 最终是要发生变化的，但是源码中对比的 mSize 发生变化之前的值。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> ArrayMap 的设计是为了更加高效地利用内存，高效体现在一下几点</p>
<ul>
<li>ArrayMap 使用更少的存储单元存储元素<br>ArrayMap 使用 int 类型的数组存储hash，使用 Object 类型数组存储k-v键值对，相较于 HashMap 使用 Node 存储节点， ArrayMap 存储一个元素占用的内存更小。</li>
<li>ArrayMap 在扩容时容量变化更小<br>HashMap 在扩容的时候，通常会将容量扩大一倍，而 ArrayMap 在扩容的时候，如果元素个数超过8，最多扩大自己的1/2。</li>
</ul>
<p>虽然有以上有点，但是和 ArraySet 一样， ArrayMap 也存在一下劣势：</p>
<ul>
<li>存储大量（超过1000）元素时比较耗时<br>在对元素进行查找或者确定待插入元素的位置时使用二分查找，当元素较多时，耗时较长</li>
<li>频繁扩容和缩容，可能会产生大量复制操作<br>ArrayMap 在扩容和缩容时需要移动元素，且扩容时容量变化比 HashMap 小，扩容和缩容的频率可能更高，元素数量过多时，元素的移动可能会对性能产生影响。</li>
</ul>
<p>基于以上优缺点，google给出的建议是当元素数量小于1000时，建议使用 Array 代替 HashMap ，效率降低最多不会超过50%</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/06/android-framework-battery-cal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/06/android-framework-battery-cal/" itemprop="url">Android 耗电计算简析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T00:54:59+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前面已经分析了耗电统计服务 BSS 的启动流程，并简要说明了 BSS 是如何统计组件耗时的，本文将会以相机耗电统计的计算详细分析一下组件耗电的计算。</p>
<h2 id="计算原理"><a href="#计算原理" class="headerlink" title="计算原理"></a>计算原理</h2><p>在分析 BSS 启动时，提到过新建 BatteryStatsService 实例，真正实现 BatteryStatsService 功能的是 BatteryStatsImpl 实例，看下 BatteryStatsImpl 实例 的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BatteryStatsImpl</span><span class="params">(Clocks clocks, File systemDir, Handler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            PlatformIdleStateCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">            UserInfoProvider userInfoProvider)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mCameraOnTimer = <span class="keyword">new</span> StopwatchTimer(mClocks, <span class="keyword">null</span>, -<span class="number">13</span>, <span class="keyword">null</span>, mOnBatteryTimeBase);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 BatteryStatsImpl 构造函数中，新建了一个 StopwatchTimer 实例 mCameraOnTimer，先不用关注 StopwatchTimer 的原理，只需要明白 mCameraOnTimer 的主要功能是计算相机的工作时长，本文的主要目的是带着大家一起了解 Android 是如何计算组件耗时。</p>
<p>前面说过，BSS 并不主动统计耗电时长，仅仅是在有和耗电时间变化相关的事件发生时，调用 BSS 的 noteXXX 方法，进行耗电时间的统计，相机的耗电时间计算也是这样。</p>
<h3 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h3><p>当某个应用打开相机时，BSS 会调用函数 noteStartCamera</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteStartCamera</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    enforceCallingPermission();</span><br><span class="line">    <span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"begin noteStartCamera"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.noteCameraOnLocked(uid);</span><br><span class="line">        StatsLog.write_non_chained(StatsLog.CAMERA_STATE_CHANGED, uid, <span class="keyword">null</span>,</span><br><span class="line">                StatsLog.CAMERA_STATE_CHANGED__STATE__ON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"end noteStartCamera"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 BSS 里的 mStats 是 BatteryStatsImpl 实例，可以看到，接下来会调用 BatteryStatsImpl 的 noteCameraOnLocked 函数，这里的参数 uid 表示某一个应用。继续跟踪</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteCameraOnLocked</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 isolated 应用的耗电信息映射到实际的应用</span></span><br><span class="line">    uid = mapUid(uid);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = mClocks.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> uptime = mClocks.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (mCameraOnNesting++ == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 相机第一次被打开</span></span><br><span class="line">        mHistoryCur.states2 |= HistoryItem.STATE2_CAMERA_FLAG;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_HISTORY) Slog.v(TAG, <span class="string">"Camera on to: "</span></span><br><span class="line">                + Integer.toHexString(mHistoryCur.states2));</span><br><span class="line">        addHistoryRecordLocked(elapsedRealtime, uptime);</span><br><span class="line">		<span class="comment">// 相机耗电的总统计入口</span></span><br><span class="line">        mCameraOnTimer.startRunningLocked(elapsedRealtime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----------------------------分割线--------------------------------*/</span></span><br><span class="line">    <span class="comment">// 根据应用进行统计</span></span><br><span class="line">    getUidStatsLocked(uid).noteCameraTurnedOnLocked(elapsedRealtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解 mapUid 方法需要我们明白 isolated process 这一概念，isolated process 进程在运行时会在应用下新建一个特殊的进程，且 isolated process 拥有和应用不一样的 uid，为了统计应用下 isolated process 和其他进程，需要将 isolated process 进程的 uid 映射到应用的 uid，这样才能准确统计某一个应用的耗电。</p>
<p>可以看到函数 noteCameraOnLocked 里有一条注视分割线，这条分割线是我自己添加的，分割线前面是统计相机的耗电时长，分割线后面是按照应用统计相机耗电时长。</p>
<p>这里还有一个 int 类型参数 mCameraOnNesting ，这个变量的作用记录相机执行打开操作的次数，其实很好理解，如果是第一次执行打开操作，对于统计相机耗电时长来说，则需要开始执行统计，如果不是第一次执行打开，则不需要再开始统计。如果是第一次执行打开操作，则需要将此次打开操作添加到历史记录中，并执行 mCameraOnTimer.startRunningLocked 开始进行时间计算。</p>
<p>执行完相机耗电时长统计后，接下来就是统计每个应用使用相机的时长。先看下 getUidStatsLocked 这个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Uid <span class="title">getUidStatsLocked</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    Uid u = mUidStats.get(uid);</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="keyword">null</span>) &#123;</span><br><span class="line">        u = <span class="keyword">new</span> Uid(<span class="keyword">this</span>, uid);</span><br><span class="line">        mUidStats.put(uid, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mUidStats 保存的是 uid -&gt; Uid 映射，uid 是 int 类型的数值，标识一个应用，Uid 记录每一个应用的耗电信息，这样一解释，getUidStatsLocked(uid).noteCameraTurnedOnLocked 其实就很好理解了，关注一下 Uid 的 noteCameraTurnedOnLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteCameraTurnedOnLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtimeMs)</span> </span>&#123;</span><br><span class="line">    createCameraTurnedOnTimerLocked().startRunningLocked(elapsedRealtimeMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续跟踪 createCameraTurnedOnTimerLocked 方法，看它究竟返回的是什么对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StopwatchTimer <span class="title">createCameraTurnedOnTimerLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraTurnedOnTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCameraTurnedOnTimer = <span class="keyword">new</span> StopwatchTimer(mBsi.mClocks, Uid.<span class="keyword">this</span>, CAMERA_TURNED_ON,</span><br><span class="line">                mBsi.mCameraTurnedOnTimers, mBsi.mOnBatteryTimeBase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCameraTurnedOnTimer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现， Uid 内部也是用的 StopwatchTimer 实例记录相机的耗电时长。</p>
<p>到这里，我们应该就有一个大致的印象了，BSS 使用 StopwatchTimer 记录相机的时长，BatteryStatsImpl 的 mCameraOnTimer 用于记录相机的总时长， Uid 内部的 mCameraTurnedOnTimer 用于记录每个应用的相机耗电时长。突然感觉一下子豁然开朗！！！！！</p>
<h3 id="关闭相机"><a href="#关闭相机" class="headerlink" title="关闭相机"></a>关闭相机</h3><p>有打开相机，就有关闭相机，相机关闭时，如何更新相机的耗电时长呢？相机关闭时，会调用 BSS 的 noteStopCamera 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteStopCamera</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    enforceCallingPermission();</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.noteCameraOffLocked(uid);</span><br><span class="line">        StatsLog.write_non_chained(StatsLog.CAMERA_STATE_CHANGED, uid, <span class="keyword">null</span>,</span><br><span class="line">                StatsLog.CAMERA_STATE_CHANGED__STATE__OFF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 uid 是应用的 uid。接下来会调用 BatteryStatsImpl 的 noteCameraOffLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteCameraOffLocked</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOnNesting == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uid = mapUid(uid);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = mClocks.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> uptime = mClocks.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (--mCameraOnNesting == <span class="number">0</span>) &#123;</span><br><span class="line">        mHistoryCur.states2 &amp;= ~HistoryItem.STATE2_CAMERA_FLAG;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_HISTORY) Slog.v(TAG, <span class="string">"Camera off to: "</span></span><br><span class="line">                + Integer.toHexString(mHistoryCur.states2));</span><br><span class="line">        addHistoryRecordLocked(elapsedRealtime, uptime);</span><br><span class="line">        mCameraOnTimer.stopRunningLocked(elapsedRealtime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----------------------------分割线--------------------------------*/</span></span><br><span class="line">    getUidStatsLocked(uid).noteCameraTurnedOffLocked(elapsedRealtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCameraOnNesting 的作用可以参考在打开相机时的介绍。mCameraOnNesting == 0 表示相机已经关闭，故直接返回，接下来会通过 –mCameraOnNesting == 0 来判断此次关闭操作后，是否还有应用在使用相机，如果没有，则会保存此次记录，并停止计算相机耗电时长。这里也有一条分割线，分割线的含义和打开相机时的解释一致。后面的内容会在重置相机中进行分析。</p>
<h3 id="重置相机"><a href="#重置相机" class="headerlink" title="重置相机"></a>重置相机</h3><p>为什么会有重置相机这一操作呢，其实很好理解，有这样的场景，多个应用都在使用相机，用户通过任务栏一次性将所有应用都杀死，那么所有应用都需要停止相机耗时统计。<br>和打开关闭相机一样，执行重置相机操作时，会调用 BSS 的 noteResetCamera 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteResetCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    enforceCallingPermission();</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.noteResetCameraLocked();</span><br><span class="line">        StatsLog.write_non_chained(StatsLog.CAMERA_STATE_CHANGED, -<span class="number">1</span>, <span class="keyword">null</span>,</span><br><span class="line">                StatsLog.CAMERA_STATE_CHANGED__STATE__RESET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来会调用 BatteryStatsImpl 的 noteResetCameraLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteResetCameraLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOnNesting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = mClocks.elapsedRealtime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> uptime = mClocks.uptimeMillis();</span><br><span class="line">        mCameraOnNesting = <span class="number">0</span>;</span><br><span class="line">        mHistoryCur.states2 &amp;= ~HistoryItem.STATE2_CAMERA_FLAG;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_HISTORY) Slog.v(TAG, <span class="string">"Camera off to: "</span></span><br><span class="line">                + Integer.toHexString(mHistoryCur.states2));</span><br><span class="line">        addHistoryRecordLocked(elapsedRealtime, uptime);</span><br><span class="line">        mCameraOnTimer.stopAllRunningLocked(elapsedRealtime);</span><br><span class="line">        <span class="comment">/*-----------------------------分割线--------------------------------*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mUidStats.size(); i++) &#123;</span><br><span class="line">            BatteryStatsImpl.Uid uid = mUidStats.valueAt(i);</span><br><span class="line">            uid.noteResetCameraLocked(elapsedRealtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCameraOnNesting &gt; 0 表示相机处于被打开的状态，重置操作直接将 mCameraOnNesting 设置为 0，然后保存此次记录，并停止相机耗时统计。这里使用的是 stopAllRunningLocked 函数，和前面的 stopRunningLocked 有什么区别呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopAllRunningLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtimeMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNesting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mNesting = <span class="number">1</span>;</span><br><span class="line">        stopRunningLocked(elapsedRealtimeMs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stopAllRunningLocked 最终也是调用 stopRunningLocked 方法，<br>mNesting 是 StopwatchTimer 内部的 int 类型参数，和 mCameraOnNesting 是相同的含义，不同的是 mCameraOnNesting 针对的相机这一组件， mNesting 针对的所有使用 StopwatchTimer 的实例。可能有一个疑问，执行 reset 操作时，mCameraOnNesting 被设置为 0，为什么执行 stopAllRunningLocked 后 mNesting 被设置为 1 呢？其实也很好理解，可以参考关闭相机时的分析，如果将 mNesting 设置为 0， 这stopRunningLocked 会直接返回，所以这里为了防止 stopRunningLocked 内部逻辑无法执行，就先将 mNesting 设置为 1 了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了相机计算耗电时长的逻辑，目的是让大家熟悉 BSS 是如何计算组件耗电时长的，这里要注意的时，进行耗电时长统计时，会按照组件和应用区分，比如对于本文提到的相机耗电时长，BSS 会记录相机耗电的总时长，也会按照应用统计每个应用使用相机的时长，这种模式会贯穿 BSS。至于本文中的 startXXX 和 stopXXX 方法，会在下篇分析 BSS 中的 Timer 体系中进行分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/go/page/2/">2</a><a class="page-number" href="/go/page/3/">3</a><a class="extend next" rel="next" href="/go/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">rockstore</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/go/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">30</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/go/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/go/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rockstore</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/go/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/go/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/go/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/go/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
