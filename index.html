<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/go/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/go/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/go/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/go/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/go/images/favicon-32x32-next.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/go/images/favicon-16x16-next.ico?v=5.1.4">


  <link rel="mask-icon" href="/go/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Rock">
<meta property="og:url" content="https://rockstore.github.io/go/index.html">
<meta property="og:site_name" content="Rock">
<meta property="article:author" content="rockstore">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/go/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rockstore.github.io/go/"/>





  <title>Rock</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/go/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/go/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/go/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/go/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-summary/" itemprop="url">Android 容器总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T21:10:55+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于其他设备，移动设备有自己的特点，内存小是一个很突出的问题，Google针对android设备的这一特点，开发了一套容器框架，目的就是为了更加高效地利用内存。接下来就对这些容器进行一下总结。</p>
<h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/android_container.png" alt=""><br>以上是android中容器的实现继承结构，简单梳理一下：</p>
<ul>
<li>ArraySet 实现了 Set 和 Collections 接口，在api 23中添加</li>
<li>ArrayMap 实现了 Map 接口，在api 19中添加</li>
<li>SparseArray ， SparseIntArray ， SparseBooleanArray 实现了 Cloneable 接口，在api 1中添加</li>
<li>SparseLong 实现了 Cloneable 接口，在api 18中添加</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>从功能上划分，可以将以上容器划分为两类：</p>
<ul>
<li><p>存储元素<br> ArraySet 优化了 HashSet 对元素的存储</p>
</li>
<li><p>存储键值对</p>
<p>相较于 HashMap ，具体的优化方向如下：</p>
<p> ArrayMap 优化了 HashMap 存储 Object –&gt; Object 的键值存储；<br> SparseArray 优化了 int –&gt; Object 的键值存储；<br> SparseIntArray 优化了 int –&gt; int 的键值存储；<br> SparseBooleanArray 优化了  int –&gt; boolean 的键值存储；<br> SparseLongArray 优化了  int –&gt; long 的键值存储</p>
</li>
</ul>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>从组织结构可以看出，可以将这些容器分为3类： ArraySet , ArrayMap 和剩余的容器。通过前面的分析可以知道， ArraySet 和 ArrayMap 使用的相同的优化方式， SparseArray 在进行优化的时候使用 gc 垃圾回收策略，故从优化方法上进行分类的话可以分一下三类：</p>
<ul>
<li>ArraySet ,  ArrayMap<br>使用数组 mKeys 存储 key 的hash值，hash 值在 mKeys 的位置为 index，并将 value 存储到 mValues 数组对应下标的位置（ ArrayMap 中 key 和 value 分别在 mValues 的 index * 2 和 index * 2 + 1 的位置）。查找或者修改元素时，使用二分查找在 mKeys 中找到元素在 mValues 的下标，然后进行修改或者返回。</li>
<li>SparseArray<br>使用 int 类型的 mKeys 数组存储 int 类型的键，下标为 index ，将 Object 类型的 value 存储在在 Object 类型的数组 mValues 的 index 位置，在查找和修改时，使用二分查找在 mKeys 中找到元素在 Values 的下标，然后进行修改或者返回。在删除 value 时， SparseArray 并不直接进行数组元素的移动，而是将待删除的 value 标记为DELETED 状态，在 gc 的过程中将所有非 DELETED 状态的元素移动到数组的最前面，从而减少二分查找的时间。</li>
<li>SparseIntArray,  SparseLongArray ,  SparseBooleanArray<br>这3个容器可以理解成专用容器，使用 int 类型数组和对应类型的数组；使用二分查找快速查找元素，然后进行删除，修改，添加操作。</li>
</ul>
<h2 id="优化共同点与差异"><a href="#优化共同点与差异" class="headerlink" title="优化共同点与差异"></a>优化共同点与差异</h2><p>虽然这些容器存储的元素类型不同，但是通过分析可以发现他们在内存优化中的共同点，接下来就分析下这些容器在优化上存在的共同点和差异。</p>
<p> <strong>共同点</strong></p>
<ul>
<li><p>数据结构<br><img src="https://raw.githubusercontent.com/rockstore/images/master/data_h_v2.png" alt=""><br>这里的数据结构是指容器的底层存储结构，虽然在 ArrayMap 中 mValues 的长度是 mKeys 的 2 倍，但也仅仅是数组长度上的差异，底层存储使用的思想仍然是一样的；int 类型的数组 mKeys 里的元素时按照升序进行排列的。相较于 HashMap 使用 Node 结构存储，这样的存储方式使用更小的存储空间存储 k-v ，同时避免了原始数据类型的自动装箱。</p>
</li>
<li><p>查找方法<br>在组织结构中列出的容器，他们在进行元素查找时，都会先在 mKeys 数组中利用二分查找找到元素的下标 index ，然后使用 index 到 mValues 数组中对 value 进行操作。</p>
</li>
<li><p>获取带插入下标<br>在进行元素插入时，会首先使用二分查找在 mKeys 数组中查找元素的下标，如果元素不存在，则二分查找会返回元素待插入位置的取反。</p>
<br>

</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>对 key的处理<br>ArraySet,  ArrayMap 底层实现时，会计算待插入元素的 hash 值，根据 hash 值，在 mKeys 找到待插入位置；SparseArray 和 SparseXXXArray 存储的时候直接使用 key 值，不会进行 hash 计算。</li>
<li>对 null 的处理<br>ArraySet 和 ArrayMap 允许插入 key 为 null 的元素， key 的 hash 值为 0； SparseArray 和 SparseXXXArray 存储的时由于直接使用int类型的数据作为key ，故不存在 key 为 null 的情况。</li>
<li>缓存<br>为了避免频繁的内存回收，ArraySet 和 ArrayMap 添加了缓存结构，SparseArray 和 SparseXXXArray 没有缓存</li>
<li>扩容规则<br>ArraySet 和 ArrayMap 在进行扩容的时，容量的变化规则为 4, 8 , size * 2 / 3 ， SparseArray 和 SparseXXXArray 使用 ArrayUtils.newUnpaddedArray 建立新的数据，将原来的数据拷贝到新数组中。</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>虽然这些容器在Android设备上可以更高效地利用内存，但是还是存在使用使用限制。</p>
<ul>
<li>兼容性<br>在组织结构中，可以看到，并不是所有的容器都是从api 1就开始提供的，在使用具体的容器时，需要考虑应用的兼容。</li>
<li>对性能的影响<br>虽然 ArrayMap 在删除时不直接使用移动元素的方式删除元素，但是在获取数组元素等操作中还是</li>
<li>对数量的限制<br>在对元素进行查找时会使用二分查找，元素数量较大（超过1000）时，查找效率会降低，相较于<code>HashMap</code>只要数量不超过1000，效率最多不会下降50%。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面说了很多，其实android容器优化的根本思想就是使用 int 到其他类型的映射，使用数组保存着两个映射，用以优化 HashMap 对 k-v 的存储。这种优化适用于元素数量较少（少于1000）的情况。</p>
<p>以上所写是我的个人总结，可能有总结不到位的情况，有任何问题感谢大家及时向我反馈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-sparseintarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-sparseintarray/" itemprop="url">Android SparseIntArray</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T21:07:03+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  SparseArray  优化了  int  到  Object  键值对的存储，  SparseIntArray  优化了  int  到  int  键值对的存储。android中在键值对存储上的优化主要做了一下几种类型的优化:</p>
<ul>
<li>int   –&gt;   Object  (SparseArray)</li>
<li>int   –&gt;   int  (SparseIntArray)</li>
<li>int   –&gt;   boolean  (SparseBooleanArray)</li>
<li>int   –&gt;   long  (SparseLongArray)</li>
<li>int   –&gt;   Set  (SparseSetArray)</li>
</ul>
<p>SparseSetArray 目前在sdk中还处于hide状态，故在做总结的时候就不分析它了。</p>
<p>之前已经分析过  SparseArray  ，本文就分析下  SparseIntArray  的实现，并在最后总结下这几种键值对在实现上的共同点。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/SparseIntArray_h.png" alt=""></p>
<br>
以上为  SparseIntArray  的继承体系。  SparseIntArray  只实现了  Cloneable  接口，结构比较简单。其实阅读源码可以发现，  SparseArray  ，  SparseIntArray  ，  SparseBooleanArray  ，  SparseLongArray  都只实现了  Cloneable  接口。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/SparseIntArray_s.png" alt=""></p>
<br>
以上为  SparseIntArray  的存储结构，mKeys存储的是int类型的键，mValues存储的是int类型的value。

<h2 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h2><pre><code>// 查找键key在mKeys的下标
public int indexOfKey(int key) {
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}

// 查找value在mValues的下标
public int indexOfValue(int value) {
    for (int i = 0; i &lt; mSize; i++)
        if (mValues[i] == value)
            return i;
    return -1;
}</code></pre><p>元素的查找分键查找和值查找，键查找使用二分查找，值查找直接使用循环遍历。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><pre><code>public void put(int key, int value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        mValues[i] = value;
    } else {
        i = ~i;

        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}</code></pre><p>添加元素首先使用二分查找找到key在mKeys数组的下标，也就是value在mValues数组的下标。如果   ContainerHelpers.binarySearch(mKeys, mSize, key)  在mKeys数组中没有找到key，则返回key待插入位置的下标的取反，如果找到了key，则直接更新mValues对应位置的值即可。<br>  GrowingArrayUtils.insert  函数的实现如下：</p>
<pre><code>public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize &lt;= array.length;

    if (currentSize + 1 &lt;= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    }

    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}</code></pre><p>函数的逻辑很简单，首先断言了currentSize &lt;= array.length；如果array在不需要扩大容量的情况下可以添加一个元素，则先将待插入位置index开始的元素整体后移一位，然后插入元素，否则先扩容，然后将元素拷贝到新的数组中。</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><pre><code>public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i &gt;= 0) {
        removeAt(i);
    }
}

public void removeAt(int index) {
    System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));
    System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));
    mSize--;
}</code></pre><p>删除元素主要涉及以上两个方法，  delete(int key)  根据  key  进行删除，  removeAt(int index)  删除指定下标的元素。这两个方法都是  public  ，故都可以直接使用。  delete(int key)  ，先使用二分查找，找到  key  在  mKeys  的下标，如果找到即  i &gt;= 0  ，则直接删除  mKeys  和  mValues  指定位置的元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有  SparseBooleanArray  ，  SparseLongArray  还没有分析，他们的实现规则是一样的，只是存储的数据类型的  mValues  数组是  boolean   和   long  ，接下来就对  SparseIntArray  ，  SparseBooleanArray  ，  SparseLongArray  进行下总结。</p>
<ul>
<li>他们的设计目的是优化  int  到  int  ,   boolean   ,  long  映射的存储</li>
<li>使用  int  类型的数组  mKeys  存储映射的键，使用对应类型的数组  mValues  存储值</li>
<li>int  类型的键在存储上是有顺序的</li>
<li>在查找值时，先使用二分查找，在  mKeys  中查找值在  mValues  中的下标，然后返回值</li>
</ul>
<p>以上三种数据类型和  SparseArray  最大的区别在于  SparseArray  在删除元素的时候会将元素设置为  DELETED  ，后续会有  gc  的过程。</p>
<p>相对于使用HashMap，这样的设计的优势和缺点：</p>
<p><strong>优势：</strong></p>
<ul>
<li>避免  int  类型的键自动装箱</li>
<li>相较于  HashMap  使用  Node  ，这样的设计使用更小的存储单元即可存储  key  到  value  的映射</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在进行元素查找时使用二分查找，元素较多（谷歌给出的数字是大于1000）时，查找效率较低</li>
<li>在进行元素的添加和删除时，可能会频繁进行元素的移动，运行效率可能会降低</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-sparearray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-sparearray/" itemprop="url">Android SpareArray</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T20:55:59+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> SparseArray 和其他的Android容器类一样，都是为了更加有效地利用内存，说直白点，就是为了节省内存。 SparseArray 和 ArrayMap 一样，都是为了更高效的保存int值到非原始类型的映射，用了同样的数据结构，但是为了提高效率， SparseArray 也做了自己的优化。接下来就分析一下 SparseArray 的存储，添加和删除元素。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p><img src="http://p0.qhimg.com/t01ebe97cef584833f4.png" alt=""></p>
<br>
上图表明， SparseArray 并没有像 ArrayMap 一样实现 Map 接口，仅仅实现了 Cloneable 接口。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="http://p0.qhimg.com/t0135547fb1e591cb0e.png" alt=""></p>
<br>
存储结构和 ArraySet 以及 ArrayMap 一脉相承，都使用int数组存储key值，使用Object数组存储对象。不同点在于 mKeys 数组中存储的是添加元素的key值本身，没有进行hash值得计算。


<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><pre><code>public void put(int key, E value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        mValues[i] = value;
    } else {
        i = ~i;

        if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }

        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {
            gc();

            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }

        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}</code></pre><p> put 方法首先使用二分查找在 mKeys 中查找 key ，如果找到，则直接更新对应下标的 value 。如果未找到， binarySearch 方法返回待插入的下标的取反，故 i = ~i 。如果待插入的位置的元素已经被标记为 DELETED ，则直接更新并返回。如果需要执行 gc 函数，且需要扩大数组的容量（ mSize &gt;= mKeys.lengt ），则先执行 gc 函数。由于执行 gc 函数之后元素会发生移动，故重新计算待插入位置，最后执行元素的插入。插入函数分为插入 key 和插入 value 。 GrowingArrayUtils.insert 的源码如下：</p>
<pre><code>public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize &lt;= array.length;

    if (currentSize + 1 &lt;= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    }

    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}</code></pre><p>函数的逻辑很简单，首先断言了 currentSize &lt;= array.length ；如果 array 在不需要扩大容量的情况下可以添加一个元素，则先将待插入位置 index 开始的元素整体后移一位，然后插入元素，否则先扩容，然后将元素拷贝到新的数组中。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>为什么删除的时候我没有使用一个具体的函数呢，是因为 SparseArray 的删除有两种：根据key删除对象，删除指定位置的对象。</p>
<h3 id="根据key删除对象"><a href="#根据key删除对象" class="headerlink" title="根据key删除对象"></a>根据key删除对象</h3><pre><code>public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i &gt;= 0) {
        if (mValues[i] != DELETED) {
            mValues[i] = DELETED;
            mGarbage = true;
        }
    }
}</code></pre><p> ContainerHelpers.binarySearch 函数在 ArraySet 和 ArrayMap 的元素查找中都出现过，作用是使用二分查找，在 mKeys 中找到 key 的位置，如果 key 存在，则返回 key 在 mKeys 中的下标，否则返回试图将 key 插入到 mKeys 中的位置的取反。找到待删除元素的下标后， SparseArray 并没有像 ArraySet 和 ArrayMap 一样去删除元素，只是将待删除元素标记为 DELETED ，然后将 mGarbage 设置为 true 。 DELETED 实际上就是一个对象，具体申明为：  Object DELETED =  new Object() ， SparseArray 有 gc 的过程，后面会分析这个 gc 的过程。</p>
<h3 id="删除执行位置的对象"><a href="#删除执行位置的对象" class="headerlink" title="删除执行位置的对象"></a>删除执行位置的对象</h3><pre><code>public void removeAt(int index) {
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}</code></pre><p>删除指定位置元素的逻辑比较简单，判断待删除位置的元素是否已经被标记为 DELETED ，如果没有被标记，则标记指定位置的元素，并将 mGarbage 设置为 true 。</p>
<p>元素在被删除之后，都会将标志 mGarbage 设置为 true ，这是执行 gc 的必要条件。</p>
<h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>说到gc，给我的第一感觉应该是什么高深的c/c++源码，其实不是，贴上 gc 的源码</p>
<pre><code>private void gc() {
    int n = mSize;
    int o = 0;
    int[] keys = mKeys;
    Object[] values = mValues;

    for (int i = 0; i &lt; n; i++) {
        Object val = values[i];

        if (val != DELETED) {
            if (i != o) {
                keys[o] = keys[i];
                values[o] = val;
                values[i] = null;
            }
            o++;
        }
    }

    mGarbage = false;
    mSize = o;
}</code></pre><p>好吧，开始被自己给吓着了， gc 函数没有那么复杂。 gc 函数实际上就是将 mValues 数组中还未标记为 DELETED 的元素以及对应下标的 mKeys 数组中的元素移动到数组的前面，保证数组在0到 mSize 之间的元素都是未被标记为 DELETED ，经过 gc 之后，数据的位置可能会发生移动。</p>
<p>在元素被删除后，标志 mGarbage 设置为 true ，表示可以执行 gc 函数了。那么 gc 函数会在什么位置执行呢？<br>分析 SparseArray 源码可以发现，如果 mGarbage 设置为 true ，在以下函数调用中 gc 函数会执行：</p>
<p> put , append ，  size , keyAt , valueAt , setValueAt , indexOfKey , indexOfValue , indexOfValueByValue 。</p>
<p>将以上函数总结一下可以归纳为三类：</p>
<ul>
<li>向SparseArray添加元素</li>
<li>修改SparseArray的mValues数组</li>
<li>获取SparseArray的属性</li>
</ul>
<p>通过执行 gc 将未被标记为 DELETED 的元素前移，在进行元素查找时可以减少需要查找的元素的数量，减少查找的时间，在添加元素的时候也可以更加快速的找到待插入点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SparseArray 主要是为了优化 int 值到 Object 映射的存储，提高内存的使用效率。相较于 HashMap ，在存储上的优化如下：</p>
<ul>
<li>使用int和Object类型的数组分别存储key和value，相较于 HashMap 使用Node， SparseArray 在存储单个key-value时更节省内存</li>
<li>SparseArray 使用int数组存储int类型的key，避免了int到Integer的自动装箱机制</li>
</ul>
<p>虽然在存储int到Object映射时的内存使用效率更高，由于使用数组存储数组，在添加或者删除元素时需要进行二分查找，元素较多（超过1000）是效率较低，谷歌给出的建议是数据量不要超过1000，这种情况下，相较于 HashMap ,效率降低不会超过50%</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-arrayset%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-arrayset%E5%88%86%E6%9E%90/" itemprop="url">Android ArraySet</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T00:32:44+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一直在使用Set相关类进行运行时数据存储，之前也有知道 Android 为了更加有效的利用内存，在23的时候设计了自己的一套运行时的集合类。本文的以我的视角分析 ArraySet 的 add 和 remove 过程，并做了简单的对比分析。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p><img src="http://p0.qhimg.com/t01ebc5f5688c918e20.png" alt=""></p>
<br>
ArraySet 实现了 Set 和 Collections 接口，故 add 和 remove 接口的使用方式相同，就不在对这两个接口的使用提供示例。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="http://p0.qhimg.com/t01dbd3b0687f23f126.png" alt=""></p>
<br/> 
ArraySet 在进行 add 和 remove 操作时，操作的是 int[] 类型的 mHashes 和 Object[] 类型的 mArray ，其中mHashes 保存 mArray 每个元素的 hash 值，且 mHashes 和 mArray 相同下标的元素一一对应。

<h2 id="add"><a href="#add" class="headerlink" title="add"></a>add</h2><p><img src="http://p0.qhimg.com/t010b82f86211d13d60.png" alt=""></p>
<br/>
以上为add的流程，可以概括为以下几点：

<ul>
<li><p>判断元素是否存在，已存在则直接返回<br>indexOf 函数判断待插入元素是否存在，如果存在，则直接返回元素在 mArray 的下标，如果不存在，则返回带插入元素即将插入的位置的取反 </p>
</li>
<li><p>判断是否需要对存储元素的数组进行扩容<br>ArraySet 使用 mSize 记录当前元素的数量，如果 mSize &gt;= mHashes.length (元素的数量大于等于数组的长度)，则需要对数组进行扩容，则计算扩容后的容量，扩容的规则会后续说明。扩容过程中还会涉及到的缓存也会后续说明。</p>
</li>
<li><p>根据元素插入的位置判断是否需要对数组元素进行移动<br>如果数组中不存在待插入元素，则在第一步中会计算出带插入元素待插入位置的取反，此不会再次取反，获得真实待插入的位置 index 。如果 index &lt; mSize (插入位置不在数组末尾)，则需要将 index+1 只 mSize - 1 位置的元素后移一位。</p>
</li>
<li><p>插入元素<br>将待插入元素本身和其hash值分别插入到 mArray 和 mHashes 的 index 位置</p>
</li>
</ul>
<h2 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h2><p><img src="http://p0.qhimg.com/t013c2e659cc85b9bd9.png" alt=""></p>
<br>
remove得流程可以概括如下：

<ul>
<li>判断元素是否存在，如果不存在则直接返回</li>
<li>如果当前元素小于等于1，则将mHashes和mArray置空，否则会进行扩容判断判断</li>
<li>如果需要进行扩容，则计算扩容后的容量，扩容过程中涉及到的缓存处理会后续说明，扩容完成后会将原来数组中的元素copy到新数组中</li>
<li>扩容完成后，执行将index至mSize-1的元素前移一位，删除待删除元素</li>
</ul>
<h2 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf"></a>indexOf</h2><p>indexOf函数功能是查找元素在mArray中的位置，在add和remove操作过程中都涉及到查找元素的过程。看下这个函数的实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private int indexOf(Object key, int hash) &#123;</span><br><span class="line">    final int N &#x3D; mSize;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Important fast case: if nothing is in here, nothing to look for.</span><br><span class="line">    if (N &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        return ~0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int index &#x3D; ContainerHelpers.binarySearch(mHashes, N, hash);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the hash code wasn&#39;t found, then we have no entry for this key.</span><br><span class="line">    if (index &lt; 0) &#123;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; If the key at the returned index matches, that&#39;s what we want.</span><br><span class="line">    if (key.equals(mArray[index])) &#123;</span><br><span class="line">        return index;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F; Search for a matching key after the index.</span><br><span class="line">    int end;</span><br><span class="line">    for (end &#x3D; index + 1; end &lt; N &amp;&amp; mHashes[end] &#x3D;&#x3D; hash; end++) &#123;</span><br><span class="line">        if (key.equals(mArray[end])) return end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Search for a matching key before the index.</span><br><span class="line">    for (int i &#x3D; index - 1; i &gt;&#x3D; 0 &amp;&amp; mHashes[i] &#x3D;&#x3D; hash; i--) &#123;</span><br><span class="line">        if (key.equals(mArray[i])) return i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Key not found -- return negative value indicating where a</span><br><span class="line">    &#x2F;&#x2F; new entry for this key should go.  We use the end of the</span><br><span class="line">    &#x2F;&#x2F; hash chain to reduce the number of array entries that will</span><br><span class="line">    &#x2F;&#x2F; need to be copied when inserting.</span><br><span class="line">    return ~end;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexOf函数的实现比较简单，首先会判断当前元素数量是否为0，如果是0，则直接返回-1，否则使用二分查找ContainerHelpers.binarySearch(mHashes, N, hash)获取元素的位置index。ContainerHelpers.binarySearch的代码比较简单，就不分析了。如果待查找元element素和mArray[index]相同，表示元素已经找到，直接返回index。若element未找到，则使用end记录如果将element插入mArray时的位置。</p>
<p>可以发现，indexOf函数有两个作用：</p>
<ul>
<li>查找element在mArray中的位置</li>
<li>若element在mArray中不存在，则返回将element插入mArray中的位置的取反。</li>
</ul>
<h2 id="resize"><a href="#resize" class="headerlink" title="resize"></a>resize</h2><p>ArraySet中没有resize函数，这里的resize表示ArraySet在add和remove时可能会执行的扩容操作，这里的扩容可能是增加容量，也可能是缩小容量。接下来会分别分下add和remove过程中涉及到的扩容操作。</p>
<h3 id="add扩容"><a href="#add扩容" class="headerlink" title="add扩容"></a>add扩容</h3><p>add过程中，如果mSize &gt;= mHashes.length(元素的数量大于等于数组的长度)，则数组(mHashes和mArray)需要进行扩容，扩容规则如下</p>
<pre><code>private static final int BASE_SIZE = 4;

final int n = mSize &gt;= (BASE_SIZE * 2) ? (mSize + (mSize &gt;&gt; 1))
            : (mSize &gt;= BASE_SIZE ? (BASE_SIZE * 2) : BASE_SIZE);</code></pre><p>BASE_SIZE是ArraySet扩容的最小增量，已经经过Google工程师验证过，BASE_SIZE = 4时，内存的使用效率最高。根据以上的扩容规则，假设我们使用ArraySet mSet = new ArraySet()的方式新建了一个ArraySet对象，mHashes和mArray的长度大小变化如下：</p>
<p><img src="http://p0.qhimg.com/t01b06cfba9651c1e15.png" alt=""></p>
<p>上图中，mSize表示mHashes和mArray中元素的数量，length表示mHashes和mArray的长度。</p>
<h3 id="remove缩容"><a href="#remove缩容" class="headerlink" title="remove缩容"></a>remove缩容</h3><p>remove的过程中ArraySet会根据一定的规则对mHashes和mArray的大小进行缩小，缩小规则如下：</p>
<pre><code>if (mHashes.length &gt; (BASE_SIZE * 2) &amp;&amp; mSize &lt; mHashes.length / 3) {
    final int n = mSize &gt; (BASE_SIZE * 2) ? (mSize + (mSize &gt;&gt; 1)) : (BASE_SIZE * 2);
    ......
}</code></pre><p>缩容的规则比扩容稍微简单一些，数组mHashes和mArray长度是一样的，故缩容的条件可理解为：</p>
<ul>
<li>mHashes和mArray长度大于BASE_SIZE * 2</li>
<li>mHashes和mArray中元素的数量小于数组长度的1/3</li>
</ul>
<p>缩容之后数组mHashes和mArray的长度：</p>
<pre><code>n = mSize &gt; (BASE_SIZE * 2) ? (mSize + (mSize &gt;&gt; 1)) : (BASE_SIZE * 2);</code></pre><p>可以发现，缩容之后，mHashes和mArray的长度最小为BASE_SIZE * 2</p>
<h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p>在add过程中，如果需要扩容，需要走如下逻辑：</p>
<pre><code>final int[] ohashes = mHashes;
final Object[] oarray = mArray;
allocArrays(n);
......
freeArrays(ohashes, oarray, mSize);</code></pre><p>在remove过程中，如果需要缩容，则需要走如下逻辑：</p>
<pre><code>final int[] ohashes = mHashes;
final Object[] oarray = mArray;
allocArrays(n);</code></pre><p>以上两段代码中n表示计算后数组的容量。在add的扩容和remove的缩容过程中，都会调用allocArray，可以看下具体实现，代码可能比较长，但不是很复杂</p>
<pre><code>private void allocArrays(final int size) {
    if (size == (BASE_SIZE * 2)) {
        synchronized (ArraySet.class) {
            if (sTwiceBaseCache != null) {
                final Object[] array = sTwiceBaseCache;
                try {
                    mArray = array;
                    sTwiceBaseCache = (Object[]) array[0];
                    mHashes = (int[]) array[1];
                    array[0] = array[1] = null;
                    sTwiceBaseCacheSize--;
                    if (DEBUG) {
                        Log.d(TAG, &quot;Retrieving 2x cache &quot; + mHashes + &quot; now have &quot;
                                + sTwiceBaseCacheSize + &quot; entries&quot;);
                }
                return;
                } catch (ClassCastException e) {
                }
                // Whoops!  Someone trampled the array (probably due to not protecting
                // their access with a lock).  Our cache is corrupt; report and give up.
                Slog.wtf(TAG, &quot;Found corrupt ArraySet cache: [0]=&quot; + array[0]
                        + &quot; [1]=&quot; + array[1]);
                sTwiceBaseCache = null;
                sTwiceBaseCacheSize = 0;
            }
        }
    } else if (size == BASE_SIZE) {
        synchronized (ArraySet.class) {
            if (sBaseCache != null) {
                final Object[] array = sBaseCache;
                try {
                    mArray = array;
                    sBaseCache = (Object[]) array[0];
                    mHashes = (int[]) array[1];
                    array[0] = array[1] = null;
                    sBaseCacheSize--;
                    if (DEBUG) {
                        Log.d(TAG, &quot;Retrieving 1x cache &quot; + mHashes + &quot; now have &quot; + sBaseCacheSize
                                + &quot; entries&quot;);
                    }
                    return;
                } catch (ClassCastException e) {
                }
                // Whoops!  Someone trampled the array (probably due to not protecting
                // their access with a lock).  Our cache is corrupt; report and give up.
                Slog.wtf(TAG, &quot;Found corrupt ArraySet cache: [0]=&quot; + array[0]
                        + &quot; [1]=&quot; + array[1]);
                sBaseCache = null;
                sBaseCacheSize = 0;
            }
        }
    }

    mHashes = new int[size];
    mArray = new Object[size];
}</code></pre><p>如果不考虑缓存部分，直接到函数的最后，可以发现，allocArray函数其实就是根据计算出来的长度，新建了mHashes和mArray数组。再看下缓存部分，Google设计了两个节点，BASE_SIZE和BASE_SIZE * 2，如果计算后数组的容量是以上两个节点，则尝试从缓存中给mHashes和mArray赋值。至于为什么不设置其他的节点，个人猜测，可能是Google认为这两个节点是数组在变化过程中会经常到达的点；也可能是认为如果缓存其他节点，缓存的数组过长，对内存的消耗较大。</p>
<p>说了这么多缓存，这个缓存究竟是什么结构呢，这个缓存是如何被赋值的呢？我们先给出这个缓存的结构，然后在分析freeArray中分析缓存的赋值。</p>
<p><img src="http://p0.qhimg.com/t016e0b7bd024302aad.png" alt=""></p>
<p>以上就是缓存的结构，sBaseCache和sTwiceBaseCache指向的节点称为缓存节点，sBaseCache和sTwiceBaseCache指向的是最新的缓存节点，这样的缓存节点最多有CACHE_SIZE = 10个。每个缓存节点都是一个Object类型的数组，index = 0的元素指向下一个缓存节点，index = 1的元素指向缓存的mHashes的数组。</p>
<p>接下来看下在释放数组的时候，freeArray函数是如何给缓存赋值的</p>
<pre><code>private static void freeArrays(final int[] hashes, final Object[] array, final int size) {
    if (hashes.length == (BASE_SIZE * 2)) {
        synchronized (ArraySet.class) {
            if (sTwiceBaseCacheSize &lt; CACHE_SIZE) {
                array[0] = sTwiceBaseCache;
                array[1] = hashes;
                for (int i = size - 1; i &gt;= 2; i--) {
                    array[i] = null;
                }
                sTwiceBaseCache = array;
                sTwiceBaseCacheSize++;
                if (DEBUG) {
                    Log.d(TAG, &quot;Storing 2x cache &quot; + array + &quot; now have &quot; + sTwiceBaseCacheSize
                            + &quot; entries&quot;);
                }
            }
        }
    } else if (hashes.length == BASE_SIZE) {
        synchronized (ArraySet.class) {
            if (sBaseCacheSize &lt; CACHE_SIZE) {
                array[0] = sBaseCache;
                array[1] = hashes;
                for (int i = size - 1; i &gt;= 2; i--) {
                    array[i] = null;
                }
                sBaseCache = array;
                sBaseCacheSize++;
                if (DEBUG) {
                    Log.d(TAG, &quot;Storing 1x cache &quot; + array + &quot; now have &quot;
                            + sBaseCacheSize + &quot; entries&quot;);
                }
            }
        }
    }
}</code></pre><p>上面的代码看着很多，逻辑理解起来相对比较简单的，在释放数组的size为4或者8的时候，会首先判断缓存节点的数量是否已经超过CACHE_SIZE，如果没有超过，则将待释放的array作为一个缓存节点，array[0]指向目前最新的节点，array[1]指向待释放的hashes数组，然后调整sBaseCache / sTwiceBaseCache指向array。这就是freeArray添加缓存节点或者说设置缓存的流程。</p>
<p>再回顾下前面的allocArray, 如果从最新的缓存节点中给mHashes和mArray赋值，sBaseCache / sTwiceBaseCache调整自己的指向，指向上一个缓存节点。</p>
<p><strong>在添加缓存节点的时候，有这样的逻辑一直在引起我的关注</strong></p>
<pre><code>for (int i = size - 1; i &gt;= 2; i--) {
    array[i] = null;
}</code></pre><p>这段逻辑如果仔细分析，可以发现Google程序员考虑的真的很周全。我们在freeArray的时候，函数中传递的array是数组，这个数组指向的是Object[]类型的mArray，也就是说函数参数中的array和mArray指向的是同一块内存区域，array中每一个元素和mArray中每个元素引用同样的内存区域。如果没有array[i] = null这一步逻辑，每一个缓存节点从2号为元素开始，都会引用mArray对应节点指向的内存区域。</p>
<p>猜测可能会产生两个后果：</p>
<ul>
<li>由于数组mArray指向的内存区域存在过多的引用，其他程序可能会使用这些引用修改缓存，引起缓存异常</li>
<li>虚拟机中普遍采用可达性分析的方式计算内存是否可以被回收，在判断时，会沿着GC Root搜索，如果对象在以GC Root为根的链上，则对象不能被回收。如果没有array[i] = null，则随着缓存的增加，mArray指向的对象增加大量的引用，可能会影响虚拟机的内存回收</li>
</ul>
<p><strong>补充一下</strong><br>虚拟机中使用可达性分析的方式来判断对象所占用的空间是否需要回收。使用可达性分析的时候，虚拟机会从GC Root开始往下搜索，搜索的过程中，会形成一条引用链，如果某个对象在引用链上，则此对象还在存活不能被回收。可以作为GC Root的对象包括下面几种：</p>
<ul>
<li>虚拟机栈中引用的对象</li>
<li>方法区中静态属性引用的对象</li>
<li>方法区中常亮引用的属性</li>
<li>本地方法栈中应用的对象。</li>
</ul>
<p><strong>以上有关虚拟机的内容，可参考《深入理解Java虚拟机》第二版，3.2.2节相关内容。此部分的分析没有经过验证，大家有验证方式可以回复我一下。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>根据Google官方的说明，ArraySet的设计是为了更加有效的利用内存，它的对比目标是HashSet，HashSet的实现底层是HashMap，故ArraySet实际上就是和HashMap进行对比。既然说ArraySet可以更加有效利用内存，有效在那些方面呢？接下来就对比下优势和劣势。</p>
<p><strong>优势：</strong></p>
<ul>
<li>ArraySet使用更少的存储单元存储元素<br>ArraySet使用int类型的数组存储hash，使用Object类型数组存储元素，相较于HashMap使用Node存储节点，ArraySet存储一个元素占用的内存更小。</li>
<li>ArraySet在扩容时容量变化更小<br>HashMap在扩容的时候，往往会对原来的容量扩大一倍，而ArraySet在元素超过8之后，只会增加元素个数的1/2，在扩容过程中更省内存空间。</li>
</ul>
<p><strong>劣势</strong></p>
<ul>
<li>存储大量元素（超过1000）时比较耗时<br>相较于HashMap使用hash算法直接找到数组下标，然后从该下表的元素往后搜索，ArraySet在查找元素时需要进行二分查找，如果数组元素数量过多(超过1000)，可能比较耗时。</li>
<li>在扩容和缩容时可能会频繁移动元素<br>ArraySet在扩容和缩容时需要移动元素，且扩容时容量变化比HashMap小，扩容和缩容的频率可能更高，元素数量过多时，元素的移动可能会对性能产生影响。</li>
</ul>
<p>Google给出了提示，如果元素的数量少于1000，性能最多降低50%。</p>
<h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><p>对程序员来说，Read The Fucking Source Code才能真正了解其中的原理，文章以我的视角分析了ArraySet，可能有些分析并不能满足需求，建议各位去Read The Fucking Source Code，同时也帮我检查看有没有问题。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-arraymap%E5%88%86%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-arraymap%E5%88%86%E6%9E%90/" itemprop="url">Android ArrayMap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T00:11:21+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ArrayMap-分析"><a href="#ArrayMap-分析" class="headerlink" title="ArrayMap 分析"></a>ArrayMap 分析</h1><p> ArraySet 使用数组保存数据，提高了内存的使用效率，在数据量不超过1000时，相较于 HashSet，效率最多不会降低50%，具体分析可参考<a href="https://blog.csdn.net/rockstore/article/details/83055565" target="_blank" rel="noopener">ArraySet 添加和删除元素分析</a>，本节来分析下 ArrayMap ，谷歌指出ArrayMap 的设计也是为了更加高效地使用内存，在数据量不超过1000时，效率最多不会降低50%。阅读源码可以发现， ArrayMap 和 ArraySet 在实现上保持了统一，主要的不同是元素的存储方式。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a><strong>继承结构</strong></h2><p><img src="http://p0.qhimg.com/t01cedf02ac30d3ccce.png" alt=""></p>
<p>可以看到，ArrayMap 的继承结构比较简单，只是实现了Map接口。</p>
<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>可以回忆一下 ArraySet 的存储结构：一个 int 类型的数组 mHashes 存储 hash 值，一个 object 类型的数组mArray 存储内容，这两个数组的下标一一对应。</p>
<p>ArrayMap 的存储结构猜想应该和 ArraySet 不一样，因为 ArrayMap 不仅仅需要存储 value，还需要存储 key，Google 的大神们是怎样解决这个问题的呢？</p>
<p>Google的大神们还是使用了和 ArraySet 一样的数据结构，在存储key和value时设计了一个非常巧妙的方法。</p>
<p><img src="http://p0.qhimg.com/t012e5a57945ea73d56.png" alt=""></p>
<p>如上图所示，mHashes 中存储了 key 的hash值，key 在 mHashes 的下标为 index ，在 mArray 中， mArray[index&lt;&lt;1] 存储key ， mArray[index&lt;&lt;1 + 1] 存储 value。故 mArray 的长度是 mHashes 的2倍。这样的设计使的 ArraySet 和 ArrayMap 在存储结构上保持了统一。</p>
<h1 id="添加和删除"><a href="#添加和删除" class="headerlink" title="添加和删除"></a>添加和删除</h1><p> ArraySet 和 ArrayMap 在实现上保持了统一，阅读原码可以发现，他们拥有同样的缓存结构，删除和添加元素时会有相同的逻辑流程。<br>大致看下 HashMap 的存储结构</p>
<div align="center"><img src="http://p0.qhimg.com/t0164e470cfc6c407ab.png"/></div>
上图是 HashMap 的存储结构，每个链表后面的元素的数量没有达到将链表树化的数目。 HashMap 在存储k-v键值对的时候，首先根据k的hash值找到k-v存储的链表数组的下标，然后将k-v键值对存储在链表的最后。

<p> ArrayMap 使用两个一维数组分别存储k的hash值和k-v键值对。添加元素时根据k查找元素以确认元素是否已经存在，如果已经存在则直接更新，否则添加；删除元素时查找元素以确定元素是否存在，如果不存在则直接返回，否则删除元素。 ArrayMap 在添加删除元素的过程中，也会涉及到元素的移动，缓存的添加和删除，整个流程和 ArraySet 相同。但是需要注意的是， ArrayMap 在添加和删除元素的过程中，存储k-v键值对 mArray 数组需要同时修改k和v两个元素。</p>
<h1 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h1><p>经过上面的分析，可能发现了一个问题， ArrayMap 和 ArraySet 太相似了。确实是，他们在底层存储结构，缓存结构都是一样的。</p>
<p>添加和删除元素的时候，需要查找元素，添加元素时根据k查找元素以确认元素是否已经存在，如果已经存在则直接更新，否则添加；删除元素时查找元素以确定元素是否存在，如果不存在则直接返回，否则删除元素（又重复了一遍）。 ArrayMap 是否和 ArraySet 具有相同的查找过程呢。直接上源码：</p>
<pre><code>int indexOf(Object key, int hash) {
    final int N = mSize;

    // Important fast case: if nothing is in here, nothing to look for.
    if (N == 0) {
        return ~0;
    }

    int index = binarySearchHashes(mHashes, N, hash);

    // If the hash code wasn&apos;t found, then we have no entry for this key.
    if (index &lt; 0) {
        return index;
    }

    // If the key at the returned index matches, that&apos;s what we want.
    if (key.equals(mArray[index&lt;&lt;1])) {
        return index;
    }

    // Search for a matching key after the index.
    int end;
    for (end = index + 1; end &lt; N &amp;&amp; mHashes[end] == hash; end++) {
        if (key.equals(mArray[end &lt;&lt; 1])) return end;
    }

    // Search for a matching key before the index.
    for (int i = index - 1; i &gt;= 0 &amp;&amp; mHashes[i] == hash; i--) {
        if (key.equals(mArray[i &lt;&lt; 1])) return i;
    }

    // Key not found -- return negative value indicating where a
    // new entry for this key should go.  We use the end of the
    // hash chain to reduce the number of array entries that will
    // need to be copied when inserting.
    return ~end;
}</code></pre><p>​<br>​    private static int binarySearchHashes(int[] hashes, int N, int hash) {<br>​        try {<br>​            return ContainerHelpers.binarySearch(hashes, N, hash);<br>​        } catch (ArrayIndexOutOfBoundsException e) {<br>​            if (CONCURRENT_MODIFICATION_EXCEPTIONS) {<br>​                throw new ConcurrentModificationException();<br>​            } else {<br>​                throw e; // the cache is poisoned at this point, there’s not much we can do<br>​            }<br>​        }<br>​    }<br>以上为 indexOf 函数和 binarySearchHashes 函数的实现。通过对比源码，可以发现， ArrayMap 和 ArraySet 使用了相同的二分查找逻辑，可以肯定的，和 ArraySet 一样， ArrayMap 在存储hash值时是有序的。具体的查找过程的分析可以参考<a href="https://blog.csdn.net/rockstore/article/details/83055565" target="_blank" rel="noopener">ArraySet 添加和删除元素分析</a>。</p>
<h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><p>上面的分析容易让人产生一种感觉— ArraySet 和 ArrayMap 的实现完全相同。这是一种误解， ArraySet 和 ArrayMap 在实现的逻辑流程是相同的，但在细节处理上还是有不同。添加删除元素的过程中，不同点主要体现在在添加和删除元素的过程中，如果有其他操作改变了 ArrayMap 存储的内容的数量，则会抛出 ConcurrentModificationException ， ArrayMap 中能改变存储容量的是以下三个方法： put 、 remove 、 clear </p>
<p>可以做一个小实验<br>首先，两个线程同时修改 ArrayMap 同一个key下的value</p>
<pre><code>ArrayMap&lt;String, String&gt; aMap = new ArrayMap&lt;&gt;();
    aMap.put(&quot;key&quot;, &quot;value&quot;);
    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot;, &quot;value&quot; + i);
            }
        }
    }).start();

    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot;, &quot;value&quot; + i);
            }
        }
    }).start();</code></pre><p>运行后可以发现，程序会一直运行，也不会报错。</p>
<p>接下来看下两个线程同时向 ArrayMap 中添加元素</p>
<pre><code>ArrayMap&lt;String, String&gt; aMap = new ArrayMap&lt;&gt;();
    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot; + i, &quot;value&quot; + i);
            }
        }
    }).start();

    new Thread(new Runnable() {

        @Override
        public void run() {
            // TODO Auto-generated method stub
            for (int i = 0 ; ; i++) {
                aMap.put(&quot;key&quot; + i, &quot;value&quot; + i);
            }
        }
    }).start();</code></pre><p>运行程序后，会报如下异常</p>
<pre><code>Exception in thread &quot;Thread-1&quot; java.util.ConcurrentModificationException
at com.rock.collections.array.ArrayMap.put(ArrayMap.java:527)
at com.rock.collections.Client$2.run(Client.java:50)
at java.lang.Thread.run(Thread.java:748)</code></pre><p>（我将 ArrayMap 抽出来进行测试，故显示的包名是我自定义的）<br>可以发现由于两个线程同时向 aMap 中添加了元素，修改了元素的数量，系统抛出了 ConcurrentModificationException 。</p>
<p>跟踪下添加元素的过程</p>
<pre><code> @Override
public V put(K key, V value) {
    final int osize = mSize;
    ......
    index = ~index;
    if (osize &gt;= mHashes.length) {
        // 数组扩容
        final int n = osize &gt;= (BASE_SIZE*2) ? (osize+(osize&gt;&gt;1))
                : (osize &gt;= BASE_SIZE ? (BASE_SIZE*2) : BASE_SIZE);

        ......
        allocArrays(n);

        if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
            throw new ConcurrentModificationException();
        }
        ......
    }

    ......

    if (CONCURRENT_MODIFICATION_EXCEPTIONS) {
        if (osize != mSize || index &gt;= mHashes.length) {
            throw new ConcurrentModificationException();
        }
    }
    mHashes[index] = hash;
    mArray[index&lt;&lt;1] = key;
    mArray[(index&lt;&lt;1)+1] = value;
    mSize++;
    return null;
}</code></pre><p>源码已经很清晰了，  CONCURRENT_MODIFICATION_EXCEPTIONS = true ，在添加元素之前，使用 osize 记录 mSize ，在扩容之后和最后添加元素之前会对当前元素的数量进行判断，如果发生了变化则抛出异常。</p>
<p>再跟踪下删除元素的过程</p>
<pre><code>public V removeAt(int index) {
    final int osize = mSize;
    ......
    if (osize &lt;= 1) {
        ......
    } else {
        nsize = osize - 1;
        if (mHashes.length &gt; (BASE_SIZE*2) &amp;&amp; mSize &lt; mHashes.length/3) {
            ......

            if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
                throw new ConcurrentModificationException();
            }

            ......
        } else {
            ......
        }
    }
    if (CONCURRENT_MODIFICATION_EXCEPTIONS &amp;&amp; osize != mSize) {
        throw new ConcurrentModificationException();
    }
    mSize = nsize;
    return (V)old;
}</code></pre><p>在缩容或者记录最终元素的数量之前，如果发现元素的数量被修改过，则抛出异常。这个地方还有一个要注意的，由于是删除元素， mSize 最终是要发生变化的，但是源码中对比的 mSize 发生变化之前的值。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p> ArrayMap 的设计是为了更加高效地利用内存，高效体现在一下几点</p>
<ul>
<li>ArrayMap 使用更少的存储单元存储元素<br>ArrayMap 使用 int 类型的数组存储hash，使用 Object 类型数组存储k-v键值对，相较于 HashMap 使用 Node 存储节点， ArrayMap 存储一个元素占用的内存更小。</li>
<li>ArrayMap 在扩容时容量变化更小<br>HashMap 在扩容的时候，通常会将容量扩大一倍，而 ArrayMap 在扩容的时候，如果元素个数超过8，最多扩大自己的1/2。</li>
</ul>
<p>虽然有以上有点，但是和 ArraySet 一样， ArrayMap 也存在一下劣势：</p>
<ul>
<li>存储大量（超过1000）元素时比较耗时<br>在对元素进行查找或者确定待插入元素的位置时使用二分查找，当元素较多时，耗时较长</li>
<li>频繁扩容和缩容，可能会产生大量复制操作<br>ArrayMap 在扩容和缩容时需要移动元素，且扩容时容量变化比 HashMap 小，扩容和缩容的频率可能更高，元素数量过多时，元素的移动可能会对性能产生影响。</li>
</ul>
<p>基于以上优缺点，google给出的建议是当元素数量小于1000时，建议使用 Array 代替 HashMap ，效率降低最多不会超过50%</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/06/android-framework-battery-cal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/06/android-framework-battery-cal/" itemprop="url">Android 耗电计算简析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T00:54:59+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>前面已经分析了耗电统计服务 BSS 的启动流程，并简要说明了 BSS 是如何统计组件耗时的，本文将会以相机耗电统计的计算详细分析一下组件耗电的计算。</p>
<h2 id="计算原理"><a href="#计算原理" class="headerlink" title="计算原理"></a>计算原理</h2><p>在分析 BSS 启动时，提到过新建 BatteryStatsService 实例，真正实现 BatteryStatsService 功能的是 BatteryStatsImpl 实例，看下 BatteryStatsImpl 实例 的构造函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">BatteryStatsImpl</span><span class="params">(Clocks clocks, File systemDir, Handler handler,</span></span></span><br><span class="line"><span class="function"><span class="params">            PlatformIdleStateCallback cb,</span></span></span><br><span class="line"><span class="function"><span class="params">            UserInfoProvider userInfoProvider)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mCameraOnTimer = <span class="keyword">new</span> StopwatchTimer(mClocks, <span class="keyword">null</span>, -<span class="number">13</span>, <span class="keyword">null</span>, mOnBatteryTimeBase);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 BatteryStatsImpl 构造函数中，新建了一个 StopwatchTimer 实例 mCameraOnTimer，先不用关注 StopwatchTimer 的原理，只需要明白 mCameraOnTimer 的主要功能是计算相机的工作时长，本文的主要目的是带着大家一起了解 Android 是如何计算组件耗时。</p>
<p>前面说过，BSS 并不主动统计耗电时长，仅仅是在有和耗电时间变化相关的事件发生时，调用 BSS 的 noteXXX 方法，进行耗电时间的统计，相机的耗电时间计算也是这样。</p>
<h3 id="打开相机"><a href="#打开相机" class="headerlink" title="打开相机"></a>打开相机</h3><p>当某个应用打开相机时，BSS 会调用函数 noteStartCamera</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteStartCamera</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    enforceCallingPermission();</span><br><span class="line">    <span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"begin noteStartCamera"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.noteCameraOnLocked(uid);</span><br><span class="line">        StatsLog.write_non_chained(StatsLog.CAMERA_STATE_CHANGED, uid, <span class="keyword">null</span>,</span><br><span class="line">                StatsLog.CAMERA_STATE_CHANGED__STATE__ON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DBG) Slog.d(TAG, <span class="string">"end noteStartCamera"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 BSS 里的 mStats 是 BatteryStatsImpl 实例，可以看到，接下来会调用 BatteryStatsImpl 的 noteCameraOnLocked 函数，这里的参数 uid 表示某一个应用。继续跟踪</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteCameraOnLocked</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将 isolated 应用的耗电信息映射到实际的应用</span></span><br><span class="line">    uid = mapUid(uid);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = mClocks.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> uptime = mClocks.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (mCameraOnNesting++ == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">// 相机第一次被打开</span></span><br><span class="line">        mHistoryCur.states2 |= HistoryItem.STATE2_CAMERA_FLAG;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_HISTORY) Slog.v(TAG, <span class="string">"Camera on to: "</span></span><br><span class="line">                + Integer.toHexString(mHistoryCur.states2));</span><br><span class="line">        addHistoryRecordLocked(elapsedRealtime, uptime);</span><br><span class="line">		<span class="comment">// 相机耗电的总统计入口</span></span><br><span class="line">        mCameraOnTimer.startRunningLocked(elapsedRealtime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----------------------------分割线--------------------------------*/</span></span><br><span class="line">    <span class="comment">// 根据应用进行统计</span></span><br><span class="line">    getUidStatsLocked(uid).noteCameraTurnedOnLocked(elapsedRealtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解 mapUid 方法需要我们明白 isolated process 这一概念，isolated process 进程在运行时会在应用下新建一个特殊的进程，且 isolated process 拥有和应用不一样的 uid，为了统计应用下 isolated process 和其他进程，需要将 isolated process 进程的 uid 映射到应用的 uid，这样才能准确统计某一个应用的耗电。</p>
<p>可以看到函数 noteCameraOnLocked 里有一条注视分割线，这条分割线是我自己添加的，分割线前面是统计相机的耗电时长，分割线后面是按照应用统计相机耗电时长。</p>
<p>这里还有一个 int 类型参数 mCameraOnNesting ，这个变量的作用记录相机执行打开操作的次数，其实很好理解，如果是第一次执行打开操作，对于统计相机耗电时长来说，则需要开始执行统计，如果不是第一次执行打开，则不需要再开始统计。如果是第一次执行打开操作，则需要将此次打开操作添加到历史记录中，并执行 mCameraOnTimer.startRunningLocked 开始进行时间计算。</p>
<p>执行完相机耗电时长统计后，接下来就是统计每个应用使用相机的时长。先看下 getUidStatsLocked 这个函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Uid <span class="title">getUidStatsLocked</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    Uid u = mUidStats.get(uid);</span><br><span class="line">    <span class="keyword">if</span> (u == <span class="keyword">null</span>) &#123;</span><br><span class="line">        u = <span class="keyword">new</span> Uid(<span class="keyword">this</span>, uid);</span><br><span class="line">        mUidStats.put(uid, u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mUidStats 保存的是 uid -&gt; Uid 映射，uid 是 int 类型的数值，标识一个应用，Uid 记录每一个应用的耗电信息，这样一解释，getUidStatsLocked(uid).noteCameraTurnedOnLocked 其实就很好理解了，关注一下 Uid 的 noteCameraTurnedOnLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteCameraTurnedOnLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtimeMs)</span> </span>&#123;</span><br><span class="line">    createCameraTurnedOnTimerLocked().startRunningLocked(elapsedRealtimeMs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再继续跟踪 createCameraTurnedOnTimerLocked 方法，看它究竟返回的是什么对象</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StopwatchTimer <span class="title">createCameraTurnedOnTimerLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraTurnedOnTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCameraTurnedOnTimer = <span class="keyword">new</span> StopwatchTimer(mBsi.mClocks, Uid.<span class="keyword">this</span>, CAMERA_TURNED_ON,</span><br><span class="line">                mBsi.mCameraTurnedOnTimers, mBsi.mOnBatteryTimeBase);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCameraTurnedOnTimer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现， Uid 内部也是用的 StopwatchTimer 实例记录相机的耗电时长。</p>
<p>到这里，我们应该就有一个大致的印象了，BSS 使用 StopwatchTimer 记录相机的时长，BatteryStatsImpl 的 mCameraOnTimer 用于记录相机的总时长， Uid 内部的 mCameraTurnedOnTimer 用于记录每个应用的相机耗电时长。突然感觉一下子豁然开朗！！！！！</p>
<h3 id="关闭相机"><a href="#关闭相机" class="headerlink" title="关闭相机"></a>关闭相机</h3><p>有打开相机，就有关闭相机，相机关闭时，如何更新相机的耗电时长呢？相机关闭时，会调用 BSS 的 noteStopCamera 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteStopCamera</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    enforceCallingPermission();</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.noteCameraOffLocked(uid);</span><br><span class="line">        StatsLog.write_non_chained(StatsLog.CAMERA_STATE_CHANGED, uid, <span class="keyword">null</span>,</span><br><span class="line">                StatsLog.CAMERA_STATE_CHANGED__STATE__OFF);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 uid 是应用的 uid。接下来会调用 BatteryStatsImpl 的 noteCameraOffLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteCameraOffLocked</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOnNesting == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    uid = mapUid(uid);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = mClocks.elapsedRealtime();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> uptime = mClocks.uptimeMillis();</span><br><span class="line">    <span class="keyword">if</span> (--mCameraOnNesting == <span class="number">0</span>) &#123;</span><br><span class="line">        mHistoryCur.states2 &amp;= ~HistoryItem.STATE2_CAMERA_FLAG;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_HISTORY) Slog.v(TAG, <span class="string">"Camera off to: "</span></span><br><span class="line">                + Integer.toHexString(mHistoryCur.states2));</span><br><span class="line">        addHistoryRecordLocked(elapsedRealtime, uptime);</span><br><span class="line">        mCameraOnTimer.stopRunningLocked(elapsedRealtime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*-----------------------------分割线--------------------------------*/</span></span><br><span class="line">    getUidStatsLocked(uid).noteCameraTurnedOffLocked(elapsedRealtime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCameraOnNesting 的作用可以参考在打开相机时的介绍。mCameraOnNesting == 0 表示相机已经关闭，故直接返回，接下来会通过 –mCameraOnNesting == 0 来判断此次关闭操作后，是否还有应用在使用相机，如果没有，则会保存此次记录，并停止计算相机耗电时长。这里也有一条分割线，分割线的含义和打开相机时的解释一致。后面的内容会在重置相机中进行分析。</p>
<h3 id="重置相机"><a href="#重置相机" class="headerlink" title="重置相机"></a>重置相机</h3><p>为什么会有重置相机这一操作呢，其实很好理解，有这样的场景，多个应用都在使用相机，用户通过任务栏一次性将所有应用都杀死，那么所有应用都需要停止相机耗时统计。<br>和打开关闭相机一样，执行重置相机操作时，会调用 BSS 的 noteResetCamera 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteResetCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    enforceCallingPermission();</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.noteResetCameraLocked();</span><br><span class="line">        StatsLog.write_non_chained(StatsLog.CAMERA_STATE_CHANGED, -<span class="number">1</span>, <span class="keyword">null</span>,</span><br><span class="line">                StatsLog.CAMERA_STATE_CHANGED__STATE__RESET);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来会调用 BatteryStatsImpl 的 noteResetCameraLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">noteResetCameraLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCameraOnNesting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> elapsedRealtime = mClocks.elapsedRealtime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> uptime = mClocks.uptimeMillis();</span><br><span class="line">        mCameraOnNesting = <span class="number">0</span>;</span><br><span class="line">        mHistoryCur.states2 &amp;= ~HistoryItem.STATE2_CAMERA_FLAG;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_HISTORY) Slog.v(TAG, <span class="string">"Camera off to: "</span></span><br><span class="line">                + Integer.toHexString(mHistoryCur.states2));</span><br><span class="line">        addHistoryRecordLocked(elapsedRealtime, uptime);</span><br><span class="line">        mCameraOnTimer.stopAllRunningLocked(elapsedRealtime);</span><br><span class="line">        <span class="comment">/*-----------------------------分割线--------------------------------*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mUidStats.size(); i++) &#123;</span><br><span class="line">            BatteryStatsImpl.Uid uid = mUidStats.valueAt(i);</span><br><span class="line">            uid.noteResetCameraLocked(elapsedRealtime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mCameraOnNesting &gt; 0 表示相机处于被打开的状态，重置操作直接将 mCameraOnNesting 设置为 0，然后保存此次记录，并停止相机耗时统计。这里使用的是 stopAllRunningLocked 函数，和前面的 stopRunningLocked 有什么区别呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stopAllRunningLocked</span><span class="params">(<span class="keyword">long</span> elapsedRealtimeMs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mNesting &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mNesting = <span class="number">1</span>;</span><br><span class="line">        stopRunningLocked(elapsedRealtimeMs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>stopAllRunningLocked 最终也是调用 stopRunningLocked 方法，<br>mNesting 是 StopwatchTimer 内部的 int 类型参数，和 mCameraOnNesting 是相同的含义，不同的是 mCameraOnNesting 针对的相机这一组件， mNesting 针对的所有使用 StopwatchTimer 的实例。可能有一个疑问，执行 reset 操作时，mCameraOnNesting 被设置为 0，为什么执行 stopAllRunningLocked 后 mNesting 被设置为 1 呢？其实也很好理解，可以参考关闭相机时的分析，如果将 mNesting 设置为 0， 这stopRunningLocked 会直接返回，所以这里为了防止 stopRunningLocked 内部逻辑无法执行，就先将 mNesting 设置为 1 了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文总结了相机计算耗电时长的逻辑，目的是让大家熟悉 BSS 是如何计算组件耗电时长的，这里要注意的时，进行耗电时长统计时，会按照组件和应用区分，比如对于本文提到的相机耗电时长，BSS 会记录相机耗电的总时长，也会按照应用统计每个应用使用相机的时长，这种模式会贯穿 BSS。至于本文中的 startXXX 和 stopXXX 方法，会在下篇分析 BSS 中的 Timer 体系中进行分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/06/android-framework-battery/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/06/android-framework-battery/" itemprop="url">耗电统计服务启动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T00:44:50+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>Android 的耗电计算也是一个系统服务，本文包括以下内容：</p>
<ul>
<li>耗电统计服务（BatteryStatsService，简称 BSS）的启动流程</li>
<li>耗电计算的简要流程</li>
</ul>
<p>经过以上两部分的分析，可以帮助我们对 Android 的耗电计算有一个框架性的认识，后面的文章会对这种框架性的认识进行细节上的丰富。</p>
<h2 id="Android-耗电统计概览"><a href="#Android-耗电统计概览" class="headerlink" title="Android 耗电统计概览"></a>Android 耗电统计概览</h2><h2 id="BSS-的启动"><a href="#BSS-的启动" class="headerlink" title="BSS 的启动"></a>BSS 的启动</h2><p>BatteryStatsService.java 文件位于 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">platform_frameworks_base/services/core/java/com/android/server/am/</span><br></pre></td></tr></table></figure>

<p>BSS 的启动逻辑位于 ActivityManagerService （AMS）的构造函数中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 新建 BatteryStatsService 实例</span></span><br><span class="line">mBatteryStatsService = <span class="keyword">new</span> BatteryStatsService(systemContext, systemDir, mHandler);</span><br><span class="line"><span class="comment">// 读取已经保存的耗电信息</span></span><br><span class="line">mBatteryStatsService.getActiveStatistics().readLocked();</span><br><span class="line"><span class="comment">// 写入耗电信息</span></span><br><span class="line">mBatteryStatsService.scheduleWriteToDisk();</span><br><span class="line">mOnBattery = DEBUG_POWER ? <span class="keyword">true</span></span><br><span class="line">                : mBatteryStatsService.getActiveStatistics().getIsOnBattery();</span><br><span class="line"><span class="comment">// 设置耗电信息更新的回调</span></span><br><span class="line">mBatteryStatsService.getActiveStatistics().setCallback(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<p>这里有一个点可能会被忽略，AMS 的构造函数在新建 AMS 的对象（一句废话），此时正是系统启动的过程，记住这一点。BSS 的启动逻辑做了四个操作：</p>
<ul>
<li>新建 BatteryStatusService 实例</li>
<li>读取已经保存的耗电信息</li>
<li>写入耗电信息</li>
<li>设置耗电更新回调</li>
</ul>
<p>接下来分别对这四个操作进行分析</p>
<h3 id="新建-BatteryStatsService-实例"><a href="#新建-BatteryStatsService-实例" class="headerlink" title="新建 BatteryStatsService 实例"></a>新建 BatteryStatsService 实例</h3><p>虽然仅仅是新建了 BatteryStatsService 实例，但是这条语句蕴含的内容却很多</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">BatteryStatsService(Context context, File systemDir, Handler handler) &#123;</span><br><span class="line">    <span class="comment">// BatteryStatsImpl expects the ActivityManagerService handler, so pass that one through.</span></span><br><span class="line">    mContext = context;</span><br><span class="line">    mUserManagerUserInfoProvider = <span class="keyword">new</span> BatteryStatsImpl.UserInfoProvider() &#123;</span><br><span class="line">        <span class="keyword">private</span> UserManagerInternal umi;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span>[] getUserIds() &#123;</span><br><span class="line">            <span class="keyword">if</span> (umi == <span class="keyword">null</span>) &#123;</span><br><span class="line">                umi = LocalServices.getService(UserManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> (umi != <span class="keyword">null</span>) ? umi.getUserIds() : <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    mStats = <span class="keyword">new</span> BatteryStatsImpl(systemDir, handler, <span class="keyword">this</span>, mUserManagerUserInfoProvider);</span><br><span class="line">	<span class="comment">// mWorker 内部统计收集电池信息</span></span><br><span class="line">    ......</span><br><span class="line">    mStats.setPowerProfileLocked(<span class="keyword">new</span> PowerProfile(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mUserManagerUserInfoProvider 类的作用是获取系统上应用的 uid 集合，获取 uid 集合的目的是为了统计不同应用的耗电情况，后面在分析不同应用耗电时会有介绍。BatteryStatsService 的作用是进行耗电统计，但是真正实现这些功能的类是 BatteryStatsImpl 类。最后一条语句需要上下代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mStats.setPowerProfileLocked(<span class="keyword">new</span> PowerProfile(context));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PowerProfile</span><span class="params">(Context context, <span class="keyword">boolean</span> forTest)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Read the XML file for the given profile (normally only one per device)</span></span><br><span class="line">    <span class="keyword">synchronized</span> (sLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (sPowerItemMap.size() == <span class="number">0</span> &amp;&amp; sPowerArrayMap.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            readPowerValuesFromXml(context, forTest);</span><br><span class="line">        &#125;</span><br><span class="line">        initCpuClusters();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 setPowerProfileLocked ，最终通过 readPowerValuesFromXml 获取手机不同组件的耗电信息。 readPowerValuesFromXml 读取的是 frameworks/core/res/res/xml/power_profile.xml 文件里的配置信息，可以看下配置信息的格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">device</span> <span class="attr">name</span>=<span class="string">"Android"</span>&gt;</span></span><br><span class="line">  ......</span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.on"</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  <span class="comment">&lt;!-- ~3mA --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.active"</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  <span class="comment">&lt;!-- WIFI data transfer, ~200mA --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">"wifi.scan"</span>&gt;</span>0.1<span class="tag">&lt;/<span class="name">item</span>&gt;</span>  <span class="comment">&lt;!-- WIFI network scanning, ~100mA --&gt;</span></span><br><span class="line">  .......</span><br><span class="line"><span class="tag">&lt;/<span class="name">device</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如上所示 power_profile.xml 里组件的耗电是电流信息，为什么会是这样呢？对于手机来说，电压是固定的，根据功率计算公式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">P = U * I</span><br><span class="line">W = P * t</span><br></pre></td></tr></table></figure>
<p>只需要知道电流和时间，就可以计算组件的耗电了，由于组件的电流也以配置文件的方式固定下来，所以<strong>通常来说，统计组件耗电就是统计组件在不同状态的运行时间。</strong></p>
<p>这里还有一个比较重要的位置，SystemService 在启动完 AMS 之后，会调用 AMS 的 initPowerManagement 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startBootstrapServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mActivityManagerService.initPowerManagement();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪一下 AMS 的 initPowerManagement 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPowerManagement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    mBatteryStatsService.initPowerManagement();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看下 BSS 内部是如何执行 initPowerManagement </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initPowerManagement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> PowerManagerInternal powerMgr = LocalServices.getService(PowerManagerInternal<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    powerMgr.registerLowPowerModeObserver(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mStats) &#123;</span><br><span class="line">        mStats.notePowerSaveModeLocked(</span><br><span class="line">                powerMgr.getLowPowerState(ServiceType.BATTERY_STATS)</span><br><span class="line">                        .batterySaverEnabled);</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行 initPowerManagement 首先获取了 PowerManager 服务，然后注册了低电模式的监听器，执行 mStats.notePowerSaveModeLocked 开始统计低电耗时统计。</p>
<h3 id="读取已经保存的耗电信息"><a href="#读取已经保存的耗电信息" class="headerlink" title="读取已经保存的耗电信息"></a>读取已经保存的耗电信息</h3><p>耗电服务 BatteryStatusService 在记录系统组件耗电的同时，会将这些信息保存在文件 /data/system/batterystats.bin 中，mBatteryStatsService.getActiveStatistics() 返回 BatteryStatsImpl 实例，mBatteryStatsService.getActiveStatistics().readLocked 调用 BatteryStatsImpl 的 readLocked() 方法。 readLocked 方法主要读取了系统存储的每天耗电信息以及其他的耗电统计信息，可以自己去分析以下。</p>
<h3 id="写入耗电信息"><a href="#写入耗电信息" class="headerlink" title="写入耗电信息"></a>写入耗电信息</h3><p>写入耗电信息 的作用是对当前系统的耗电统计进行记录，写入到日志文件中。</p>
<h3 id="设置耗电更新回调"><a href="#设置耗电更新回调" class="headerlink" title="设置耗电更新回调"></a>设置耗电更新回调</h3><p>耗电回调 BatteryCallback 接口如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BatteryCallback</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 需要更新 CPU 耗电信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batteryNeedsCpuUpdate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 手机在供电在电源供电和电池供电之间发生了变化，onBattery 表示是否电池供电</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batteryPowerChanged</span><span class="params">(<span class="keyword">boolean</span> onBattery)</span></span>;</span><br><span class="line">    <span class="comment">// 手机在充电和放电之间发生了变化，intent 中根据 action 信息标示充电（android.os.action.CHARGING）和放电（android.os.action.DISCHARGING）状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batterySendBroadcast</span><span class="params">(Intent intent)</span></span>;</span><br><span class="line">    <span class="comment">// 电池统计信息被重制</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">batteryStatsReset</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h3><p>BSS 是一个系统服务，需要将服务发布出去以便向外部暴露相关的接口，BSS 是如何将自己发布出去的呢？ ActivityManagerService 在启动的时候，会调用 onStart() 方法，最终会调用 ActivityManagerService 的 start 方法， start 方法内部会进行 BSS 的服务发布</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private void start() &#123;</span><br><span class="line">    ......</span><br><span class="line">    mBatteryStatsService.publish();</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>继续跟踪 mBatteryStatsService.publish() 代码，最终看到了如下的位置，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public void publish() &#123;</span><br><span class="line">    LocalServices.addService(BatteryStatsInternal.class, new LocalService());</span><br><span class="line">    ServiceManager.addService(BatteryStats.SERVICE_NAME, asBinder());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LocalServices 的作用有点类似 ServiceManager 的功能，不通的是 LocalServices 内部管理的服务不是 Binder 对象，且其保存的服务是为本进程内部使用的。这里在进行服务发布的时候，先在 LocalServices 执行了 addService 方法以便本进程使用 BSS，接着在 ServiceManager 执行了 addService 方法以便其他进程使用 BSS。</p>
<h2 id="耗电计算的简要流程"><a href="#耗电计算的简要流程" class="headerlink" title="耗电计算的简要流程"></a>耗电计算的简要流程</h2><p>前面分析了 BSS 的启动和 BSS 的发布，但是有一个疑问一直存在，分析 BSS 启动的时候，仅仅出现了 BSS 实例的新建和相关配置信息读取，分析 BSS 的发布也仅仅是一个发布的操作，BSS 究竟是如何进行耗电统计的呢？<br>BSS 并不主动进行耗电统计，而是被动更新系统组件的耗电时间。前面以及说过，BSS 内部耗电的最终计算实际是 BatteryStatsImpl 实例完成的，BSS 在收到和耗电相关的事件或者外部主动更新耗电信息时，会调用 BSS 的 noteXXX 方法，最终会调用 BatteryStatsImpl 内的方法，更新耗电组件的耗电时间信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文概述了 Android 的耗电启动并简单说明了 BSS 的耗电计算流程，下篇文章将会以相机的耗电计算为例，分析 Android 的耗电计算流程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/06/java-anno/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/06/java-anno/" itemprop="url">Java 注解实现简析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-06T00:04:15+08:00">
                2020-05-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/Java-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index">
                    <span itemprop="name">Java 基础知识</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注解是平时开发过程中使用频率很高的点，注解的基础可以参考这篇文章：<a href="https://www.jianshu.com/p/9471d6bcf4cf" target="_blank" rel="noopener">https://www.jianshu.com/p/9471d6bcf4cf</a> ，本文会从简单的 Demo 开始，逐步深入分析注解是如何实现的。</p>
<h2 id="Demo-引入"><a href="#Demo-引入" class="headerlink" title="Demo 引入"></a>Demo 引入</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnoTest &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义了一个方法的注解，就不做语法上的解释了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnoTestClz</span> </span>&#123;</span><br><span class="line">    <span class="meta">@AnnoTest</span>(test = <span class="string">"test1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test anno"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>申明了一个简单的类，在 test 方法上使用了 AnnoTest 注解，接下来使用简单的测试程序使用注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AnnoTestClz atc = <span class="keyword">new</span> AnnoTestClz();</span><br><span class="line">Method test = atc.getClass().getDeclaredMethod(<span class="string">"test"</span>);</span><br><span class="line">AnnoTest annoTest = test.getDeclaredAnnotation(AnnoTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">System.out.println(annoTest.test());</span><br></pre></td></tr></table></figure>
<p>程序运行结果如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test1</span><br></pre></td></tr></table></figure>
<p>其实程序的运行结果不用分析，一眼就能看出来，接下来就开始分析下以下语句是如何运行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AnnoTest annoTest = test.getDeclaredAnnotation(AnnoTest<span class="class">.<span class="keyword">class</span>)</span>;</span><br></pre></td></tr></table></figure>
<h2 id="深入"><a href="#深入" class="headerlink" title="深入"></a>深入</h2><p>本节的主要内容是分析 test.getDeclaredAnnotation ，其实就是分析类 Method 的 getDeclaredAnnotation 方法，那就开始深入吧</p>
<h3 id="getDeclaredAnnotation"><a href="#getDeclaredAnnotation" class="headerlink" title="getDeclaredAnnotation"></a>getDeclaredAnnotation</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends Annotation&gt; <span class="function">T <span class="title">getDeclaredAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Only annotations on classes are inherited, for all other</span></span><br><span class="line">    <span class="comment">// objects getDeclaredAnnotation is the same as</span></span><br><span class="line">    <span class="comment">// getAnnotation.</span></span><br><span class="line">    <span class="keyword">return</span> getAnnotation(annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法不是 Method 中的方法，而是 Method 父类 AccessibleObject 类中的方法，这里有必要说明下这里面涉及到的类继承结构。</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/annotation/anno_hierarchy.jpg" alt=""></p>
<p>从上图可以看出，Method 方法继承 Executable , Executable 继承 AccessibleObject 。继续跟踪 Method 类中的 getAnnotation(annotationClass) 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.getAnnotation(annotationClass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Method 最终会调用父类 AccessibleObject 的 getAnnotation(annotationClass) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T extends Annotation&gt; <span class="function">T <span class="title">getAnnotation</span><span class="params">(Class&lt;T&gt; annotationClass)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(annotationClass);</span><br><span class="line">    <span class="keyword">return</span> annotationClass.cast(declaredAnnotations().get(annotationClass));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>annotationClass.cast 方法是对象转换方法，直觉告诉我，declaredAnnotations() 方法获取了全部的注解，保存成了 Map 的接口，然后根据传入的注解 Class 获取注解的实例。OK，废话不多说，让我们赶紧去看看 declaredAnnotations() 方法的实现。</p>
<h3 id="declaredAnnotations"><a href="#declaredAnnotations" class="headerlink" title="declaredAnnotations"></a>declaredAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">synchronized</span>  Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations() &#123;</span><br><span class="line">    <span class="keyword">if</span> (declaredAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Executable root = getRoot();</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="keyword">null</span>) &#123;</span><br><span class="line">            declaredAnnotations = root.declaredAnnotations();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            declaredAnnotations = AnnotationParser.parseAnnotations(</span><br><span class="line">                getAnnotationBytes(),</span><br><span class="line">                sun.misc.SharedSecrets.getJavaLangAccess().</span><br><span class="line">                getConstantPool(getDeclaringClass()),</span><br><span class="line">                getDeclaringClass());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> declaredAnnotations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然不出所料， declaredAnnotations() 返回了注解 class 到注解对象的 Map 结构。注意，declaredAnnotations() 方法是在类 Executable 中。这里有一个新的东西 getRoot() 方法，getRoot() 方法返回一个 Executable 实例，是一个抽象方法，在 Method 实现中，会返回一个 Method 类型的的对象 root ，root 的主要作用是实现注解共享。如何理解注解共享呢？注解共享，顾名思义，就是许多个方法使用同样的注解信息，什么时候会用到呢？<br>注解的共享主要用在 Method 对象的复制，在复制时，让所有复制的对象都指向最开始被复制的 Method 对象，这样，只要最开始的被复制对象执行了注解的解析，后面复制的对象就可以直接使用已经被解析的注解信息，这算是对注解的优化（大家可以参考 Mehtod 类中的 copy 方法）。最开始被复制对象在执行注解的解析时，会执行 declaredAnnotations() 里的 else 分支。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">declaredAnnotations = AnnotationParser.parseAnnotations(</span><br><span class="line">                getAnnotationBytes(),</span><br><span class="line">                sun.misc.SharedSecrets.getJavaLangAccess().</span><br><span class="line">                getConstantPool(getDeclaringClass()),</span><br><span class="line">                getDeclaringClass());</span><br></pre></td></tr></table></figure>
<p>在分析 parseAnnotations 方法之前，我们要对这个方法中的参数有所了解，不然后面的分析会无所适从。</p>
<ul>
<li>getAnnotationBytes()</li>
</ul>
<p>方法的名字很清晰的表达了这个函数返回的内容，就是注解的 byte 数组，如何理解注解的 byte 数组，注解为什么会有 byte 数组？Method 中的注解信息以 byte 数组的形式存在与 Method 对象的 annotations 变量中，annotatins 变量在 Method 对象被新建时赋值的，可以大致看下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Method(Class&lt;?&gt; declaringClass,</span><br><span class="line">           String name,</span><br><span class="line">           Class&lt;?&gt;[] parameterTypes,</span><br><span class="line">           Class&lt;?&gt; returnType,</span><br><span class="line">           Class&lt;?&gt;[] checkedExceptions,</span><br><span class="line">           <span class="keyword">int</span> modifiers,</span><br><span class="line">           <span class="keyword">int</span> slot,</span><br><span class="line">           String signature,</span><br><span class="line">           <span class="keyword">byte</span>[] annotations,</span><br><span class="line">           <span class="keyword">byte</span>[] parameterAnnotations,</span><br><span class="line">           <span class="keyword">byte</span>[] annotationDefault) &#123;</span><br><span class="line">        <span class="keyword">this</span>.clazz = declaringClass;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.parameterTypes = parameterTypes;</span><br><span class="line">        <span class="keyword">this</span>.returnType = returnType;</span><br><span class="line">        <span class="keyword">this</span>.exceptionTypes = checkedExceptions;</span><br><span class="line">        <span class="keyword">this</span>.modifiers = modifiers;</span><br><span class="line">        <span class="keyword">this</span>.slot = slot;</span><br><span class="line">        <span class="keyword">this</span>.signature = signature;</span><br><span class="line">        <span class="keyword">this</span>.annotations = annotations;</span><br><span class="line">        <span class="keyword">this</span>.parameterAnnotations = parameterAnnotations;</span><br><span class="line">        <span class="keyword">this</span>.annotationDefault = annotationDefault;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>至于该构造方法在什么位置被调用，感兴趣的同学可以参考下类 Class 的 privateGetDeclaredMethods 方法。</p>
<ul>
<li>sun.misc.SharedSecrets.getJavaLangAccess().<pre><code>getConstantPool(getDeclaringClass())</code></pre></li>
</ul>
<p>这个方法获取了申明这个方法的 Class 的常量池信息，至于什么是常量池，大家可以搜一下 Class 文件的结构。</p>
<ul>
<li>getDeclaringClass()</li>
</ul>
<p>这个方法就不多说了，很明显了。</p>
<p>OK，接下来就开始进入 AnnotationParser.parseAnnotations 方法了。</p>
<h3 id="parseAnnotations"><a href="#parseAnnotations" class="headerlink" title="parseAnnotations"></a>parseAnnotations</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations(</span><br><span class="line">                <span class="keyword">byte</span>[] rawAnnotations,</span><br><span class="line">                ConstantPool constPool,</span><br><span class="line">                Class&lt;?&gt; container) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rawAnnotations == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> parseAnnotations2(rawAnnotations, constPool, container, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(BufferUnderflowException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(<span class="string">"Unexpected end of annotations."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span>(IllegalArgumentException e) &#123;</span><br><span class="line">        <span class="comment">// Type mismatch in constant pool</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>逻辑比较清晰，继续看 parseAnnotations2 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; parseAnnotations2(<span class="keyword">byte</span>[] var0, ConstantPool var1, Class&lt;?&gt; var2, Class&lt;? extends Annotation&gt;[] var3) &#123;</span><br><span class="line">    LinkedHashMap result = <span class="keyword">new</span> LinkedHashMap();</span><br><span class="line">    <span class="comment">// 使用注解字节码数据构造 ByteBuffer 实例 var5</span></span><br><span class="line">    ByteBuffer buf = ByteBuffer.wrap(var0);</span><br><span class="line">    <span class="comment">// 获取 Method 注解的数量（一个 Method 可以有多个注解）</span></span><br><span class="line">    <span class="keyword">int</span> numAnnotations = buf.getShort() &amp; <span class="string">'\uffff'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numAnnotations; i++) &#123;</span><br><span class="line">        <span class="comment">// 逐个解析注解，并获取注解的实例</span></span><br><span class="line">        Annotation a = parseAnnotation2(buf, constPool, container, <span class="keyword">false</span>, selectAnnotationClasses);</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Class klass = a.annotationType();</span><br><span class="line">            <span class="comment">// 将注解实例按照类型存储在 result 中</span></span><br><span class="line">            <span class="keyword">if</span> (AnnotationType.getInstance(klass).retention() == RetentionPolicy.RUNTIME &amp;&amp; result.put(klass, a) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AnnotationFormatError(</span><br><span class="line">                            <span class="string">"Duplicate annotation for class: "</span>+klass+<span class="string">": "</span> + a);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> var4;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过对 parseAnnotations2 方法的注释，相信大家已经对注解的解析过程有了一个比较清晰的理解。接下来，就到了最为核心的倒数第三步了，先给大家剧透以下，注解最终的实现是通过动态代理实现的。通过 parseAnnotation2 方法获取到注解的实例对象 a 后，按照注解的类型（Class）将 a 保存在 result 中，后续获取则直接通过 result 获取。</p>
<p>OK，接下来我们就要分析非常核心的函数 parseAnnotation2 了。</p>
<h3 id="parseAnnotation2"><a href="#parseAnnotation2" class="headerlink" title="parseAnnotation2"></a>parseAnnotation2</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Annotation <span class="title">parseAnnotation2</span><span class="params">(ByteBuffer buf,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ConstantPool constPool,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Class&lt;?&gt; container,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">boolean</span> exceptionOnMissingAnnotationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              Class&lt;? extends Annotation&gt;[] selectAnnotationClasses)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 常量池中注解类型描述符的索引</span></span><br><span class="line">    <span class="keyword">int</span> typeIndex = buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationClass = <span class="keyword">null</span>;</span><br><span class="line">    String sig = <span class="string">"[unknown]"</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注解的类型，在前面的 Demo 中，sig 就是AnnoTest类的签名信息</span></span><br><span class="line">            sig = constPool.getUTF8At(typeIndex);</span><br><span class="line">            <span class="comment">// 根据 sig 签名信息，获取 Class 信息</span></span><br><span class="line">            annotationClass = (Class&lt;? extends Annotation&gt;)parseSig(sig, container);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException ex) &#123;</span><br><span class="line">            <span class="comment">// support obsolete early jsr175 format class files</span></span><br><span class="line">            annotationClass = (Class&lt;? extends Annotation&gt;)constPool.getClassAt(typeIndex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoClassDefFoundError e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (TypeNotPresentException e) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">// AnnotationType 实例保存了注解内部的成员信息</span></span><br><span class="line">    AnnotationType type = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        type = AnnotationType.getInstance(annotationClass);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        skipAnnotation(buf, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Class&lt;?&gt;&gt; memberTypes = type.memberTypes();</span><br><span class="line">    Map&lt;String, Object&gt; memberValues =</span><br><span class="line">        <span class="keyword">new</span> LinkedHashMap&lt;String, Object&gt;(type.memberDefaults());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMembers = buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">    <span class="comment">// 遍历注解的所有方法，并将每个方法的值保存在 memberValues 变量中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numMembers; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> memberNameIndex = buf.getShort() &amp; <span class="number">0xFFFF</span>;</span><br><span class="line">        String memberName = constPool.getUTF8At(memberNameIndex);</span><br><span class="line">        Class&lt;?&gt; memberType = memberTypes.get(memberName);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (memberType == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Member is no longer present in annotation type; ignore it</span></span><br><span class="line">            skipMemberValue(buf);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Object value = parseMemberValue(memberType, buf, constPool, container);</span><br><span class="line">            <span class="keyword">if</span> (value <span class="keyword">instanceof</span> AnnotationTypeMismatchExceptionProxy)</span><br><span class="line">                ((AnnotationTypeMismatchExceptionProxy) value).</span><br><span class="line">                    setMember(type.members().get(memberName));</span><br><span class="line">            memberValues.put(memberName, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> annotationForMap(annotationClass, memberValues);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法看似很长，逻辑梳理起来很简单，就是逐个遍历注解的每一个成员（方法），然后将每个方法的返回值根据方法名保存在 memberValues 中。在 parseAnnotations2 方法中，我们知道 parseAnnotation2 返回的是一个注解类型的实例，但是注解又是一个接口，如何根据注解的 Class 信息构造一个注解的实例呢？我们继续跟踪 annotationForMap 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Annotation <span class="title">annotationForMap</span><span class="params">(<span class="keyword">final</span> Class&lt;? extends Annotation&gt; type,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Annotation&gt;() &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Annotation <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (Annotation) Proxy.newProxyInstance(</span><br><span class="line">                type.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; type &#125;,</span><br><span class="line">                <span class="keyword">new</span> AnnotationInvocationHandler(type, memberValues));</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于看到了最终的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(Annotation) Proxy.newProxyInstance(</span><br><span class="line">            type.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; type &#125;,</span><br><span class="line">            <span class="keyword">new</span> AnnotationInvocationHandler(type, memberValues));</span><br></pre></td></tr></table></figure>
<p>不得不说，动态代理在这个位置的使用很是巧妙啊，废话不多说，赶紧看下 AnnotationInvocationHandler </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> </span>&#123;</span><br><span class="line">    String member = method.getName();</span><br><span class="line">    Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle Object and Annotation methods</span></span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">"equals"</span>) &amp;&amp; paramTypes.length == <span class="number">1</span> &amp;&amp;</span><br><span class="line">        paramTypes[<span class="number">0</span>] == Object<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">        return equalsImpl(args[0]);</span><br><span class="line">    <span class="keyword">assert</span> paramTypes.length == <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">"toString"</span>))</span><br><span class="line">        <span class="keyword">return</span> toStringImpl();</span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">"hashCode"</span>))</span><br><span class="line">        <span class="keyword">return</span> hashCodeImpl();</span><br><span class="line">    <span class="keyword">if</span> (member.equals(<span class="string">"annotationType"</span>))</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle annotation member accessors</span></span><br><span class="line">    Object result = memberValues.get(member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IncompleteAnnotationException(type, member);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result <span class="keyword">instanceof</span> ExceptionProxy)</span><br><span class="line">        <span class="keyword">throw</span> ((ExceptionProxy) result).generateException();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result.getClass().isArray() &amp;&amp; Array.getLength(result) != <span class="number">0</span>)</span><br><span class="line">        result = cloneArray(result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>这里只展示了核心的 invoke 方法，核心的逻辑就是根据方法的名称，从 memberValues 中去除前面保存的值，并返回。其他的逻辑就不做过多说明，感兴趣的同学可以自行研究下 AnnotationInvocationHandler 的源码。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文以方法的注解切入，从源码的角度去分析注解的实现细节。总结起来就是：使用动态代理生成注解实例，将注解的实例根据注解的 Class 保存在方法的 declaredAnnotations 变量中</p>
<p>方法的注解实现原理比较清晰，但是彻底明白方法注解的实现需要对 Class 文件的结构以及动态代理的原理有比较清晰的理解。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/05/design-pattern-mediator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/05/design-pattern-mediator/" itemprop="url">中介者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T10:07:46+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>包装了一系列对象相互作用的方式，使得这些对象不必相互明显引用，从而使他们可以较松散的耦合，当这些对象中的某些对象之间相互发生作用发生改变时，不会理解影响到其他的一些对象之间的相互作用，从而保证这些相互作用可以彼此独立地变化。</p>
<h2 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h2><p>上面的定义很官方，其实生活中，中介者模式离我们最近的应该就是房产中介了，卖房者将房子挂在房屋中介，购买者通过房屋中介得到房屋信息，然后通过中介达成最后的交易。如何更加形象地去理解呢，先看下下面这张图</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/un_mediator.png" alt=""></p>
<p>可以看到，存在 A - D 五个对象，他们之间存在相互作用，他们之间的耦合关系使得修改某一个对象的行为时，可能会印象其他对象的行为。出现上述问题的根本原因是这五个对象之间是直接相互依赖，如果换一种方式会不会好些呢？</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/mediator_optimize.png" alt=""></p>
<p>这样修改之后的好处也是十分明显，最显著的优点，对象之间的直接依赖被解除了，对象之间依赖关系的复杂性被大大降低，某个对象的修改之后，如果对其他对象有影响，直接修改中介者即可。以上使用的就是中介者模式的思想。</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/mediator.png" alt=""></p>
<p>如上图所示，中介者模式涉及到四种角色：</p>
<ul>
<li><p>Mediator 抽象中介者</p>
<p>抽象中介者定义了各同事之间的通信接口</p>
</li>
<li><p>ConcreteMediator 具体中介者</p>
<p>协调各同事之间的通信写作行为，同时持有同事对象的引用</p>
</li>
<li><p>Colleague 抽象同事类</p>
<p>定义各个同时的方法，同时持有中介者对象的引用，同事之间可以通过持有的中介者对象的引用进行相互通信写作</p>
</li>
<li><p>ConcreteColleague 具体同事类</p>
<p>具体同事类实现了抽象同事类的方法</p>
</li>
</ul>
<h2 id="一般实现"><a href="#一般实现" class="headerlink" title="一般实现"></a>一般实现</h2><p>抽象中介者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(Colleague colleague)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象同事</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> Mediator mediator;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">		<span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (mediator != <span class="keyword">null</span>) &#123;</span><br><span class="line">			mediator.changeState(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象同事持有中介者对象 mediator，并定义了 operation 函数</p>
<p>具体同事 ColleagueA</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColleagueA</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ColleagueA</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(mediator);</span><br><span class="line">		<span class="comment">// TODO Auto-generated constructor stub</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ColleagueB has changed its state!!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在本 Demo 中，只有 ColleagueA 和 ColleagueB，ColleagueA 和 ColleagueB 通过中介者沟通，ColleagueA 收到 ColleagueB 状态发生变化后，在 operation 函数中输出提示字符串，ColleagueB 也是如此。</p>
<p>具体中介者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> Colleague colleagueA;</span><br><span class="line">	<span class="keyword">private</span> Colleague colleagueB;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueA</span><span class="params">(ColleagueA colleagueA)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.colleagueA = colleagueA;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setColleagueB</span><span class="params">(ColleagueB colleagueB)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.colleagueB = colleagueB;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> ColleagueA &amp;&amp; colleagueB != <span class="keyword">null</span>) &#123;</span><br><span class="line">			colleagueB.operation();</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (colleague <span class="keyword">instanceof</span> ColleagueB &amp;&amp; colleagueA != <span class="keyword">null</span>) &#123;</span><br><span class="line">			colleagueA.operation();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ConcreteMediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line">ColleagueA colleagueA = <span class="keyword">new</span> ColleagueA(mediator);</span><br><span class="line">ColleagueB colleagueB = <span class="keyword">new</span> ColleagueB(mediator);</span><br><span class="line">mediator.setColleagueA(colleagueA);</span><br><span class="line">mediator.setColleagueB(colleagueB);</span><br><span class="line"></span><br><span class="line">colleagueA.changeState();</span><br><span class="line">colleagueB.changeState();</span><br></pre></td></tr></table></figure>

<p>程序运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ColleagueA has changes its state!!</span><br><span class="line">ColleagueB has changed its state!!</span><br></pre></td></tr></table></figure>

<h2 id="中介者在-Android-中的使用"><a href="#中介者在-Android-中的使用" class="headerlink" title="中介者在 Android 中的使用"></a>中介者在 Android 中的使用</h2><p>此部分参考了《Android源码设计模式 实战与分析》一书。Android 源码中实现锁屏功能的源码 KeyguardViewMediator.java 就是中介者模式。锁屏对应移动设备的用户来说，只是一个很简单的操作，点下 按钮即可，但是对于系统来说，锁屏功能的实现会涉及很多子系统。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyguardViewMediator</span> <span class="keyword">extends</span> <span class="title">SystemUI</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> AlarmManager mAlarmManager;</span><br><span class="line">    <span class="keyword">private</span> AudioManager mAudioManager;</span><br><span class="line">    <span class="keyword">private</span> StatusBarManager mStatusBarManager;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> PowerManager mPM;</span><br><span class="line">    <span class="keyword">private</span> TrustManager mTrustManager;</span><br><span class="line">    <span class="keyword">private</span> StatusBarKeyguardViewManager mStatusBarKeyguardViewManager;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上是 KeyguardViewMediator 类的部分代码，有很多其他的系统功能对象，这些对象需要组合在一起才能完成锁屏状态的各种操作，以解锁时播放声音为例，KeyguardViewMediator 函数 playSounds 完成解锁时声音的播放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">playSounds</span><span class="params">(<span class="keyword">boolean</span> locked)</span> </span>&#123;</span><br><span class="line">        playSound(locked ? mLockSoundId : mUnlockSoundId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">playSound</span><span class="params">(<span class="keyword">int</span> soundId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (soundId == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">final</span> ContentResolver cr = mContext.getContentResolver();</span><br><span class="line">        <span class="keyword">if</span> (Settings.System.getInt(cr, Settings.System.LOCKSCREEN_SOUNDS_ENABLED, <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line"></span><br><span class="line">            mLockSounds.stop(mLockSoundStreamId);</span><br><span class="line">            <span class="comment">// Init mAudioManager</span></span><br><span class="line">            <span class="keyword">if</span> (mAudioManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">                <span class="keyword">if</span> (mAudioManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">                mUiSoundsStreamType = mAudioManager.getUiSoundsStreamType();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mUiOffloadThread.submit(() -&gt; &#123;</span><br><span class="line">                <span class="comment">// If the stream is muted, don't play the sound</span></span><br><span class="line">                <span class="keyword">if</span> (mAudioManager.isStreamMute(mUiSoundsStreamType)) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> id = mLockSounds.play(soundId,</span><br><span class="line">                        mLockSoundVolume, mLockSoundVolume, <span class="number">1</span><span class="comment">/*priortiy*/</span>, <span class="number">0</span><span class="comment">/*loop*/</span>, <span class="number">1.0f</span><span class="comment">/*rate*/</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    mLockSoundStreamId = id;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，KeyguardViewMediator 作为协调者，通过调用 没AudioManager 的相关接口完成了解锁时声音播放的操作。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>中介者模式的有点十分明显，将多对多转换为一对多，减小了同事类之间的耦合，使得同事类之间可以独立地使用，同事类的关系易于理解和维护。</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>一对多的关系可能会导致中介者责任过大，中介者出现异常可能会导致同事类之间的交互出现异常；中介者模式可能会被滥用，大多数场景中，同事类之间的关系不会复杂到网状结构，不需要引入中介者模式，如果强行使用中介者模式，不仅会增加设计的复杂，也会让原本简单的业务逻辑变得复杂。</p>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><p>对象之间的交互操作很多，且这些操作存在彼此依赖，当这些依赖关系已经达到网状时，为了防止一个对象的修改影响其他对象之间的相互操作，可以采用中介者模式减少或者降低耦合关系。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/05/design-pattern-watcher/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/05/design-pattern-watcher/" itemprop="url">观察者模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-05T10:06:21+08:00">
                2020-05-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index">
                    <span itemprop="name">设计模式</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h1><h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>相对于其他模式，观察者模式很容易理解，观察者模式又叫发布订阅模式，定义了被观察者和观察者之间一对多的关系，被观察者由于某种原因发生变化时，所有的观察者都会根据这种变化做出对应的行为</p>
<h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/observe.png" alt=""></p>
<p>从 UML 可以看到观察者模式涉及到四个角色：</p>
<ul>
<li><p>Obserable 抽象被观察者角色</p>
<p>抽象被观察者角色持有观察者实例的集合，并提供添加和删除观察者的接口</p>
</li>
<li><p>ConcreteObservable 具体被观察者角色</p>
<p>具体被观察者角色负责维护被观察者的状态，当状态发生变化时通知观察者执行 update 方法</p>
</li>
<li><p>Observer 抽象观察者角色</p>
<p>定义观察者需要实现的接口，当具体被观察者维护的状态发生变化时，将通过此接口通知观察者</p>
</li>
<li><p>ConcreteObserver 具体观察者角色</p>
<p>实现抽象观察者定义的接口，处理具体被观察者角色发出的状态变化</p>
</li>
</ul>
<p>在日常开发中，往往不会将抽象被观察者和具体被观察者进行区分，最后就只有 被观察者角色，抽象观察者角色，具体观察者角色。</p>
<p><img src="https://raw.githubusercontent.com/rockstore/images/master/design_pattern/simple-observer.png" alt=""></p>
<h2 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h2><p>抽象观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverA</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ConcreteObserverA updates"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverB</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ConcreteObserverB updates"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>抽象被观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">		observers.add(observer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">		observers.remove(observer);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> ArrayList&lt;Observer&gt; <span class="title">getObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> observers;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体被观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> state = <span class="number">0</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">		state = newState;</span><br><span class="line">		change();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Observer observer : getObservers()) &#123;</span><br><span class="line">			observer.update();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span> </span>&#123;</span><br><span class="line">		ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">		concreteSubject.add(<span class="keyword">new</span> ConcreteObserverA());</span><br><span class="line">		concreteSubject.add(<span class="keyword">new</span> ConcreteObserverB());</span><br><span class="line">		concreteSubject.setState(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ConcreteSubject concreteSubject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">concreteSubject.add(<span class="keyword">new</span> ConcreteObserverA());</span><br><span class="line">concreteSubject.add(<span class="keyword">new</span> ConcreteObserverB());</span><br><span class="line">concreteSubject.setState(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>测试代码运行结果</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ConcreteObserverA updates</span><br><span class="line">ConcreteObserverB updates</span><br></pre></td></tr></table></figure>

<p>上述的观察者模式简单实现是我们纯手打，其实 jdk 也已经提供了观察者框架，很简洁很简单。jdk 中的观察者模式需要我们关注两个类：</p>
<ul>
<li><p>Observer</p>
<p>抽象观察者，定义了如下的观察者接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   o     the observable object.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   arg   an argument passed to the &lt;code&gt;notifyObservers&lt;/code&gt;</span></span><br><span class="line"><span class="comment">     *                 method.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Observable</p>
<p>被观察者，其实我们可以将其理解为前面提到的抽象被观察者角色，里面提供了观察者添加和删除方法，并保存了具体观察者的集合。</p>
</li>
</ul>
<p>接下来我们使用 jdk 提供的框架实现一个简单的观察者 Demo。</p>
<p>首先定义具体观察者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverA</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ObserverA updates:"</span> + o + <span class="string">" args:"</span> + arg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverB</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"ObserverA updates:"</span> + o + <span class="string">" args:"</span> + arg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>定义具体被观察者角色，具体</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyObservable</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		setChanged();</span><br><span class="line">		notifyObservers(<span class="string">"1234"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyObservable myObservable = <span class="keyword">new</span> MyObservable();</span><br><span class="line">myObservable.addObserver(<span class="keyword">new</span> ObserverA());</span><br><span class="line">myObservable.addObserver(<span class="keyword">new</span> ObserverB());</span><br><span class="line">myObservable.update();</span><br></pre></td></tr></table></figure>

<p>运行结果如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ObserverA updates:com.apm.windseeker.observer_injava.MyObservable@<span class="number">15</span>db9742 args:<span class="number">1234</span></span><br><span class="line">ObserverA updates:com.apm.windseeker.observer_injava.MyObservable@<span class="number">15</span>db9742 args:<span class="number">1234</span></span><br></pre></td></tr></table></figure>

<p>相较于我们自己实现的观察者， jdk 观察者框架在通知具体观察者进行更新时，将具体被观察者的对象一起传了过去。感兴趣的同学可以看下 jdk 观察者的实现，代码很少，在下面的分析中还会涉及到 jdk 中的观察者框架</p>
<h2 id="推模型和拉模型"><a href="#推模型和拉模型" class="headerlink" title="推模型和拉模型"></a>推模型和拉模型</h2><p>在使用观察者模式的时候，我们很少去关注观察者模式使用的是推模型还是拉模型，因为我们已经习惯于使用推模型了，什么是推模型，什么是拉模型呢？</p>
<p>推模型，拉模型是相对于被观察者来说的，如果被观察者在通知观察者时，直接将内容告知观察者，也就是在执行观察者的 update 方法时， update 里的参数就是被观察者需要告知观察者的内容，这样的实现模型叫做推模型，在推模型中，观察者仅仅是被动接受被观察者传过来的参数，使用推模型的前提是我们能确保所有的观察者都关注同样的内容。如果不同观察者关注的内容不一样，那该怎么处理呢，看下面的一个场景</p>
<p>有这样一个系统，系统中包含传感器以及子模块，传感器负责收集空气湿度，温度等信息，不同的子模块可会根据不同的状态做出不同的处理：子模块 A 仅仅是输出当前湿度信息，子模块 B 在温度低于 30 摄氏度时仅仅是输出温度信息，高于 30 摄氏度时需要输出风速信息。</p>
<p>不同模块需要的信息不同，且相同模块在不同状态下需要的信息也不相同，推模型显然已经无法满足需求，先看下实现</p>
<p>抽象子模块：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Submodule</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Sensor sensor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>传感器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.apm.windseeker.observer_injava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sensor</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 温度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> temperature;</span><br><span class="line">	<span class="comment">// 湿度</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> humidity;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">private</span> ArrayList&lt;Submodule&gt; submodules = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubmodule</span><span class="params">(Submodule submodule)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (submodule != <span class="keyword">null</span>) &#123;</span><br><span class="line">			submodules.add(submodule);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSubmodule</span><span class="params">(Submodule submodule)</span> </span>&#123;</span><br><span class="line">		submodules.remove(submodule);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifySubmodule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (Submodule submodule : submodules) &#123;</span><br><span class="line">			submodule.update(<span class="keyword">this</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		notifySubmodule();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateTemperature</span><span class="params">(<span class="keyword">int</span> newTemperature)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (temperature != newTemperature) &#123;</span><br><span class="line">			temperature = newTemperature;</span><br><span class="line">			changeState();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateHumidity</span><span class="params">(<span class="keyword">int</span> newHumidity)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (humidity != newHumidity) &#123;</span><br><span class="line">			humidity = newHumidity;</span><br><span class="line">			changeState();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> temperature;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> humidity;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子模块 A</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmoduleA</span> <span class="keyword">implements</span> <span class="title">Submodule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Sensor sensor)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		System.out.println(<span class="string">"Sensor state changes, current humidity:"</span> + sensor.getHumidity());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子模块 B</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmoduleB</span> <span class="keyword">implements</span> <span class="title">Submodule</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Sensor sensor)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">		<span class="keyword">if</span> (sensor.getTemperature() &lt; <span class="number">30</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"temperature &lt; 30, current temperature:"</span> + sensor.getTemperature());</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			System.out.println(<span class="string">"temperature &gt;= 30, current temperature:"</span> + sensor.getTemperature() + <span class="string">",current humidity:"</span> + sensor.getHumidity());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Sensor sensor = <span class="keyword">new</span> Sensor();</span><br><span class="line">sensor.addSubmodule(<span class="keyword">new</span> SubmoduleB());</span><br><span class="line">sensor.addSubmodule(<span class="keyword">new</span> SubmoduleA());</span><br><span class="line">sensor.updateHumidity(<span class="number">1</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">sensor.updateTemperature(<span class="number">20</span>);</span><br><span class="line">System.out.println();</span><br><span class="line">sensor.updateTemperature(<span class="number">40</span>);</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">temperature &lt; <span class="number">30</span>, current temperature:<span class="number">0</span></span><br><span class="line">Sensor state changes, current humidity:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">temperature &lt; <span class="number">30</span>, current temperature:<span class="number">20</span></span><br><span class="line">Sensor state changes, current humidity:<span class="number">1</span></span><br><span class="line"></span><br><span class="line">temperature &gt;= <span class="number">30</span>, current temperature:<span class="number">40</span>,current humidity:<span class="number">1</span></span><br><span class="line">Sensor state changes, current humidity:<span class="number">1</span></span><br></pre></td></tr></table></figure>



<p>以上便是拉模型的实现，可以发现，拉模型在定义抽象观察者 Submodule 的 update 函数时，并没有传递具体的状态参数，而是直接将被观察者对象 Sensor 的实例传了过去。Sensor 内部定义 get 函数以获取 Sensor 当前的状态。观察者 Submodule 收到 被观察者的通知后，根据自己的需求，主动到 Sensor 通过 get 函数拉取参数。这便是拉模型的实现。</p>
<p>其实总结起来，拉模型相较于推模型最大的变化就是执行 update 函数时传递参数的不同，推模型传递的是具体的参数，而拉模型传递的是被观察者对象的实例。</p>
<p>前面在使用 jdk 提供的观察者模式框架时， update 方法有两个参数，一个是被观察者本身，一个是 object 类型的数据（标准说法叫 DTO (数据传输对象)），使用这种方式实现观察者模式，不同的观察者可以根据自己的需求完成不同的操作，故 jdk 中的观察者模式框架既支持推模型，又支持拉模型</p>
<p>拉模型的好处是可以理解了，但是拉模型也有一个明显的弊端，每个观察者都会拿到被观察者的对象引用，被观察者需要进行合理的接口设计以及访问控制，防止观察者修对被观察者进行恶意修改</p>
<h2 id="观察者模式在-Android-中的使用"><a href="#观察者模式在-Android-中的使用" class="headerlink" title="观察者模式在 Android 中的使用"></a>观察者模式在 Android 中的使用</h2><p>说起 Android 中观察者模式的使用，</p>
<h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><ul>
<li><p>观察者消息响应方式</p>
<p>在前面的示例代码中，被观察者通知观察者使用循环的方式逐个通知观察者，逐个执行观察者的 update 方法。在实际业务中，有些观察者的 update 方法可能是一个很耗时的逻辑，如果是这样，后续观察者的 update 方法可能会被阻塞，被观察者的 notify 方法的执行时间可能被拉长。故需要根据实际的业务场景好好设计观察者的响应方式。通常可以使用两种方式优化观察者的响应：多线程技术，观察者执行 update 方法时，新开线程，降低被观察者的阻塞时间；缓存技术，为正在执行响应的观察者准备足够的资源，让观察者快速执行返回。</p>
</li>
<li><p>是否需要全部通知</p>
<p>每次被观察者状态的改变都需要全部通知观察者，所有的观察者都需要执行 update 方法。这个地方有一个地方可以优化点：是否任何状态的改变都需要通知观察者。在实现具体被观察者的 notifiy 时，可以根据实际场景，判断是否需要通知，提高效率。</p>
</li>
</ul>
<h2 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h2><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>观察者和被观察者之间时抽象耦合，这样无论是观察者还是被观察者，都易于扩展</p>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>被观察者和观察者之间是一对多的关系，调试观察者比较复杂；被观察者在通知观察者时，默认使用顺序的方式通知观察者，如果不优化观察者的执行方式，一个观察者阻塞会导致系统阻塞，影响系统效率</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>观察者模式是被观察者和观察者之间一对多的关系，被观察者保存了观察者的集合，当观察者状态发生变化时，会通知观察者集合中的所有观察者</li>
<li>观察者模式存在推模型和拉模型，相对于推模型，拉模型允许观察者根据自己的需求从被观察者获取自身需求的信息</li>
<li>观察者模式在实现时需要考虑到观察者的响应方式，防止观察者执行响应导致的阻塞</li>
<li>对于被观察者状态的改变，可以考虑是否需要通知观察者，提高效率</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/go/page/2/">2</a><a class="page-number" href="/go/page/3/">3</a><a class="extend next" rel="next" href="/go/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">rockstore</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/go/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/go/categories/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/go/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rockstore</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/go/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/go/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/go/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/go/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
