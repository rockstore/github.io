<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/go/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/go/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/go/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/go/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/go/images/favicon-32x32-next.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/go/images/favicon-16x16-next.ico?v=5.1.4">


  <link rel="mask-icon" href="/go/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Rock">
<meta property="og:url" content="https://rockstore.github.io/go/index.html">
<meta property="og:site_name" content="Rock">
<meta property="article:author" content="rockstore">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/go/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://rockstore.github.io/go/"/>





  <title>Rock</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/go/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Rock</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/go/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/go/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/go/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/21/android-framework-component-jobservice-invoke/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/21/android-framework-component-jobservice-invoke/" itemprop="url">JobService 被调度流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-21T00:21:59+08:00">
                2020-05-21
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">系统组件</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/JobService/" itemprop="url" rel="index">
                    <span itemprop="name">JobService</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章分析了 JobService 的启动流程，由于本文</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/20/android-framework-common-getservice/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/20/android-framework-common-getservice/" itemprop="url">getSystemService 的执行流程简单分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T17:23:07+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E9%80%9A%E7%94%A8/" itemprop="url" rel="index">
                    <span itemprop="name">通用</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>这个话题流程不复杂，在平时分析 framework 源码的过程中，如果知道了系统服务的实现类，这一流程其实不用太关注，但本着知其所以然的态度，还是分析记录一下。</p>
<h2 id="详细流程"><a href="#详细流程" class="headerlink" title="详细流程"></a>详细流程</h2><p>详细流程还是从一个例子开始说起</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br></pre></td></tr></table></figure>

<p>这就是我们平时调用的方法，context.getSystemService(Context.JOB_SCHEDULER_SERVICE) 方法最终调用了 ContextImpl 实例的 getSystemService(Context.JOB_SCHEDULER_SERVICE) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再跟踪一下 SystemServiceRegistry.getSystemService 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">getSystemService</span><span class="params">(ContextImpl ctx, String name)</span> </span>&#123;</span><br><span class="line">  ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name);</span><br><span class="line">  <span class="keyword">return</span> fetcher != <span class="keyword">null</span> ? fetcher.getService(ctx) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceFetcher 是 SystemServiceRegistry 的一个内部类，它的实例保存在一个 HashMap 的结构中，键为服务字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =</span><br><span class="line">            <span class="keyword">new</span> HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;();</span><br></pre></td></tr></table></figure>

<p>继续跟踪一下 ServiceFetcher 的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ServiceFetcher 是一个接口，提供了一个 getService 函数。SystemServiceRegistry 有一个静态块，静态块内部执行服务的注册工作，以便其他应用可以通过 getSystemService 获取服务的引用，这里我们需要关注静态块内部的注册函数 registerService </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">  SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">  SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>registerService 函数接受三个参数，分别是服务名，实现服务接口的类 class 以及一个 ServiceFetcher 实例。这里有两个 Map ，分别保存了服务类到服务名的映射以及服务名到 serviceFetcher 的映射。</p>
<p>ServiceFetcher 类在 SystemServiceRegistry 类中有多个子类实现，这里就不一一列举，子类添加了 create 方法，具体会在后面进行分析。</p>
<h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p>以 JobSchedulerService 说明 registerService 函数的执行过程，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">registerService(Context.JOB_SCHEDULER_SERVICE, JobScheduler<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">                <span class="title">new</span> <span class="title">StaticServiceFetcher</span>&lt;<span class="title">JobScheduler</span>&gt;() </span>&#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> JobScheduler <span class="title">createService</span><span class="params">()</span> <span class="keyword">throws</span> ServiceNotFoundException </span>&#123;</span><br><span class="line">                    IBinder b = ServiceManager.getServiceOrThrow(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> JobSchedulerImpl(IJobScheduler.Stub.asInterface(b));</span><br><span class="line">                  &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>这里第三个参数 ServiceFetcher 的子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticServiceFetcher</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">ServiceFetcher</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T mCachedInstance;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> T <span class="title">getService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (StaticServiceFetcher.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mCachedInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          mCachedInstance = createService();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ServiceNotFoundException e) &#123;</span><br><span class="line">          onServiceNotFound(e);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> mCachedInstance;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> T <span class="title">createService</span><span class="params">()</span> <span class="keyword">throws</span> ServiceNotFoundException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>StaticServiceFetcher 内部 mCachedInstance 缓存了服务的实例，调用 getService 时如果 mCachedInstance 为空，则会调用 createService 方法进行创建。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文的逻辑比较简单，相信通过上面的分析，已经对 getSystemService 的流程有了比较清晰的认识，这部分的内容是比较通用的，凡是涉及到 getSystemService 都会走这样一个流程。</p>
<p>其实我们目前分析的 getSystemService 流程只是简单分析了应用端的使用流程，framework 层的流程后面有时间会继续分析。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/20/android-framework-component-jobservice-flow/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/20/android-framework-component-jobservice-flow/" itemprop="url">JobService 启动流程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-20T01:04:57+08:00">
                2020-05-20
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">系统组件</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/JobService/" itemprop="url" rel="index">
                    <span itemprop="name">JobService</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上篇文章已经简单分析了 JobService 的基本结构以及其提供的方法，本文的目的是分析 JobService 是如何被启动。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>JobService 的启动逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JobScheduler jobScheduler = (JobScheduler) context.getSystemService(Context.JOB_SCHEDULER_SERVICE);</span><br><span class="line">JobInfo.Builder builder = <span class="keyword">new</span> JobInfo.Builder(jobId,</span><br><span class="line">                <span class="keyword">new</span> ComponentName(context.getPackageName(), PushJobService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">...... <span class="comment">// 配置 JobInfo 信息</span></span><br><span class="line">JobInfo jobInfo = builder.build();</span><br><span class="line"><span class="keyword">int</span> result = jobScheduler.schedule(jobInfo);</span><br></pre></td></tr></table></figure>

<p>JobScheduler 在 framework 层的实现类是 JobSchedulerService ，由于 Binder 进程间通信，就直接忽略掉进程间的通信细节，直接分析 JobSchedulerService 。JobSchedulerService.java 位于</p>
<p>framework/services/core/java/com/android/server/job/JobSchedulerService.java</p>
<p>接下来我们就分析启动函数 schedule </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">schedule</span><span class="params">(JobInfo job)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> JobSchedulerService.<span class="keyword">this</span>.scheduleAsPackage(job, <span class="keyword">null</span>, uid, <span class="keyword">null</span>, userId,</span><br><span class="line">                                                      <span class="keyword">null</span>);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来会调用 JobSchdulerService 的 scheduleAsPackage 方法，虽然方法提有点长，但是逻辑还是很清晰的，我就直接贴上代码了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">scheduleAsPackage</span><span class="params">(JobInfo job, JobWorkItem work, <span class="keyword">int</span> uId, String packageName,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> userId, String tag)</span> </span>&#123;</span><br><span class="line">        ......</span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">          	<span class="comment">// 检测 JobInfo 描述的 JobService 是否已经在 mJobs 存在</span></span><br><span class="line">            <span class="keyword">final</span> JobStatus toCancel = mJobs.getJobByUidAndJobId(uId, job.getId());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (work != <span class="keyword">null</span> &amp;&amp; toCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Fast path: we are adding work to an existing job, and the JobInfo is not</span></span><br><span class="line">                <span class="comment">// changing.  We can just directly enqueue this work in to the job.</span></span><br><span class="line">                <span class="keyword">if</span> (toCancel.getJob().equals(job)) &#123;</span><br><span class="line"></span><br><span class="line">                    toCancel.enqueueWorkLocked(ActivityManager.getService(), work);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// If any of work item is enqueued when the source is in the foreground,</span></span><br><span class="line">                    <span class="comment">// exempt the entire job.</span></span><br><span class="line">                    toCancel.maybeAddForegroundExemption(mIsUidActivePredicate);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">return</span> JobScheduler.RESULT_SUCCESS;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">						<span class="comment">// 根据 Job 信息创建 JobStatus</span></span><br><span class="line">            JobStatus jobStatus = JobStatus.createFromJobInfo(job, uId, packageName, userId, tag);</span><br><span class="line">            jobStatus.maybeAddForegroundExemption(mIsUidActivePredicate);</span><br><span class="line">            ......</span><br><span class="line">            <span class="comment">// This may throw a SecurityException.</span></span><br><span class="line">            jobStatus.prepareLocked(ActivityManager.getService());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (toCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                cancelJobImplLocked(toCancel, jobStatus, <span class="string">"job rescheduled by app"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (work != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If work has been supplied, enqueue it into the new job.</span></span><br><span class="line">                jobStatus.enqueueWorkLocked(ActivityManager.getService(), work);</span><br><span class="line">            &#125;</span><br><span class="line">          	<span class="comment">// 开始跟踪 JobService</span></span><br><span class="line">            startTrackingJobLocked(jobStatus, toCancel);</span><br><span class="line">            StatsLog.write_non_chained(StatsLog.SCHEDULED_JOB_STATE_CHANGED,</span><br><span class="line">                    uId, <span class="keyword">null</span>, jobStatus.getBatteryName(),</span><br><span class="line">                    StatsLog.SCHEDULED_JOB_STATE_CHANGED__STATE__SCHEDULED,</span><br><span class="line">                    JobProtoEnums.STOP_REASON_CANCELLED);</span><br><span class="line">            <span class="comment">// 如果当前的系统状态满足了 JobService 的运行条件，则会将会将 JobSerice 方法等待队列中并尝						// 试运行</span></span><br><span class="line">            <span class="keyword">if</span> (isReadyToBeExecutedLocked(jobStatus)) &#123;</span><br><span class="line">                mJobPackageTracker.notePending(jobStatus);</span><br><span class="line">                addOrderedItem(mPendingJobs, jobStatus, mEnqueueTimeComparator);</span><br><span class="line">                maybeRunPendingJobsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> JobScheduler.RESULT_SUCCESS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>scheduleAsPackage 的逻辑很清晰，接下来将会详细分析这个函数</p>
<h3 id="检测-JobInfo-对应的-JobService-是否已存在"><a href="#检测-JobInfo-对应的-JobService-是否已存在" class="headerlink" title="检测 JobInfo 对应的 JobService 是否已存在"></a>检测 JobInfo 对应的 JobService 是否已存在</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> JobStatus toCancel = mJobs.getJobByUidAndJobId(uId, job.getId());</span><br><span class="line"><span class="keyword">if</span> (work != <span class="keyword">null</span> &amp;&amp; toCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// Fast path: we are adding work to an existing job, and the JobInfo is not</span></span><br><span class="line">  <span class="comment">// changing.  We can just directly enqueue this work in to the job.</span></span><br><span class="line">  <span class="keyword">if</span> (toCancel.getJob().equals(job)) &#123;</span><br><span class="line"></span><br><span class="line">    toCancel.enqueueWorkLocked(ActivityManager.getService(), work);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If any of work item is enqueued when the source is in the foreground,</span></span><br><span class="line">    <span class="comment">// exempt the entire job.</span></span><br><span class="line">    toCancel.maybeAddForegroundExemption(mIsUidActivePredicate);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JobScheduler.RESULT_SUCCESS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mJobs 是 JobStore 的实例，保存 JobStatus 集合，在 JobStore 内部，JobStatus 按照 uid 进行分类，如果 getJobByUidAndJobId 返回不为空，表示 JobService 对应的 JobStatus 已经存在，直接将 work 添加到队列等待调度执行。</p>
<h3 id="根据-JobInfo-创建-JobStatus"><a href="#根据-JobInfo-创建-JobStatus" class="headerlink" title="根据 JobInfo 创建 JobStatus"></a>根据 JobInfo 创建 JobStatus</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据 Job 信息创建 JobStatus</span></span><br><span class="line">JobStatus jobStatus = JobStatus.createFromJobInfo(job, uId, packageName, userId, tag);</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (toCancel != <span class="keyword">null</span>) &#123;</span><br><span class="line">  cancelJobImplLocked(toCancel, jobStatus, <span class="string">"job rescheduled by app"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (work != <span class="keyword">null</span>) &#123;</span><br><span class="line">  <span class="comment">// If work has been supplied, enqueue it into the new job.</span></span><br><span class="line">  jobStatus.enqueueWorkLocked(ActivityManager.getService(), work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 mJobs 中未查询到对应的 JobStatus 信息后，调用 createFromJobInfo 创建 JobStatus 实例。当逻辑走到这个位置时，JobService 会被重新调度，故需要执行 cancelJobImplLocked 方法，取消之前调度的 JobService ，取消的过程中，如果有任务在执行，正在执行的任务也会被取消。</p>
<h3 id="跟踪-JobService"><a href="#跟踪-JobService" class="headerlink" title="跟踪 JobService"></a>跟踪 JobService</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startTrackingJobLocked</span><span class="params">(JobStatus jobStatus, JobStatus lastJob)</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  jobStatus.enqueueTime = sElapsedRealtimeClock.millis();</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">boolean</span> update = mJobs.add(jobStatus);</span><br><span class="line">  <span class="keyword">if</span> (mReadyToRock) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mControllers.size(); i++) &#123;</span><br><span class="line">      StateController controller = mControllers.get(i);</span><br><span class="line">      <span class="keyword">if</span> (update) &#123;</span><br><span class="line">        controller.maybeStopTrackingJobLocked(jobStatus, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      controller.maybeStartTrackingJobLocked(jobStatus, lastJob);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>mJobs 执行 add 方法时，如果 JobStatus 已经存在，则先删除原来的 JobStatus 再将传入的 JobStatus 对象添加到 mJobs 中，并返回 true。接下来的部分就是承上启下了，这里出现了 StateController ，StatueController 是一个抽象类，StateController 的子类负责跟踪自己负责的任务，通知 JobSchedulerService 对任务进行调度或者停止这些任务，这样的解释听起来有点空洞，让我们看下 StateController 具体有哪些子类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">com.android.server.job.controllers.BatteryController;</span><br><span class="line">com.android.server.job.controllers.BackgroudJobsController;</span><br><span class="line">com.android.server.job.controllers.StorageController;</span><br><span class="line">com.android.server.job.controllers.ContentObserverController;</span><br><span class="line">com.android.server.job.controllers.DeviceIdleJobsController;</span><br><span class="line">com.android.server.job.controllers.IdleController;</span><br><span class="line">com.android.server.job.controllers.ConnectivityController;</span><br><span class="line">com.android.server.job.controllers.TimeController;</span><br></pre></td></tr></table></figure>

<p>这些子类分别负责监控系统的某一类事件，当这些事件满足了 JobService 的运行条件时，就会调度 JobService，让其运行。假设我们在构建 JobInfo 时使用如下逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JobInfo.Builder builder = <span class="keyword">new</span> JobInfo.Builder(jobId,</span><br><span class="line">                <span class="keyword">new</span> ComponentName(context.getPackageName(), XXXJobService<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>()))</span>;</span><br><span class="line">builder.setRequiresCharging(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>

<p>跟踪一下 BatteryController 的 maybeStartTrackingJobLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">maybeStartTrackingJobLocked</span><span class="params">(JobStatus taskStatus, JobStatus lastJob)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (taskStatus.hasPowerConstraint()) &#123;</span><br><span class="line">    mTrackedTasks.add(taskStatus);</span><br><span class="line">    taskStatus.setTrackingController(JobStatus.TRACKING_BATTERY);</span><br><span class="line">    taskStatus.setChargingConstraintSatisfied(mChargeTracker.isOnStablePower());</span><br><span class="line">    taskStatus.setBatteryNotLowConstraintSatisfied(mChargeTracker.isBatteryNotLow());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先执行 hasPowerConstraint() 判断 JobStatus 是否有和耗电相关的限制，继续跟踪一下 hasPowerConstraint() 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasPowerConstraint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (requiredConstraints&amp;(CONSTRAINT_CHARGING|CONSTRAINT_BATTERY_NOT_LOW)) != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再回到刚才构建 JobInfo 时的逻辑</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">builder.setRequiresCharging(<span class="keyword">true</span>);</span><br><span class="line">-------------------------------------</span><br><span class="line"><span class="function"><span class="keyword">public</span> Builder <span class="title">setRequiresCharging</span><span class="params">(<span class="keyword">boolean</span> requiresCharging)</span> </span>&#123;</span><br><span class="line">  mConstraintFlags = (mConstraintFlags&amp;~CONSTRAINT_FLAG_CHARGING)</span><br><span class="line">    | (requiresCharging ? CONSTRAINT_FLAG_CHARGING : <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，执行 setRequiresCharging(true) 后，mConstraintFlags 中已经包含了 CONSTRAINT_FLAG_CHARGING 信息，故 hasPowerConstraints() 函数返回 true。maybeStartTrackingJobLocked() 剩余的逻辑就是将 JobStatus 实例添加到 BatteryController 的 mTrackedTasks 中并设置状态变量。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> jobScheduler.schedule 方法已经分析完了，其实总结起来，方法完成了一下两个方面的工作：</p>
<ul>
<li>将描述 JobService 信息的 JobInfo 信息保存到 JobSchedulerServices 的 mJobs 中</li>
<li>将 JobStatus 信息保存到负责监控某一类系统状态的 StateController 中，以便系统状态满足时系统调度 JobService</li>
</ul>
<p>下篇文章将会详细分析系统是如何对 JobService 进行调度的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/15/android-framework-componet-jobscheduler/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/15/android-framework-componet-jobscheduler/" itemprop="url">JobService 简单分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-15T23:36:04+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">系统组件</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/JobService/" itemprop="url" rel="index">
                    <span itemprop="name">JobService</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JobService 在之前做推送的时候遇到过，主要的作用基于给予系统的各种条件执行异步任务，实现保活功能。从本片开始，逐渐分析 JobService 。</p>
<h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>本文就不介绍 JobService 的使用了，因为网上这样的文章还是比较多的，有一点需要注意的是 JobService 组件需要在清单文件中使用以下权限保护 android:permission=”android.permission.BIND_JOB_SERVICE”，否则是不会被系统调用的。</p>
<p>JobService 的源码相当简单，这里我直接把源码贴出来</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">JobService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"JobService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PERMISSION_BIND =</span><br><span class="line">            <span class="string">"android.permission.BIND_JOB_SERVICE"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> JobServiceEngine mEngine;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mEngine == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mEngine = <span class="keyword">new</span> JobServiceEngine(<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> JobService.<span class="keyword">this</span>.onStartJob(params);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> JobService.<span class="keyword">this</span>.onStopJob(params);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mEngine.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">jobFinished</span><span class="params">(JobParameters params, <span class="keyword">boolean</span> wantsReschedule)</span> </span>&#123;</span><br><span class="line">        mEngine.jobFinished(params, wantsReschedule);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onStartJob</span><span class="params">(JobParameters params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">onStopJob</span><span class="params">(JobParameters params)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，JobService 就是是 Service ，并且提供了 bind 的方法进行绑定，只是添加了一下几个方法。</p>
<ul>
<li><p>jobFinished</p>
<p>应用执行完后主动调用，通知 JobScheduler ，wantsReschedule 表示执行完成后是否还需要系统继续规划执行，如果为 true ，则规划的执行时间受退避规则限制</p>
</li>
<li><p>onStartJob</p>
<p>子类需要实现此方法，以便在服务开始执行时执行自己的业务逻辑。此方法执行在应用的主线程，故需要考虑阻塞的问题；方法的返回值表示方法返回后服务是否还需要继续执行，true 表示需要继续执行，返回 true 后，如果想停止服务，则需要调用 jobFinished 函数或者系统当前的状态已经无法满足最开始设置的服务运行的条件。还有一点需要注意的时，在服务被即将被调用之前，系统将会获取应用的 WakeLock，WakeLock 会一直存在直到调用 jobFinished 或者 onStopJob</p>
</li>
<li><p>onStopJob</p>
<p>子类需要实现此方法，当系统认为当前系统的状态已经不满足服务的运行后，系统会主动调用此方法，调用此方法后，系统持有应用的锁 WakeLock 也会被释放。</p>
</li>
</ul>
<p>介绍完 JobService 的三个方法后，发现 JobService 的原理其实蛮简单，但是回过头再看下，这还有一个类 JobServiceEngine 未分析。JobServiceEngnie 类的实例是在 onBind 中新建的，JobService 的 onStartJob 和 onStopJob 方法也是在 JobServiceEngine 对应的方法中被调用的，onBind 方法最终返回 mEngine.getBinder() ，说明 JobServiceEngnie 的 getBinder 方法返回了 Binder 实例，用于进行进程通信。</p>
<p>这个 Binder 实例会被谁获取呢？当然是被 JobScheduler 获取了，JobScheduler 通过这个 Binder 实例进行跨进程通信，首先调用 JobServiceEngine 的 onStartJob 或者 onStopJob 方法，JobServiceEngine 会相应调用 JobService 的 onStartJob 和 onStopJob 方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文比较简单，梳理了 JobService 的结构，并大致了解了 JobService 中 onStartJob 和 onStopJob 方法的调用链，下篇文章将会详细分析 JobService onStartJob 和 onStopJob 方法被调用的整个 过程。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/15/android-framework-server-watchdog/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/15/android-framework-server-watchdog/" itemprop="url">WatchDog 原理分析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-15T22:38:01+08:00">
                2020-05-15
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E7%B3%BB%E7%BB%9F%E7%BB%84%E4%BB%B6/" itemprop="url" rel="index">
                    <span itemprop="name">系统组件</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>WatchDog 为系统的看门狗， 它会不断的查看它监控的线程的运行情况，如果发现异常，则会重启系统，之前排查问题的时候遇到过 WatchDog，但是一直没有分析 WatchDog ，趁着这两天有时间，把 WatchDog 的原理总结分析一下。</p>
<h2 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h2><p>WatchDog 是在 SystemServer 中启动的（后面会分析 SystemServer），SystemServer.java 文件位于</p>
<p>framework/services/java/com/android/server/SystemServer.java，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> SystemServer().run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面是 SystemServer 的 main 方法，直接新建了一个 SystemServer 对象，并执行了 run 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    ......</span><br><span class="line">    startOtherServices();</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">    Slog.e(<span class="string">"System"</span>, <span class="string">"******************************************"</span>);</span><br><span class="line">    Slog.e(<span class="string">"System"</span>, <span class="string">"************ Failure starting system services"</span>, ex);</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    traceEnd();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续跟踪 startOtherServices 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startOtherServices</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">final</span> Watchdog watchdog = Watchdog.getInstance();</span><br><span class="line">  watchdog.init(context, mActivityManagerService);</span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 startOtherServices 方法中，系统执行了对 WatchDog 的初始化，执行了 init 方法，WatchDog 的构造方法会在分析 WatchDog 的运行时进行分析。init 方法内部监听重启广播，这里不做分析。</p>
<p>到这里，我们已经执行了 WatchDog 的初始化，但是 WatchDog 究竟是一个什么样的类呢？WatchDog.java 位于</p>
<p>framework/services/java/com/android/server/WatchDog.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Watchdog</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;......&#125;</span><br></pre></td></tr></table></figure>

<p>WatchDog 继承 Thread ，会作为一个线程运行，要启动一个线程，需要执行其 start 方法，SystemServer 内部是如何启动 WatchDog 的呢？答案在 AMS，在 SystemServer 的 startOtherServices 方法中，AMS 这样启动 WatchDog</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mActivityManagerService.systemReady(() -&gt; &#123;</span><br><span class="line">  ......</span><br><span class="line">  Watchdog.getInstance().start();</span><br><span class="line">  ......</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>AMS 在执行 systemReady 时，会调用 start 方法启动 WatchDog。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><p>上一节分析了 WatchDog 的启动过程，本节分析 WatchDog 启动后干了什么，如何为系统看门的。start 方法直接启动了线程，在分析运行之前，需要清楚在新建 WatchDog 对象时都做了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Watchdog</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"watchdog"</span>);</span><br><span class="line">        <span class="comment">// Initialize handler checkers for each common thread we want to check.  Note</span></span><br><span class="line">        <span class="comment">// that we are not currently checking the background thread, since it can</span></span><br><span class="line">        <span class="comment">// potentially hold longer running operations with no guarantees about the timeliness</span></span><br><span class="line">        <span class="comment">// of operations there.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// The shared foreground thread is the main checker.  It is where we</span></span><br><span class="line">        <span class="comment">// will also dispatch monitor checks and do other work.</span></span><br><span class="line">        mMonitorChecker = <span class="keyword">new</span> HandlerChecker(FgThread.getHandler(),</span><br><span class="line">                <span class="string">"foreground thread"</span>, DEFAULT_TIMEOUT);</span><br><span class="line">        mHandlerCheckers.add(mMonitorChecker);</span><br><span class="line">        <span class="comment">// Add checker for main thread.  We only do a quick check since there</span></span><br><span class="line">        <span class="comment">// can be UI running on the thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(<span class="keyword">new</span> Handler(Looper.getMainLooper()),</span><br><span class="line">                <span class="string">"main thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">        <span class="comment">// Add checker for shared UI thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(UiThread.getHandler(),</span><br><span class="line">                <span class="string">"ui thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">        <span class="comment">// And also check IO thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(IoThread.getHandler(),</span><br><span class="line">                <span class="string">"i/o thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line">        <span class="comment">// And the display thread.</span></span><br><span class="line">        mHandlerCheckers.add(<span class="keyword">new</span> HandlerChecker(DisplayThread.getHandler(),</span><br><span class="line">                <span class="string">"display thread"</span>, DEFAULT_TIMEOUT));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Initialize monitor for Binder threads.</span></span><br><span class="line">        addMonitor(<span class="keyword">new</span> BinderThreadMonitor());</span><br><span class="line"></span><br><span class="line">        mOpenFdMonitor = OpenFdMonitor.create();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// See the notes on DEFAULT_TIMEOUT.</span></span><br><span class="line">        <span class="keyword">assert</span> DB ||</span><br><span class="line">                DEFAULT_TIMEOUT &gt; ZygoteConnectionConstants.WRAPPED_PID_TIMEOUT_MILLIS;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里出现了一个陌生的 HandlerChecker 类，HandlerChecker 类的构造函数穿了一个 Handler 的对象，这个类的主要作用是定期去检测 Handler 对象对应的线程的运行状态。这里出现了 FgThread，UiThread，IoThread 以及 DisplayThread ，可能比较好奇，这都是些什么线程呢？查看源码就会发现，这些线程最终都继承 HandlerThread ，他们的主要作用就是为使用者提供 Handler 以便运行 Runnable，举个例子，DisplayThread 主要供 WindowManager，DisplayManager，InputManager 使用，以便他们可以执行 Runnable 的任务。如果以上线程在被检测过程中发现执行超时或者无响应，由于以上线程是系统运行必须的线程，WatchDog 则会重启系统。接下来就来分析 WatchDog 是如何检测线程运行的状态。</p>
<p>WatchDog 继承 Thread，他的主要工作为放在 run 函数中，所以分析 WatchDog 的运行机制，就从 WatchDog 的 run 函数开始，为了便于阅读，将 run 函数分几段</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> List&lt;HandlerChecker&gt; blockedCheckers;</span><br><span class="line">            <span class="keyword">final</span> String subject;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> allowRestart;</span><br><span class="line">            ......</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> timeout = CHECK_INTERVAL;</span><br><span class="line">                <span class="comment">// Make sure we (re)spin the checkers that have become idle within</span></span><br><span class="line">                <span class="comment">// this wait-and-check interval</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;mHandlerCheckers.size(); i++) &#123;</span><br><span class="line">                    HandlerChecker hc = mHandlerCheckers.get(i);</span><br><span class="line">                    hc.scheduleCheckLocked();</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<p>在 WatchDog 的构造函数中，添加了若干 HandlerChecker 的对象，在执行循环检测时，首先遍历这些 HandlerChecker 对象的实例，并调用 scheduleCheckLocked 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleCheckLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  如果没有 monitor 需要监控且当前线程 alive，则当前的检测已经完成</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">if</span> (mMonitors.size() == <span class="number">0</span> &amp;&amp; mHandler.getLooper().getQueue().isPolling()) &#123;</span><br><span class="line">    <span class="comment">// If the target looper has recently been polling, then</span></span><br><span class="line">    <span class="comment">// there is no reason to enqueue our checker on it since that</span></span><br><span class="line">    <span class="comment">// is as good as it not being deadlocked.  This avoid having</span></span><br><span class="line">    <span class="comment">// to do a context switch to check the thread.  Note that we</span></span><br><span class="line">    <span class="comment">// only do this if mCheckReboot is false and we have no</span></span><br><span class="line">    <span class="comment">// monitors, since those would need to be executed at this point.</span></span><br><span class="line">    <span class="comment">// handler 当前未执行</span></span><br><span class="line">    mCompleted = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	之前的检测还未完成，不需要继续执行检测了。</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">  <span class="keyword">if</span> (!mCompleted) &#123;</span><br><span class="line">    <span class="comment">// we already have a check in flight, so no need</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  开始检测</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  mCompleted = <span class="keyword">false</span>;</span><br><span class="line">  mCurrentMonitor = <span class="keyword">null</span>;</span><br><span class="line">  mStartTime = SystemClock.uptimeMillis();</span><br><span class="line">  mHandler.postAtFrontOfQueue(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入  scheduleCheckLocked 函数时有一个判断 mHandler.getLooper().getQueue().isPolling()，isPolling 是 MessageQueue 类中的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPolling</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> isPollingLocked();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数判断当前线程是否正在从消息队列中获取消息以便执行相应的操作，返回 true 表示当前线程未被阻塞，正常运行，返回 false 表示当前线程已经被阻塞了。在新建 HandlerChecker 对象时，mCompleted = true，只有在开始检测的时候，mCompleted 才会被设置 false。</p>
<p>在开始检测时，mStartTime 首先记录了开始检测的时间，然后执行 mHandler.postAtFrontOfQueue(this)，接下来看下 HandlerChecker 的 run 函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> size = mMonitors.size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; size ; i++) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Watchdog.<span class="keyword">this</span>) &#123;</span><br><span class="line">      mCurrentMonitor = mMonitors.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    mCurrentMonitor.monitor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">synchronized</span> (Watchdog.<span class="keyword">this</span>) &#123;</span><br><span class="line">    mCompleted = <span class="keyword">true</span>;</span><br><span class="line">    mCurrentMonitor = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，需要先了解一下 Monitor ，Monitor 是定义在 WatchDog 中的一个接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Monitor</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要被 WatchDog 监控的组件只需要实现此接口，然后调用 WatchDog.getInstance().addMonitor() 函数添加即可，至于 monitor 函数监控的细节，后面会做分析。每一个 monitor 实例执行完 monitor 函数后，将 mCompleted 设置为 true，表示本次检测完成。</p>
<p>继续回到 WatchDog 的 run 函数进行分析</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> start = SystemClock.uptimeMillis();</span><br><span class="line"><span class="comment">// 等待 CHECK_INTERVAL 时间</span></span><br><span class="line"><span class="keyword">while</span> (timeout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  ......</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    wait(timeout);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">    Log.wtf(TAG, e);</span><br><span class="line">  &#125;</span><br><span class="line">  ......</span><br><span class="line">  timeout = CHECK_INTERVAL - (SystemClock.uptimeMillis() - start);</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line"><span class="keyword">if</span> (!fdLimitTriggered) &#123;</span><br><span class="line">  <span class="comment">// 获取 WatchDog 当前监控线程的状态，取所有线程的最差状态</span></span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> waitState = evaluateCheckerCompletionLocked();</span><br><span class="line">  <span class="keyword">if</span> (waitState == COMPLETED) &#123;</span><br><span class="line">    <span class="comment">// The monitors have returned; reset</span></span><br><span class="line">    <span class="comment">// 监控的线程都已经执行完 monitor 函数正常返回</span></span><br><span class="line">    waitedHalf = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITING) &#123;</span><br><span class="line">    <span class="comment">// still waiting but within their configured intervals; back off and recheck</span></span><br><span class="line">    <span class="comment">// 监控的线程正在执行 monitor 函数，还未返回，未超过最长等待时间的 1/2，继续检查</span></span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (waitState == WAITED_HALF) &#123;</span><br><span class="line">    <span class="comment">// 等待超过最长等待时间的 1/2 ，继续等待</span></span><br><span class="line">    <span class="keyword">if</span> (!waitedHalf) &#123;</span><br><span class="line">      <span class="comment">// We've waited half the deadlock-detection interval.  Pull a stack</span></span><br><span class="line">      <span class="comment">// trace and wait another half.</span></span><br><span class="line">      ArrayList&lt;Integer&gt; pids = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">      pids.add(Process.myPid());</span><br><span class="line">      ActivityManagerService.dumpStackTraces(<span class="keyword">true</span>, pids, <span class="keyword">null</span>, <span class="keyword">null</span>,</span><br><span class="line">                                             getInterestingNativePids());</span><br><span class="line">      waitedHalf = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待已超时，</span></span><br><span class="line">  blockedCheckers = getBlockedCheckersLocked();</span><br><span class="line">  subject = describeCheckersLocked(blockedCheckers);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  blockedCheckers = Collections.emptyList();</span><br><span class="line">  subject = <span class="string">"Open FD high water mark reached"</span>;</span><br><span class="line">&#125;</span><br><span class="line">allowRestart = mAllowRestart;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 系统记录相关日志并准备重启</span></span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>这里只保留了关键的代码，evaluateCheckerCompletionLocked 函数会计算所有线程的监控状态，返回最差的状态，WAITING 状态表示等待的时间少于最长等待时间的 1/2 ，会继续执行检测操作，WAIT_HALF 状态表示等待的时间已经大于最长等待时间的 1/2，会继续等待最长时间的 1/2。如果以上条件都不满足，则表示已经有线程等待超时，线程可能已经死掉了，由于 WatchDog 监控的都是系统运行的核心线程，如果等待超时，表示当前系统已经不稳定或者出现了异常，此时会进行系统重启。</p>
<h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><p>经过前面的分析，WatchDog 监控的流程已经又了一个清晰的认识，还有一个关键的问题没有解决：Monitor 接口里的 monitor 函数是如何监控线程是否是活的呢？</p>
<p>为了搞懂这个问题，需要找一个组件分析一下，就直接找 AMS 好了，看下 AMS 是如何实现 Monitor 接口的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">monitor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我勒个大叉，什么玩意儿，为什么就是一个同步呢？分析一下这个同步的意义，synchronized 的意义是获取当前对的锁，如果可以成功获取，那么当前线程就没有出现死锁，当前线程就是活的，如果迟迟无法获取，则当前线程已经出现了死锁，无法再正常运行。</p>
<p>可以再看下其他实现 Monitor 接口的组件，他们的实现思路也是通过获取锁的方式检测线程的状态，这里就不在举例子了。</p>
<p>突然觉得 Google 的大佬们实在太有创意了，不知道他们是如何想出这么棒的方法检测线程的死锁。。。。。。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>WatchDog 的实现十分巧妙，通过尝试获取线程相关锁的方式检测线程的状态，如果在规定的时间内可以正常获取锁，则表示线程运行状态正常，否则线程运行出现了死锁获取其他异常。</p>
<p>这里需要注意的是，WatchDog 会检测多个线程，只要有一个线程出现死锁异常，系统就会重启。</p>
<p>这里又学会了一个技能，用同步方法检测线程死锁，got it !!!</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/12/android-framework-battery-sys-promote/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/12/android-framework-battery-sys-promote/" itemprop="url">Android 系统尝试耗电的措施</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-12T23:16:31+08:00">
                2020-05-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为了提高电池寿命，减少耗电，Android 系统在不断进行优化，本文只是简单的记录 Android6.0 到 Android 9.0 系统为了优化耗电所做的工作，并没有做过多的分析，如果需要看相关的详情，可以到官网查看。</p>
<h2 id="Android-6"><a href="#Android-6" class="headerlink" title="Android 6"></a>Android 6</h2><h3 id="Doze-低耗电模式"><a href="#Doze-低耗电模式" class="headerlink" title="Doze 低耗电模式"></a>Doze 低耗电模式</h3><ul>
<li>进入条件</li>
</ul>
<p>用户未插接设备的电源，在屏幕关闭且静止的情况下，让设备在一段时间内保持不活动状态，那么设备就会进入低电耗模式</p>
<ul>
<li>限制</li>
</ul>
<p>在低电耗模式下，系统会尝试通过限制应用访问占用大量网络和 CPU 资源的服务来节省电量。它还会阻止应用访问网络，并延迟其作业、同步和标准闹钟。</p>
<p>（1）暂停访问网络。</p>
<p>（2）系统忽略唤醒锁定。</p>
<p>（3）标准 AlarmManager 闹钟（包括 setExact() 和 setWindow()）推迟到下一个维护期。</p>
<p>a）如果您需要设置在设备处于低电耗模式时触发的闹钟，请使用 setAndAllowWhileIdle() 或 setExactAndAllowWhileIdle()。</p>
<p>b）使用 setAlarmClock() 设置的闹钟将继续正常触发，系统会在这些闹钟触发之前不久退出低电耗模式。</p>
<p>（4）系统不执行 WLAN 扫描。</p>
<p>（5）系统不允许运行同步适配器。</p>
<p>（6）系统不允许运行 JobScheduler。</p>
<h3 id="应用待机模式"><a href="#应用待机模式" class="headerlink" title="应用待机模式"></a>应用待机模式</h3><ul>
<li>进入条件</li>
</ul>
<p>应用待机模式允许系统判定应用在用户未主动使用它时是否处于闲置状态。当用户有一段时间未触摸应用时，系统便会作出此判定。</p>
<ul>
<li>退出和限制</li>
</ul>
<p>当用户将设备插入电源时，系统会从待机状态释放应用，允许它们自由访问网络并执行任何待处理的作业和同步。如果设备长时间处于闲置状态，系统将允许闲置应用访问网络，频率大约每天一次。</p>
<ul>
<li>排除条件</li>
</ul>
<p>（1）用户明确启动应用。</p>
<p>（2）应用当前有一个进程在前台运行（作为活动或前台服务，或者正在由其他活动或前台服务使用）。<br>注意：您只能将前台服务用于用户希望系统立即执行或不中断的任务。此类情况包括将照片上传到社交媒体，或者即使在音乐播放器应用不在前台运行时也能播放音乐。您不应该只是为了阻止系统判定您的应用处于闲置状态而启动前台服务。</p>
<p>（3）应用生成用户可在锁定屏幕或通知栏中看到的通知。</p>
<p>（4）应用是正在使用中的设备管理应用（例如设备策略控制器）。虽然设备管理应用通常在后台运行，但永远不会进入应用待机模式，因为它们必须保持可用性，以便随时从服务器接收策略。</p>
<h2 id="Android-7"><a href="#Android-7" class="headerlink" title="Android 7"></a>Android 7</h2><h3 id="增强了-Doze"><a href="#增强了-Doze" class="headerlink" title="增强了 Doze"></a>增强了 Doze</h3><p>通过在设备未插接电源且屏幕关闭状态下、但不一定要处于静止状态（例如用户外出时把手持式设备装在口袋里）时应用部分 CPU 和网络限制，进一步增强了低电耗模式。</p>
<ul>
<li>限制</li>
</ul>
<p>当设备处于充电状态且屏幕已关闭一定时间后，设备会进入低电耗模式并应用第一部分限制：关闭应用网络访问、推迟作业和同步。如果进入低电耗模式后设备处于静止状态达到一定时间，系统则会对 PowerManager.WakeLock、AlarmManager 闹铃、GPS 和 WLAN 扫描应用余下的低电耗模式限制。无论是应用部分还是全部低电耗模式限制，系统都会唤醒设备以提供简短的维护时间窗口，在此窗口期间，应用程序可以访问网络并执行任何被推迟的作业/同步。</p>
<h3 id="移除了三项隐式广播"><a href="#移除了三项隐式广播" class="headerlink" title="移除了三项隐式广播"></a>移除了三项隐式广播</h3><p>CONNECTIVITY_ACTION<br>对于 target 7.0 的应用，通过静态注册的广播，无法接收到  CONNECTIVITY_ACTION 广播；应用无法接收到 ACTION_NEW_PICTURE 或 ACTION_NEW_VIDEO 的广播</p>
<h2 id="Android-8"><a href="#Android-8" class="headerlink" title="Android 8"></a>Android 8</h2><h3 id="后台执行限制"><a href="#后台执行限制" class="headerlink" title="后台执行限制"></a>后台执行限制</h3><p>（1）前台应用</p>
<p>a）具有可见 Activity（不管该 Activity 已启动还是已暂停）。</p>
<p>b）具有前台 Service。</p>
<p>c）另一个前台应用已关联到该应用（不管是通过绑定到其中一个 Service，还是通过使用其中一个内容提供程序）。 例如，如果另一个应用绑定到该应用的 Service，那么该应用处于前台：<br>IME<br>壁纸 Service<br>通知侦听器<br>语音或文本 Service</p>
<ul>
<li>限制</li>
</ul>
<p>处于前台时，应用可以自由创建和运行前台与后台 Service。 进入后台时，在一个持续数分钟的时间窗内，应用仍可以创建和使用 Service。 在该时间窗结束后，应用将被视为处于空闲状态。 此时，系统将停止应用的后台 Service，就像应用已经调用 Service 的 Service.stopSelf() 方法一样。</p>
<p>在这些情况下，后台应用将被置于一个临时白名单中并持续数分钟。 位于白名单中时，应用可以无限制地启动 Service，并且其后台 Service 也可以运行。</p>
<h3 id="后台位置限制"><a href="#后台位置限制" class="headerlink" title="后台位置限制"></a>后台位置限制</h3><p>降低了后台应用接收位置更新的频率</p>
<h3 id="升级隐式广播限制"><a href="#升级隐式广播限制" class="headerlink" title="升级隐式广播限制"></a>升级隐式广播限制</h3><ul>
<li>限制</li>
</ul>
<p>（1）适配 Android 8.0 或更高版本的应用无法继续在其清单中为隐式广播注册广播接收器。 隐式广播是一种不专门针对该应用的广播。 例如，ACTION_PACKAGE_REPLACED 就是一种隐式广播，因为该广播将被发送给所有已注册侦听器，让后者知道设备上的某些软件包已被替换。 不过，ACTION_MY_PACKAGE_REPLACED 不是隐式广播，因为不管已为该广播注册侦听器的其他应用有多少，它都会只被发送给软件包已被替换的应用。</p>
<p>（2）应用可以继续在它们的清单中注册显式广播。</p>
<p>（3）应用可以在运行时使用 Context.registerReceiver() 为任意广播（不管是隐式还是显式）注册接收器。</p>
<p>（4）需要签名权限的广播不受此限制所限，因为这些广播只会发送到使用相同证书签名的应用，而不是发送到设备上的所有应用。</p>
<p>以下链接可以查看隐式广播的例外<br><a href="https://developer.android.com/guide/components/broadcast-exceptions" target="_blank" rel="noopener">https://developer.android.com/guide/components/broadcast-exceptions</a></p>
<h2 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h2><h3 id="电源管理"><a href="#电源管理" class="headerlink" title="电源管理"></a>电源管理</h3><h4 id="应用待机群组"><a href="#应用待机群组" class="headerlink" title="应用待机群组"></a>应用待机群组</h4><p>Android 9 引入了一项新的电池管理功能，即应用待机群组。 应用待机群组可以基于应用最近使用时间和使用频率，帮助系统排定应用请求资源的优先级。 根据使用模式，每个应用都会归类到五个优先级群组之一中。 系统将根据应用所属的群组限制每个应用可以访问的设备资源</p>
<p>五个群组按照以下特性将应用分组：</p>
<p><strong>活跃</strong></p>
<p>如果用户当前正在使用应用，应用将被归到“活跃”群组中，例如：</p>
<ul>
<li>应用已启动一个 Activity</li>
<li>应用正在运行前台服务</li>
<li>应用的同步适配器与某个前台应用使用的 content provider 关联</li>
<li>用户在应用中点击了某个通知</li>
</ul>
<p>如果应用处于“活跃”群组，系统不会对应用的作业、报警或 FCM 消息施加任何限制。</p>
<p><strong>工作集</strong></p>
<p>如果应用经常运行，但当前未处于活跃状态，它将被归到“工作集”群组中。 例如，用户在大部分时间都启动的某个社交媒体应用可能就属于“工作集”群组。 如果应用被间接使用，它们也会被升级到“工作集”群组中 。</p>
<p>如果应用处于“工作集”群组，系统会对它运行作业和触发报警的能力施加轻度限制。 如需了解详细信息，请参阅电源管理限制。</p>
<p>常用<br>如果应用会定期使用，但不是每天都必须使用，它将被归到“常用”群组中。 例如，用户在健身房运行的某个锻炼跟踪应用可能就属于“常用”群组。</p>
<p>如果应用处于“常用”群组，系统将对它运行作业和触发报警的能力施加较强的限制，也会对高优先级 FCM 消息的数量设定限制。 如需了解详细信息，请参阅电源管理限制。</p>
<p>极少使用<br>如果应用不经常使用，那么它属于“极少使用”群组。 例如，用户仅在入住酒店期间运行的酒店应用就可能属于“极少使用”群组。</p>
<p>如果应用处于“极少使用”群组，系统将对它运行作业、触发警报和接收高优先级 FCM 消息的能力施加严格限制。系统还会限制应用连接到网络的能力。 如需了解详细信息，请参阅电源管理限制。</p>
<p>从未使用<br>安装但是从未运行过的应用会被归到“从未使用”群组中。 系统会对这些应用施加极强的限制。</p>
<p>以下链接可以查看电源管理限制<br><a href="https://developer.android.com/topic/performance/power/power-details" target="_blank" rel="noopener">https://developer.android.com/topic/performance/power/power-details</a></p>
<h4 id="省电模式改进"><a href="#省电模式改进" class="headerlink" title="省电模式改进"></a>省电模式改进</h4><p>开启省电模式后，系统会对所有应用施加限制。 这是一项已有的功能，但在 Android 9 中得到了改进</p>
<h3 id="后台对传感器的访问受限"><a href="#后台对传感器的访问受限" class="headerlink" title="后台对传感器的访问受限"></a>后台对传感器的访问受限</h3><p>Android 9 限制后台应用访问用户输入和传感器数据的能力。 如果您的应用在运行 Android 9 设备的后台运行，系统将对您的应用采取以下限制：</p>
<ul>
<li>您的应用不能访问麦克风或摄像头。</li>
<li>使用连续报告模式的传感器（例如加速度计和陀螺仪）不会接收事件。</li>
<li>使用变化或一次性报告模式的传感器不会接收事件。</li>
</ul>
<p>如果您的应用需要在运行 Android 9 的设备上检测传感器事件，请使用前台服务。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-framework-battery-app/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-framework-battery-app/" itemprop="url">Android App 耗电计算</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T22:27:08+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/" itemprop="url" rel="index">
                    <span itemprop="name">framework</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/framework/%E8%80%97%E7%94%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index">
                    <span itemprop="name">耗电分析</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Android 中对组件的耗电时间统计是由 BatteryStatusService 完成的，真正完成耗时统计的是类 BatteryStatsImpl 类。系统耗电排行中显示的耗电信息是通过 BatteryStatsHelper 类中相关的函数完成的。后面会分别分析 App 耗电和 硬件耗电，本文首先分析 App 耗电。</p>
<h2 id="耗电计算"><a href="#耗电计算" class="headerlink" title="耗电计算"></a>耗电计算</h2><p>App 耗电也称软件耗电，分别统计不同应用的耗电情况，系统通过 BatterStatsHelper 的 processAppUsage 函数，去更新不同应用的耗电信息，然后显示其排行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processAppUsage</span><span class="params">(SparseArray&lt;UserHandle&gt; asUsers)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> iu = <span class="number">0</span>; iu &lt; NU; iu++) &#123;</span><br><span class="line">		<span class="comment">// 统计每一个应用的耗电信息</span></span><br><span class="line">        <span class="keyword">final</span> Uid u = uidStats.valueAt(iu);</span><br><span class="line">        <span class="keyword">final</span> BatterySipper app = <span class="keyword">new</span> BatterySipper(BatterySipper.DrainType.APP, u, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// CPU </span></span><br><span class="line">        mCpuPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// WakeLock</span></span><br><span class="line">        mWakelockPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 移动网络</span></span><br><span class="line">        mMobileRadioPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">		<span class="comment">// wifi</span></span><br><span class="line">        mWifiPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 蓝牙</span></span><br><span class="line">        mBluetoothPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">		<span class="comment">// 传感器</span></span><br><span class="line">        mSensorPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 相机</span></span><br><span class="line">        mCameraPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">		<span class="comment">// 闪光灯</span></span><br><span class="line">        mFlashlightPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs,</span><br><span class="line">                mStatsType);</span><br><span class="line">		<span class="comment">// 多媒体</span></span><br><span class="line">        mMediaPowerCalculator.calculateApp(app, u, mRawRealtimeUs, mRawUptimeUs, mStatsType);</span><br><span class="line">        <span class="comment">// 统计总的耗电</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">double</span> totalPower = app.sumPower();</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有 Uid 类，可以将这个类的实例理解为一个应用， processAppUsage 函数循环遍历每一个应用，分别统计不同应用不同组件的耗电。每一个应用会分别计算应用的 CPU，Wakelock，移动网络，wifi，传感器，相机，闪光灯，多媒体的耗电情况，最后将这些组件的耗电相加便得到了应用的总耗电，前面已经分析过，Android 计算耗电实际上就是计算不同组件在不同状态的工作时间，下面在分析不同组件的耗电，也是沿着这样的思路。在分析每一个组件的耗电，只会列出最核心的代码，</p>
<h2 id="组件耗电"><a href="#组件耗电" class="headerlink" title="组件耗电"></a>组件耗电</h2><h3 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">        app.cpuTimeMs = (u.getUserCpuTimeUs(statsType) + u.getSystemCpuTimeUs(statsType)) / <span class="number">1000</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> numClusters = mProfile.getNumCpuClusters();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">double</span> cpuPowerMaUs = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> cluster = <span class="number">0</span>; cluster &lt; numClusters; cluster++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> speedsForCluster = mProfile.getNumSpeedStepsInCpuCluster(cluster);</span><br><span class="line">            <span class="comment">// 计算不同主频下 CPU 的耗电</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> speed = <span class="number">0</span>; speed &lt; speedsForCluster; speed++) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">long</span> timeUs = u.getTimeAtCpuSpeed(cluster, speed, statsType);</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">double</span> cpuSpeedStepPower = timeUs *</span><br><span class="line">                        mProfile.getAveragePowerForCpuCore(cluster, speed);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                    Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": CPU cluster #"</span> + cluster + <span class="string">" step #"</span></span><br><span class="line">                            + speed + <span class="string">" timeUs="</span> + timeUs + <span class="string">" power="</span></span><br><span class="line">                            + BatteryStatsHelper.makemAh(cpuSpeedStepPower / MICROSEC_IN_HR));</span><br><span class="line">                &#125;</span><br><span class="line">                cpuPowerMaUs += cpuSpeedStepPower;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cpuPowerMaUs += u.getCpuActiveTime() * <span class="number">1000</span> * mProfile.getAveragePower(</span><br><span class="line">                PowerProfile.POWER_CPU_ACTIVE);</span><br><span class="line">        <span class="keyword">long</span>[] cpuClusterTimes = u.getCpuClusterTimes();</span><br><span class="line">        <span class="comment">// 计算各个 Cluster 的平均耗电</span></span><br><span class="line">        <span class="keyword">if</span> (cpuClusterTimes != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cpuClusterTimes.length == numClusters) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClusters; i++) &#123;</span><br><span class="line">                    <span class="keyword">double</span> power =</span><br><span class="line">                            cpuClusterTimes[i] * <span class="number">1000</span> * mProfile.getAveragePowerForCpuCluster(i);</span><br><span class="line">                    cpuPowerMaUs += power;</span><br><span class="line">                    <span class="keyword">if</span> (DEBUG) &#123;</span><br><span class="line">                        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": CPU cluster #"</span> + i + <span class="string">" clusterTimeUs="</span></span><br><span class="line">                                + cpuClusterTimes[i] + <span class="string">" power="</span></span><br><span class="line">                                + BatteryStatsHelper.makemAh(power / MICROSEC_IN_HR));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">" CPU cluster # mismatch: Power Profile # "</span></span><br><span class="line">                        + numClusters + <span class="string">" actual # "</span> + cpuClusterTimes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        app.cpuPowerMah = cpuPowerMaUs / MICROSEC_IN_HR;</span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，CPU 耗电计算了 CPU 在不同核心在不同主频下的耗电，并将这些耗电相加。</p>
<h3 id="Wakelock"><a href="#Wakelock" class="headerlink" title="Wakelock"></a>Wakelock</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> wakeLockTimeUs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> ArrayMap&lt;String, ? extends BatteryStats.Uid.Wakelock&gt; wakelockStats =</span><br><span class="line">            u.getWakelockStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> wakelockStatsCount = wakelockStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; wakelockStatsCount; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Wakelock wakelock = wakelockStats.valueAt(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Only care about partial wake locks since full wake locks</span></span><br><span class="line">        <span class="comment">// are canceled when the user turns the screen off.</span></span><br><span class="line">        BatteryStats.Timer timer = wakelock.getWakeTime(BatteryStats.WAKE_TYPE_PARTIAL);</span><br><span class="line">        <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            wakeLockTimeUs += timer.getTotalTimeLocked(rawRealtimeUs, statsType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    app.wakeLockTimeMs = wakeLockTimeUs / <span class="number">1000</span>; <span class="comment">// convert to millis</span></span><br><span class="line">    mTotalAppWakelockTimeMs += app.wakeLockTimeMs;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add cost of holding a wake lock.</span></span><br><span class="line">    app.wakeLockPowerMah = (app.wakeLockTimeMs * mPowerWakelock) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wakeLockPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": wake "</span> + app.wakeLockTimeMs</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(app.wakeLockPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Wakelock 的耗电逻辑比叫简单，但是这里有一个需要注意的位置，在统计 Wakelock 的耗电时，仅仅统计了 PARTIAL 类型的 Wakelock 的耗时，这就给我们使用 Wakelock 的策略提供了思路。</p>
<h3 id="移动网络"><a href="#移动网络" class="headerlink" title="移动网络"></a>移动网络</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Add cost of mobile traffic.</span></span><br><span class="line">    app.mobileRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileActive = u.getMobileRadioActiveTime(statsType) / <span class="number">1000</span>;</span><br><span class="line">    app.mobileActiveCount = u.getMobileRadioActiveCount(statsType);</span><br><span class="line">    app.mobileRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_MOBILE_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.mobileTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_MOBILE_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app.mobileActive &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// We are tracking when the radio is up, so can use the active time to</span></span><br><span class="line">        <span class="comment">// determine power use.</span></span><br><span class="line">        mTotalAppMobileActiveMs += app.mobileActive;</span><br><span class="line">        app.mobileRadioPowerMah = (app.mobileActive * mPowerRadioOn) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// We are not tracking when the radio is up, so must approximate power use</span></span><br><span class="line">        <span class="comment">// based on the number of packets.</span></span><br><span class="line">        app.mobileRadioPowerMah = (app.mobileRxPackets + app.mobileTxPackets)</span><br><span class="line">                * getMobilePowerPerPacket(rawRealtimeUs, statsType);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.mobileRadioPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": mobile packets "</span></span><br><span class="line">                + (app.mobileRxPackets + app.mobileTxPackets)</span><br><span class="line">                + <span class="string">" active time "</span> + app.mobileActive</span><br><span class="line">                + <span class="string">" power="</span> + BatteryStatsHelper.makemAh(app.mobileRadioPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>无线电耗电的计算分两种情况，如果 mobileActive &gt; 0 即 无线电处于 active 状态时，直接使用无线电处于 active 的时间乘以无线电在 active 时的功率 mPowerRadioOn 即可，如果未处于 active ，则使用收发的数据包数量乘以收发数据包的平均功率。</p>
<h3 id="wifi"><a href="#wifi" class="headerlink" title="wifi"></a>wifi</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = u.getWifiControllerActivity();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// wifi 处于空闲的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTime = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="comment">// wifi 发送数据包的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTime = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="comment">// wifi 接收数据包的时间</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTime = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="comment">// wifi 总运行时间</span></span><br><span class="line">    app.wifiRunningTimeMs = idleTime + rxTime + txTime;</span><br><span class="line">    mTotalAppRunningTime += app.wifiRunningTimeMs;</span><br><span class="line">    <span class="comment">// wifi 的总耗电</span></span><br><span class="line">    app.wifiPowerMah =</span><br><span class="line">            ((idleTime * mIdleCurrentMa) + (txTime * mTxCurrentMa) + (rxTime * mRxCurrentMa))</span><br><span class="line">            / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    mTotalAppPowerDrain += app.wifiPowerMah;</span><br><span class="line"></span><br><span class="line">    app.wifiRxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxPackets = u.getNetworkActivityPackets(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_RX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line">    app.wifiTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_WIFI_TX_DATA,</span><br><span class="line">            statsType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG &amp;&amp; app.wifiPowerMah != <span class="number">0</span>) &#123;</span><br><span class="line">        Log.d(TAG, <span class="string">"UID "</span> + u.getUid() + <span class="string">": idle="</span> + idleTime + <span class="string">"ms rx="</span> + rxTime + <span class="string">"ms tx="</span> +</span><br><span class="line">                txTime + <span class="string">"ms power="</span> + BatteryStatsHelper.makemAh(app.wifiPowerMah));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>wifi 的工作状态氛围空闲 idle，发送数据包 tx，接收数据包 如下，wifi 耗电的计算也分别计算了 wifi 在空闲，发送数据包和接收数据包时的耗电，最后计算了 wifi 收发的数据包。</p>
<h3 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.ControllerActivityCounter counter = u.getBluetoothControllerActivity();</span><br><span class="line">    <span class="keyword">if</span> (counter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> idleTimeMs = counter.getIdleTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> rxTimeMs = counter.getRxTimeCounter().getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> txTimeMs = counter.getTxTimeCounters()[<span class="number">0</span>].getCountLocked(statsType);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> totalTimeMs = idleTimeMs + txTimeMs + rxTimeMs;</span><br><span class="line">    <span class="keyword">double</span> powerMah = counter.getPowerCounter().getCountLocked(statsType)</span><br><span class="line">            / (<span class="keyword">double</span>)(<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (powerMah == <span class="number">0</span>) &#123;</span><br><span class="line">        powerMah = ((idleTimeMs * mIdleMa) + (rxTimeMs * mRxMa) + (txTimeMs * mTxMa))</span><br><span class="line">                / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    app.bluetoothPowerMah = powerMah;</span><br><span class="line">    app.bluetoothRunningTimeMs = totalTimeMs;</span><br><span class="line">    app.btRxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_BT_RX_DATA, statsType);</span><br><span class="line">    app.btTxBytes = u.getNetworkActivityBytes(BatteryStats.NETWORK_BT_TX_DATA, statsType);</span><br><span class="line"></span><br><span class="line">    mAppTotalPowerMah += powerMah;</span><br><span class="line">    mAppTotalTimeMs += totalTimeMs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>蓝牙耗电的计算和 wifi 类似，蓝牙的工作状态也分为空闲 idle ，发送 tx，接收 rx，在计算蓝牙耗电时也分别计算了蓝牙在 idle ，tx，rx 时的耗电，最后将这些耗电进行相加。</p>
<h3 id="传感器"><a href="#传感器" class="headerlink" title="传感器"></a>传感器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Process Sensor usage</span></span><br><span class="line">    <span class="keyword">final</span> SparseArray&lt;? extends BatteryStats.Uid.Sensor&gt; sensorStats = u.getSensorStats();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> NSE = sensorStats.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ise = <span class="number">0</span>; ise &lt; NSE; ise++) &#123;</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Uid.Sensor sensor = sensorStats.valueAt(ise);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> sensorHandle = sensorStats.keyAt(ise);</span><br><span class="line">        <span class="keyword">final</span> BatteryStats.Timer timer = sensor.getSensorTime();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> sensorTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (sensorHandle) &#123;</span><br><span class="line">            <span class="keyword">case</span> BatteryStats.Uid.Sensor.GPS:</span><br><span class="line">                app.gpsTimeMs = sensorTime;</span><br><span class="line">                app.gpsPowerMah = (app.gpsTimeMs * mGpsPower) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> sensorsCount = mSensors.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sensorsCount; i++) &#123;</span><br><span class="line">                    <span class="keyword">final</span> Sensor s = mSensors.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (s.getHandle() == sensorHandle) &#123;</span><br><span class="line">                        app.sensorPowerMah += (sensorTime * s.getPower()) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里传感器耗电分为两种：GPS ，其他传感器，GPS 的耗电记录在 PowerProfile.xml 文件中，保存在 mGpsPower 中，其他传感器的计算根据SensorManager得到所有传感器类型，这个里面保存有不同传感器的单位耗电量，这样就能计算不同传感器的耗电量。</p>
<h3 id="相机"><a href="#相机" class="headerlink" title="相机"></a>相机</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate camera power usage.  Right now, this is a (very) rough estimate based on the</span></span><br><span class="line">    <span class="comment">// average power usage for a typical camera application.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer timer = u.getCameraTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.cameraTimeMs = totalTime;</span><br><span class="line">        app.cameraPowerMah = (totalTime * mCameraPowerOnAvg) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app.cameraTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.cameraPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相机的耗电首先计算出相机工作的时间，然后乘以相机的平均耗电。</p>
<h3 id="闪光灯"><a href="#闪光灯" class="headerlink" title="闪光灯"></a>闪光灯</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate flashlight power usage.  Right now, this is based on the average power draw</span></span><br><span class="line">    <span class="comment">// of the flash unit when kept on over a short period of time.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer timer = u.getFlashlightTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (timer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = timer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.flashlightTimeMs = totalTime;</span><br><span class="line">        app.flashlightPowerMah = (totalTime * mFlashlightPowerOnAvg) / (<span class="number">1000</span>*<span class="number">60</span>*<span class="number">60</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        app.flashlightTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.flashlightPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>闪光灯的耗电和相机类似，先计算相机工作的时间，然后乘以相机的平均耗电。</p>
<h3 id="多媒体"><a href="#多媒体" class="headerlink" title="多媒体"></a>多媒体</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">calculateApp</span><span class="params">(BatterySipper app, BatteryStats.Uid u, <span class="keyword">long</span> rawRealtimeUs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">long</span> rawUptimeUs, <span class="keyword">int</span> statsType)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Calculate audio power usage, an estimate based on the average power routed to different</span></span><br><span class="line">    <span class="comment">// components like speaker, bluetooth, usb-c, earphone, etc.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer audioTimer = u.getAudioTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (audioTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.audioTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.audioPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = audioTimer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.audioTimeMs = totalTime;</span><br><span class="line">        app.audioPowerMah = (totalTime * mAudioAveragePowerMa) / MS_IN_HR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Calculate video power usage.</span></span><br><span class="line">    <span class="keyword">final</span> BatteryStats.Timer videoTimer = u.getVideoTurnedOnTimer();</span><br><span class="line">    <span class="keyword">if</span> (videoTimer == <span class="keyword">null</span>) &#123;</span><br><span class="line">        app.videoTimeMs = <span class="number">0</span>;</span><br><span class="line">        app.videoPowerMah = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> totalTime = videoTimer.getTotalTimeLocked(rawRealtimeUs, statsType) / <span class="number">1000</span>;</span><br><span class="line">        app.videoTimeMs = totalTime;</span><br><span class="line">        app.videoPowerMah = (totalTime * mVideoAveragePowerMa) / MS_IN_HR;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>多媒体耗电分别计算音频和视频的耗电，耗电的计算方法和闪光灯和相机类似，分别计算出工作时间，然后乘以平均能耗。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android App 耗电的分析初步写完了。其实耗电的计算也没有那么复杂，和我们平时生活中的耗电计算的思路是相同的，唯一不同的是这里计算的是移动设备。</p>
<p>Android 系统中，不同组件的耗电功率数据通过记录在文件 PowerProfile.xml 文件中，PowerProfile.xml 文件是进行耗电分析的基础，如果这个文件的数据有问题，那么我们的分析结果就是有问题，这也提醒我们，一些小的或者不知名的厂商，他们的耗电数据可能是不准确的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-summary/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-summary/" itemprop="url">Android 容器总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T21:10:55+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>相较于其他设备，移动设备有自己的特点，内存小是一个很突出的问题，Google针对android设备的这一特点，开发了一套容器框架，目的就是为了更加高效地利用内存。接下来就对这些容器进行一下总结。</p>
<h2 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/android_container.png" alt=""><br>以上是android中容器的实现继承结构，简单梳理一下：</p>
<ul>
<li>ArraySet 实现了 Set 和 Collections 接口，在api 23中添加</li>
<li>ArrayMap 实现了 Map 接口，在api 19中添加</li>
<li>SparseArray ， SparseIntArray ， SparseBooleanArray 实现了 Cloneable 接口，在api 1中添加</li>
<li>SparseLong 实现了 Cloneable 接口，在api 18中添加</li>
</ul>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>从功能上划分，可以将以上容器划分为两类：</p>
<ul>
<li><p>存储元素<br> ArraySet 优化了 HashSet 对元素的存储</p>
</li>
<li><p>存储键值对</p>
<p>相较于 HashMap ，具体的优化方向如下：</p>
<p> ArrayMap 优化了 HashMap 存储 Object –&gt; Object 的键值存储；<br> SparseArray 优化了 int –&gt; Object 的键值存储；<br> SparseIntArray 优化了 int –&gt; int 的键值存储；<br> SparseBooleanArray 优化了  int –&gt; boolean 的键值存储；<br> SparseLongArray 优化了  int –&gt; long 的键值存储</p>
</li>
</ul>
<h2 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h2><p>从组织结构可以看出，可以将这些容器分为3类： ArraySet , ArrayMap 和剩余的容器。通过前面的分析可以知道， ArraySet 和 ArrayMap 使用的相同的优化方式， SparseArray 在进行优化的时候使用 gc 垃圾回收策略，故从优化方法上进行分类的话可以分一下三类：</p>
<ul>
<li>ArraySet ,  ArrayMap<br>使用数组 mKeys 存储 key 的hash值，hash 值在 mKeys 的位置为 index，并将 value 存储到 mValues 数组对应下标的位置（ ArrayMap 中 key 和 value 分别在 mValues 的 index * 2 和 index * 2 + 1 的位置）。查找或者修改元素时，使用二分查找在 mKeys 中找到元素在 mValues 的下标，然后进行修改或者返回。</li>
<li>SparseArray<br>使用 int 类型的 mKeys 数组存储 int 类型的键，下标为 index ，将 Object 类型的 value 存储在在 Object 类型的数组 mValues 的 index 位置，在查找和修改时，使用二分查找在 mKeys 中找到元素在 Values 的下标，然后进行修改或者返回。在删除 value 时， SparseArray 并不直接进行数组元素的移动，而是将待删除的 value 标记为DELETED 状态，在 gc 的过程中将所有非 DELETED 状态的元素移动到数组的最前面，从而减少二分查找的时间。</li>
<li>SparseIntArray,  SparseLongArray ,  SparseBooleanArray<br>这3个容器可以理解成专用容器，使用 int 类型数组和对应类型的数组；使用二分查找快速查找元素，然后进行删除，修改，添加操作。</li>
</ul>
<h2 id="优化共同点与差异"><a href="#优化共同点与差异" class="headerlink" title="优化共同点与差异"></a>优化共同点与差异</h2><p>虽然这些容器存储的元素类型不同，但是通过分析可以发现他们在内存优化中的共同点，接下来就分析下这些容器在优化上存在的共同点和差异。</p>
<p> <strong>共同点</strong></p>
<ul>
<li><p>数据结构<br><img src="https://raw.githubusercontent.com/rockstore/images/master/data_h_v2.png" alt=""><br>这里的数据结构是指容器的底层存储结构，虽然在 ArrayMap 中 mValues 的长度是 mKeys 的 2 倍，但也仅仅是数组长度上的差异，底层存储使用的思想仍然是一样的；int 类型的数组 mKeys 里的元素时按照升序进行排列的。相较于 HashMap 使用 Node 结构存储，这样的存储方式使用更小的存储空间存储 k-v ，同时避免了原始数据类型的自动装箱。</p>
</li>
<li><p>查找方法<br>在组织结构中列出的容器，他们在进行元素查找时，都会先在 mKeys 数组中利用二分查找找到元素的下标 index ，然后使用 index 到 mValues 数组中对 value 进行操作。</p>
</li>
<li><p>获取带插入下标<br>在进行元素插入时，会首先使用二分查找在 mKeys 数组中查找元素的下标，如果元素不存在，则二分查找会返回元素待插入位置的取反。</p>
<br>

</li>
</ul>
<p><strong>不同点</strong></p>
<ul>
<li>对 key的处理<br>ArraySet,  ArrayMap 底层实现时，会计算待插入元素的 hash 值，根据 hash 值，在 mKeys 找到待插入位置；SparseArray 和 SparseXXXArray 存储的时候直接使用 key 值，不会进行 hash 计算。</li>
<li>对 null 的处理<br>ArraySet 和 ArrayMap 允许插入 key 为 null 的元素， key 的 hash 值为 0； SparseArray 和 SparseXXXArray 存储的时由于直接使用int类型的数据作为key ，故不存在 key 为 null 的情况。</li>
<li>缓存<br>为了避免频繁的内存回收，ArraySet 和 ArrayMap 添加了缓存结构，SparseArray 和 SparseXXXArray 没有缓存</li>
<li>扩容规则<br>ArraySet 和 ArrayMap 在进行扩容的时，容量的变化规则为 4, 8 , size * 2 / 3 ， SparseArray 和 SparseXXXArray 使用 ArrayUtils.newUnpaddedArray 建立新的数据，将原来的数据拷贝到新数组中。</li>
</ul>
<h2 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h2><p>虽然这些容器在Android设备上可以更高效地利用内存，但是还是存在使用使用限制。</p>
<ul>
<li>兼容性<br>在组织结构中，可以看到，并不是所有的容器都是从api 1就开始提供的，在使用具体的容器时，需要考虑应用的兼容。</li>
<li>对性能的影响<br>虽然 ArrayMap 在删除时不直接使用移动元素的方式删除元素，但是在获取数组元素等操作中还是</li>
<li>对数量的限制<br>在对元素进行查找时会使用二分查找，元素数量较大（超过1000）时，查找效率会降低，相较于<code>HashMap</code>只要数量不超过1000，效率最多不会下降50%。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>前面说了很多，其实android容器优化的根本思想就是使用 int 到其他类型的映射，使用数组保存着两个映射，用以优化 HashMap 对 k-v 的存储。这种优化适用于元素数量较少（少于1000）的情况。</p>
<p>以上所写是我的个人总结，可能有总结不到位的情况，有任何问题感谢大家及时向我反馈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-sparseintarray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-sparseintarray/" itemprop="url">Android SparseIntArray</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T21:07:03+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>  SparseArray  优化了  int  到  Object  键值对的存储，  SparseIntArray  优化了  int  到  int  键值对的存储。android中在键值对存储上的优化主要做了一下几种类型的优化:</p>
<ul>
<li>int   –&gt;   Object  (SparseArray)</li>
<li>int   –&gt;   int  (SparseIntArray)</li>
<li>int   –&gt;   boolean  (SparseBooleanArray)</li>
<li>int   –&gt;   long  (SparseLongArray)</li>
<li>int   –&gt;   Set  (SparseSetArray)</li>
</ul>
<p>SparseSetArray 目前在sdk中还处于hide状态，故在做总结的时候就不分析它了。</p>
<p>之前已经分析过  SparseArray  ，本文就分析下  SparseIntArray  的实现，并在最后总结下这几种键值对在实现上的共同点。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/SparseIntArray_h.png" alt=""></p>
<br>
以上为  SparseIntArray  的继承体系。  SparseIntArray  只实现了  Cloneable  接口，结构比较简单。其实阅读源码可以发现，  SparseArray  ，  SparseIntArray  ，  SparseBooleanArray  ，  SparseLongArray  都只实现了  Cloneable  接口。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="https://raw.githubusercontent.com/rockstore/images/master/SparseIntArray_s.png" alt=""></p>
<br>
以上为  SparseIntArray  的存储结构，mKeys存储的是int类型的键，mValues存储的是int类型的value。

<h2 id="元素查找"><a href="#元素查找" class="headerlink" title="元素查找"></a>元素查找</h2><pre><code>// 查找键key在mKeys的下标
public int indexOfKey(int key) {
    return ContainerHelpers.binarySearch(mKeys, mSize, key);
}

// 查找value在mValues的下标
public int indexOfValue(int value) {
    for (int i = 0; i &lt; mSize; i++)
        if (mValues[i] == value)
            return i;
    return -1;
}</code></pre><p>元素的查找分键查找和值查找，键查找使用二分查找，值查找直接使用循环遍历。</p>
<h2 id="添加元素"><a href="#添加元素" class="headerlink" title="添加元素"></a>添加元素</h2><pre><code>public void put(int key, int value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        mValues[i] = value;
    } else {
        i = ~i;

        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}</code></pre><p>添加元素首先使用二分查找找到key在mKeys数组的下标，也就是value在mValues数组的下标。如果   ContainerHelpers.binarySearch(mKeys, mSize, key)  在mKeys数组中没有找到key，则返回key待插入位置的下标的取反，如果找到了key，则直接更新mValues对应位置的值即可。<br>  GrowingArrayUtils.insert  函数的实现如下：</p>
<pre><code>public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize &lt;= array.length;

    if (currentSize + 1 &lt;= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    }

    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}</code></pre><p>函数的逻辑很简单，首先断言了currentSize &lt;= array.length；如果array在不需要扩大容量的情况下可以添加一个元素，则先将待插入位置index开始的元素整体后移一位，然后插入元素，否则先扩容，然后将元素拷贝到新的数组中。</p>
<h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><pre><code>public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i &gt;= 0) {
        removeAt(i);
    }
}

public void removeAt(int index) {
    System.arraycopy(mKeys, index + 1, mKeys, index, mSize - (index + 1));
    System.arraycopy(mValues, index + 1, mValues, index, mSize - (index + 1));
    mSize--;
}</code></pre><p>删除元素主要涉及以上两个方法，  delete(int key)  根据  key  进行删除，  removeAt(int index)  删除指定下标的元素。这两个方法都是  public  ，故都可以直接使用。  delete(int key)  ，先使用二分查找，找到  key  在  mKeys  的下标，如果找到即  i &gt;= 0  ，则直接删除  mKeys  和  mValues  指定位置的元素。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>还有  SparseBooleanArray  ，  SparseLongArray  还没有分析，他们的实现规则是一样的，只是存储的数据类型的  mValues  数组是  boolean   和   long  ，接下来就对  SparseIntArray  ，  SparseBooleanArray  ，  SparseLongArray  进行下总结。</p>
<ul>
<li>他们的设计目的是优化  int  到  int  ,   boolean   ,  long  映射的存储</li>
<li>使用  int  类型的数组  mKeys  存储映射的键，使用对应类型的数组  mValues  存储值</li>
<li>int  类型的键在存储上是有顺序的</li>
<li>在查找值时，先使用二分查找，在  mKeys  中查找值在  mValues  中的下标，然后返回值</li>
</ul>
<p>以上三种数据类型和  SparseArray  最大的区别在于  SparseArray  在删除元素的时候会将元素设置为  DELETED  ，后续会有  gc  的过程。</p>
<p>相对于使用HashMap，这样的设计的优势和缺点：</p>
<p><strong>优势：</strong></p>
<ul>
<li>避免  int  类型的键自动装箱</li>
<li>相较于  HashMap  使用  Node  ，这样的设计使用更小的存储单元即可存储  key  到  value  的映射</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在进行元素查找时使用二分查找，元素较多（谷歌给出的数字是大于1000）时，查找效率较低</li>
<li>在进行元素的添加和删除时，可能会频繁进行元素的移动，运行效率可能会降低</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://rockstore.github.io/go/go/2020/05/11/android-collections-sparearray/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="rockstore">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/go/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Rock">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/go/2020/05/11/android-collections-sparearray/" itemprop="url">Android SpareArray</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-11T20:55:59+08:00">
                2020-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/" itemprop="url" rel="index">
                    <span itemprop="name">android</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/go/categories/android/collections/" itemprop="url" rel="index">
                    <span itemprop="name">collections</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> SparseArray 和其他的Android容器类一样，都是为了更加有效地利用内存，说直白点，就是为了节省内存。 SparseArray 和 ArrayMap 一样，都是为了更高效的保存int值到非原始类型的映射，用了同样的数据结构，但是为了提高效率， SparseArray 也做了自己的优化。接下来就分析一下 SparseArray 的存储，添加和删除元素。</p>
<h2 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h2><p><img src="http://p0.qhimg.com/t01ebe97cef584833f4.png" alt=""></p>
<br>
上图表明， SparseArray 并没有像 ArrayMap 一样实现 Map 接口，仅仅实现了 Cloneable 接口。

<h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p><img src="http://p0.qhimg.com/t0135547fb1e591cb0e.png" alt=""></p>
<br>
存储结构和 ArraySet 以及 ArrayMap 一脉相承，都使用int数组存储key值，使用Object数组存储对象。不同点在于 mKeys 数组中存储的是添加元素的key值本身，没有进行hash值得计算。


<h2 id="put"><a href="#put" class="headerlink" title="put"></a>put</h2><pre><code>public void put(int key, E value) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);

    if (i &gt;= 0) {
        mValues[i] = value;
    } else {
        i = ~i;

        if (i &lt; mSize &amp;&amp; mValues[i] == DELETED) {
            mKeys[i] = key;
            mValues[i] = value;
            return;
        }

        if (mGarbage &amp;&amp; mSize &gt;= mKeys.length) {
            gc();

            // Search again because indices may have changed.
            i = ~ContainerHelpers.binarySearch(mKeys, mSize, key);
        }

        mKeys = GrowingArrayUtils.insert(mKeys, mSize, i, key);
        mValues = GrowingArrayUtils.insert(mValues, mSize, i, value);
        mSize++;
    }
}</code></pre><p> put 方法首先使用二分查找在 mKeys 中查找 key ，如果找到，则直接更新对应下标的 value 。如果未找到， binarySearch 方法返回待插入的下标的取反，故 i = ~i 。如果待插入的位置的元素已经被标记为 DELETED ，则直接更新并返回。如果需要执行 gc 函数，且需要扩大数组的容量（ mSize &gt;= mKeys.lengt ），则先执行 gc 函数。由于执行 gc 函数之后元素会发生移动，故重新计算待插入位置，最后执行元素的插入。插入函数分为插入 key 和插入 value 。 GrowingArrayUtils.insert 的源码如下：</p>
<pre><code>public static int[] insert(int[] array, int currentSize, int index, int element) {
    assert currentSize &lt;= array.length;

    if (currentSize + 1 &lt;= array.length) {
        System.arraycopy(array, index, array, index + 1, currentSize - index);
        array[index] = element;
        return array;
    }

    int[] newArray = ArrayUtils.newUnpaddedIntArray(growSize(currentSize));
    System.arraycopy(array, 0, newArray, 0, index);
    newArray[index] = element;
    System.arraycopy(array, index, newArray, index + 1, array.length - index);
    return newArray;
}</code></pre><p>函数的逻辑很简单，首先断言了 currentSize &lt;= array.length ；如果 array 在不需要扩大容量的情况下可以添加一个元素，则先将待插入位置 index 开始的元素整体后移一位，然后插入元素，否则先扩容，然后将元素拷贝到新的数组中。</p>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><p>为什么删除的时候我没有使用一个具体的函数呢，是因为 SparseArray 的删除有两种：根据key删除对象，删除指定位置的对象。</p>
<h3 id="根据key删除对象"><a href="#根据key删除对象" class="headerlink" title="根据key删除对象"></a>根据key删除对象</h3><pre><code>public void delete(int key) {
    int i = ContainerHelpers.binarySearch(mKeys, mSize, key);
    if (i &gt;= 0) {
        if (mValues[i] != DELETED) {
            mValues[i] = DELETED;
            mGarbage = true;
        }
    }
}</code></pre><p> ContainerHelpers.binarySearch 函数在 ArraySet 和 ArrayMap 的元素查找中都出现过，作用是使用二分查找，在 mKeys 中找到 key 的位置，如果 key 存在，则返回 key 在 mKeys 中的下标，否则返回试图将 key 插入到 mKeys 中的位置的取反。找到待删除元素的下标后， SparseArray 并没有像 ArraySet 和 ArrayMap 一样去删除元素，只是将待删除元素标记为 DELETED ，然后将 mGarbage 设置为 true 。 DELETED 实际上就是一个对象，具体申明为：  Object DELETED =  new Object() ， SparseArray 有 gc 的过程，后面会分析这个 gc 的过程。</p>
<h3 id="删除执行位置的对象"><a href="#删除执行位置的对象" class="headerlink" title="删除执行位置的对象"></a>删除执行位置的对象</h3><pre><code>public void removeAt(int index) {
    if (mValues[index] != DELETED) {
        mValues[index] = DELETED;
        mGarbage = true;
    }
}</code></pre><p>删除指定位置元素的逻辑比较简单，判断待删除位置的元素是否已经被标记为 DELETED ，如果没有被标记，则标记指定位置的元素，并将 mGarbage 设置为 true 。</p>
<p>元素在被删除之后，都会将标志 mGarbage 设置为 true ，这是执行 gc 的必要条件。</p>
<h2 id="gc"><a href="#gc" class="headerlink" title="gc"></a>gc</h2><p>说到gc，给我的第一感觉应该是什么高深的c/c++源码，其实不是，贴上 gc 的源码</p>
<pre><code>private void gc() {
    int n = mSize;
    int o = 0;
    int[] keys = mKeys;
    Object[] values = mValues;

    for (int i = 0; i &lt; n; i++) {
        Object val = values[i];

        if (val != DELETED) {
            if (i != o) {
                keys[o] = keys[i];
                values[o] = val;
                values[i] = null;
            }
            o++;
        }
    }

    mGarbage = false;
    mSize = o;
}</code></pre><p>好吧，开始被自己给吓着了， gc 函数没有那么复杂。 gc 函数实际上就是将 mValues 数组中还未标记为 DELETED 的元素以及对应下标的 mKeys 数组中的元素移动到数组的前面，保证数组在0到 mSize 之间的元素都是未被标记为 DELETED ，经过 gc 之后，数据的位置可能会发生移动。</p>
<p>在元素被删除后，标志 mGarbage 设置为 true ，表示可以执行 gc 函数了。那么 gc 函数会在什么位置执行呢？<br>分析 SparseArray 源码可以发现，如果 mGarbage 设置为 true ，在以下函数调用中 gc 函数会执行：</p>
<p> put , append ，  size , keyAt , valueAt , setValueAt , indexOfKey , indexOfValue , indexOfValueByValue 。</p>
<p>将以上函数总结一下可以归纳为三类：</p>
<ul>
<li>向SparseArray添加元素</li>
<li>修改SparseArray的mValues数组</li>
<li>获取SparseArray的属性</li>
</ul>
<p>通过执行 gc 将未被标记为 DELETED 的元素前移，在进行元素查找时可以减少需要查找的元素的数量，减少查找的时间，在添加元素的时候也可以更加快速的找到待插入点。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> SparseArray 主要是为了优化 int 值到 Object 映射的存储，提高内存的使用效率。相较于 HashMap ，在存储上的优化如下：</p>
<ul>
<li>使用int和Object类型的数组分别存储key和value，相较于 HashMap 使用Node， SparseArray 在存储单个key-value时更节省内存</li>
<li>SparseArray 使用int数组存储int类型的key，避免了int到Integer的自动装箱机制</li>
</ul>
<p>虽然在存储int到Object映射时的内存使用效率更高，由于使用数组存储数组，在添加或者删除元素时需要进行二分查找，元素较多（超过1000）是效率较低，谷歌给出的建议是数据量不要超过1000，这种情况下，相较于 HashMap ,效率降低不会超过50%</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/go/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/go/page/4/">4</a><a class="extend next" rel="next" href="/go/page/2/">&gt;</a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">rockstore</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/go/archives%7C%7C%20archive">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/go/categories/index.html">
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/go/tags/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">rockstore</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/go/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/go/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/go/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/go/js/src/motion.js?v=5.1.4"></script>



  
  

  

  


  <script type="text/javascript" src="/go/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
